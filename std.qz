struct string {
    data: bytes,
}

func (s: string) len(): int {
    return _len(s.data);
}

func (s: string) eq(t: string): bool {
    if (s.len() != t.len()) {
        return false;
    };

    let n = 0;
    while (n < s.len()) {
        if (s.data[n] != t.data[n]) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

func (s: string) starts_with(prefix: string): bool {
    let n = 0;
    while (n < prefix.len()) {
        if (s.data[n] != prefix.data[n]) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

func (s: string) bytes(): bytes {
    return s.data;
}

func (s: string) slice(start: int, end: int): string {
    let buffer = _new(end - start);
    _copy(0, end - start, _padd(s.data, start), buffer);

    return string {
        data: buffer,
    };
}

func (s: string) slice_after(start: int): string {
    return s.slice(start, s.len());
}

func (s: string) concat(t: string): string {
    let buffer = _new(s.len() + t.len());
    _copy(0, s.len(), s.data, buffer);
    _copy(s.len(), t.len(), t.data, buffer);

    return string { data: buffer };
}

func (s: string) reverse(): string {
    let buffer = _new(s.len());
    let n = 0;
    while (n < s.len()) {
        // FIXME: multiple operators
        // s.len() - n - 1
        buffer[n] = s.data[_sub(s.len(), n + 1)];
        n = n + 1;
    };

    return string { data: buffer };
}

// int cannot have any methods then we need to define as a global function... X(
func show_bool(b: bool): string {
    if b {
        return "true";
    } else {
        return "false";
    };
}

func show_int(a: int): string {
    let num = a;
    let str = "";
    let digits = "0123456789";

    while (num > 0) {
        let r = _mod(num, 10);
        str = str.concat(digits.slice(r, r+1));
        num = _div(num, 10);
    };

    return str.reverse();
}

func assert(a: bool) {
    if a {
        return nil;
    } else {
        _println("Assertion failed: false");
        _panic;
    };
}

func assert_eq(a: string, b: string) {
    if a.eq(b) {
        return nil;
    } else {
        _println("Assertion failed: ".concat(a).concat(" != ").concat(b));
        _panic;
    };
}

func test() {
    assert("foo".eq("foo"));
    assert("foo".concat("bar").eq("foobar"));
    assert_eq("hello".slice(1,5), "ello");
    assert_eq("hello".slice_after(3), "lo");
    assert_eq("hello".reverse(), "olleh");
    assert_eq(show_int(12345), "12345");
    assert_eq(show_int("hello, world".len()), show_int(12));
    assert("prefix-suffix".starts_with("prefix"));
    assert(_not("prefix-suffix".starts_with("suffix")));
}
