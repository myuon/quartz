method bool to_string(self): string {
    if self {
        return "true";
    } else {
        return "false";
    };
}

method byte to_int(self): int {
    return _byte_to_int(self);
}

method byte to_string(self): string {
    let buffer = make[array[byte]](1, nil as byte);
    buffer(0) = self;

    return string::from_bytes(buffer);
}

method int to_string(self): string {
    return show_int(self);
}

method string len(self): int {
    return _len(self.bytes());
}

method string bytes(self): array[byte] {
    return self as array[byte];
}

method string at(self, index: int): byte {
    return self(index);
}

method string from_bytes(bs: array[byte]): string {
    return bs as string;
}

method string eq(self, t: string): bool {
    if (self.len() != t.len()) {
        return false;
    };

    let n = 0;
    while (n < self.len()) {
        if (_byte_to_int(self.at(n)) != _byte_to_int(t.at(n))) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

method string starts_with(self, prefix: string): bool {
    let n = 0;
    while (n < prefix.len()) {
        if (_byte_to_int(self.at(n)) != _byte_to_int(prefix.at(n))) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

method string concat(self, t: string): string {
    let s_len = self.len();
    let t_len = t.len();
    let buffer = make[array[byte]](s_len + t_len, nil as byte);
    _copy(s_len, self.bytes(), 0, buffer, 0);
    _copy(t_len, t.bytes(), 0, buffer, s_len);

    return string::from_bytes(buffer);
}

method string reverse(self): string {
    let buffer = make[array[byte]](self.len(), nil as byte);
    let n = 0;
    while (n < self.len()) {
        // FIXME: multiple operators
        // s.len() - n - 1
        buffer(n) = self.at(_sub(self.len(), n + 1));
        n = n + 1;
    };

    return string::from_bytes(buffer);
}

struct substring {
    str: string,
    start: int,
    end: int,
}

method string to_substring(self): substring {
    return substring {
        str: self,
        start: 0,
        end: self.len(),
    };
}

method string slice(self, start: int, end: int): substring {
    return substring {
        str: self,
        start: start,
        end: end,
    };
}

method string slice_after(self, start: int): substring {
    return self.slice(start, self.len());
}

method substring to_string(self): string {
    let buffer = make[array[byte]](self.end - self.start, nil as byte);
    _copy(self.end - self.start, self.str.bytes(), self.start, buffer, 0);

    return string::from_bytes(buffer);
}

// FIXME: faster implementation
method substring eq(self, t: substring): bool {
    return self.to_string().eq(t.to_string());
}

method substring len(self): int {
    return self.end - self.start;
}

method substring at(self, n: int): byte {
    return self.str.at(self.start + n);
}

method substring slice(self, start: int, end: int): substring {
    if (self.end < self.start + end) {
        _println("end ".concat(show_int(end)).concat(" but ").concat(show_int(self.start + end)));
        _panic;
    };

    return substring {
        str: self.str,
        start: self.start + start,
        end: self.start + end,
    };
}

method substring slice_after(self, start: int): substring {
    return self.slice(start, self.len());
}

method byte char_to_digit(self): int {
    let digits = "0123456789";
    let n = 0;
    while (n < digits.len()) {
        if (self.to_int() == digits.at(n).to_int()) {
            return n;
        };

        n = n + 1;
    };

    _panic;
    return 0;
}

method string parse_int(self): int {
    let i = 0;
    let result = 0;
    while (i < self.len()) {
        result = _mult(result,10) + self.at(i).char_to_digit();
        i = i + 1;
    };

    return result;
}

method substring parse_int(self): int {
    let i = 0;
    let result = 0;
    while (i < self.len()) {
        result = _mult(result, 10) + self.at(i).char_to_digit();
        i = i + 1;
    };

    return result;
}

method substring starts_with(self, prefix: string): bool {
    let n = 0;
    while (n < prefix.len()) {
        if _not(self.at(n).to_int() == prefix.at(n).to_int()) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

// int cannot have any methods then we need to define as a global function... X(
func show_bool(b: bool): string {
    if b {
        return "true";
    } else {
        return "false";
    };
}

func show_int(a: int): string {
    if (a == 0) {
        return "0";
    };

    let num = a;
    let str = "";
    let digits = "0123456789";

    while (num > 0) {
        let r = _mod(num, 10);
        let ch = digits.slice(r, r+1).to_string();
        str = str.concat(ch);
        num = _div(num, 10);
    };

    return str.reverse();
}

func assert(a: bool) {
    if a {
        return nil;
    } else {
        _println("Assertion failed: false");
        _panic;
    };
}

func assert_eq(a: string, b: string) {
    if a.eq(b) {
        return nil;
    } else {
        _println("Assertion failed: ".concat(a).concat(" != ").concat(b));
        _panic;
    };
}

func assert_eq_int(a: int, b: int) {
    if (a == b) {
        return nil;
    } else {
        _println("Assertion failed: ".concat(show_int(a)).concat(" != ").concat(show_int(b)));
        _panic;
    };
}

struct vector[T] {
    data: array[T],
    len: int,
}

method vector[T] new(): vector[T] {
    return vector {
        data: make[array[T]](10),
        len: 0,
    };
}

method vector[T] len(self): int {
    return self.len;
}

method vector[T] push(self, item: T) {
    if (self.len == _len(self.data)) {
        let new_data = make[array[T]](_len(self.data) * 2);

        let i = 0;
        while (i < self.len) {
            let data = self.data;
            new_data(i) = data(i);
            i = i + 1;
        };

        self.data = new_data;
    };

    let data = self.data;
    data(self.len) = item;
    self.len = self.len + 1;
}

func test() {
    assert("foo".eq("foo"));
    assert("foo".concat("bar").eq("foobar"));
    assert_eq("hello".slice(1,5).to_string(), "ello");
    assert_eq(show_int("hello".slice(1,5).len()), show_int(4));
    assert_eq("hello".slice_after(3).to_string(), "lo");
    assert_eq("hello".reverse(), "olleh");
    assert_eq(show_int(12345), "12345");
    assert_eq(show_int("hello, world".len()), show_int(12));
    assert("prefix-suffix".starts_with("prefix"));
    assert(_not("prefix-suffix".starts_with("suffix")));
    assert("12345".parse_int() == 12345);

    assert(_sizeof[int]() == 1);
    assert(_sizeof[vector[int]]() == 3);

    let v = vector[int]::new();
    // v.push(10);
    // v.push(20);

    // assert(v.len() == 10);
}
