struct string {
    data: bytes,
}

method string len(self): int {
    return _len(self.data);
}

method string eq(self, t: string): bool {
    if (self.len() != t.len()) {
        return false;
    };

    let n = 0;
    while (n < self.len()) {
        if (_byte_to_int(self.data[n]) != _byte_to_int(t.data[n])) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

method string starts_with(self, prefix: string): bool {
    let n = 0;
    while (n < prefix.len()) {
        if (_byte_to_int(self.data[n]) != _byte_to_int(prefix.data[n])) {
            return false;
        };

        n = n + 1;
    };

    return true;
}

method string bytes(self): bytes {
    return self.data;
}

method string concat(self, t: string): string {
    let buffer = _new(self.len() + t.len());
    _copy(0, self.len(), self.data, buffer);
    _copy(self.len(), t.len(), t.data, buffer);

    return string { data: buffer };
}

method string reverse(self): string {
    let buffer = _new(self.len());
    let n = 0;
    while (n < self.len()) {
        // FIXME: multiple operators
        // s.len() - n - 1
        buffer[n] = self.data[_sub(self.len(), n + 1)];
        n = n + 1;
    };

    return string { data: buffer };
}

struct substring {
    str: string,
    start: int,
    end: int,
}

method string to_substring(self): substring {
    return substring {
        str: self,
        start: 0,
        end: self.len(),
    };
}

method string slice(self, start: int, end: int): substring {
    return substring {
        str: self,
        start: start,
        end: end,
    };
}

method string slice_after(self, start: int): substring {
    return self.slice(start, self.len());
}

method substring to_string(self): string {
    let buffer = _new(self.end - self.start);
    _copy(0, self.end - self.start, _padd(self.str.data, self.start), buffer);

    return string {
        data: buffer,
    };
}

// FIXME: faster implementation
method substring eq(self, t: substring): bool {
    return self.to_string().eq(t.to_string());
}

method substring len(self): int {
    return self.end - self.start;
}

method substring at(self, n: int): string {
    return self.str.slice(self.start + n, self.start + n + 1).to_string();
}

method substring slice(self, start: int, end: int): substring {
    if (self.end < self.start + end) {
        _println("end ".concat(show_int(end)).concat(" but ").concat(show_int(self.start + end)));
        _panic;
    };

    return substring {
        str: self.str,
        start: self.start + start,
        end: self.start + end,
    };
}

method substring slice_after(self, start: int): substring {
    return self.slice(start, self.len());
}

method string at(self, p: int): string {
    return self.slice(p, p+1).to_string();
}

method string char_to_digit(self): int {
    let digits = "0123456789";
    let n = 0;
    while (n < digits.len()) {
        if (self.at(0).eq(digits.at(n))) {
            return n;
        };

        n = n + 1;
    };

    _panic;
    return 0;
}

method string parse_int(self): int {
    let i = 0;
    let result = 0;
    while (i < self.len()) {
        result = _mult(result,10) + self.at(i).char_to_digit();
        i = i + 1;
    };

    return result;
}

method substring parse_int(self): int {
    let i = 0;
    let result = 0;
    while (i < self.len()) {
        result = _mult(result, 10) + self.at(i).char_to_digit();
        i = i + 1;
    };

    return result;
}

// int cannot have any methods then we need to define as a global function... X(
func show_bool(b: bool): string {
    if b {
        return "true";
    } else {
        return "false";
    };
}

func show_int(a: int): string {
    if (a == 0) {
        return "0";
    };

    let num = a;
    let str = "";
    let digits = "0123456789";

    while (num > 0) {
        let r = _mod(num, 10);
        let ch = digits.slice(r, r+1).to_string();
        str = str.concat(ch);
        num = _div(num, 10);
    };

    return str.reverse();
}

func assert(a: bool) {
    if a {
        return nil;
    } else {
        _println("Assertion failed: false");
        _panic;
    };
}

func assert_eq(a: string, b: string) {
    if a.eq(b) {
        return nil;
    } else {
        _println("Assertion failed: ".concat(a).concat(" != ").concat(b));
        _panic;
    };
}

func test() {
    assert("foo".eq("foo"));
    assert("foo".concat("bar").eq("foobar"));
    assert_eq("hello".slice(1,5).to_string(), "ello");
    assert_eq(show_int("hello".slice(1,5).len()), show_int(4));
    assert_eq("hello".slice_after(3).to_string(), "lo");
    assert_eq("hello".reverse(), "olleh");
    assert_eq(show_int(12345), "12345");
    assert_eq(show_int("hello, world".len()), show_int(12));
    assert("prefix-suffix".starts_with("prefix"));
    assert(_not("prefix-suffix".starts_with("suffix")));
    assert("12345".parse_int() == 12345);
}
