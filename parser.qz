import lexer;

struct IrTerm {
    type: string, // NIL | BOOL | INT | IDENT | ARGUMENT | INFO
    value_bool: bool?,
    value_int: int?,
    value_ident: string?,
    value_argument: string?,
    value_info: int?,
}

method IrTerm int(value: int): IrTerm {
    return IrTerm {
        type: "INT",
        value_bool: nil,
        value_int: value,
        value_ident: nil,
        value_argument: nil,
        value_info: nil,
    };
}

method IrTerm to_string(self): string {
    if (self.type.eq("NIL")) {
        return "nil";
    };
    if (self.type.eq("BOOL")) {
        let b = self.value_bool!;
        return b.to_string();
    };
    if (self.type.eq("INT")) {
        let v = self.value_int!;
        return v.to_string();
    };
    if (self.type.eq("IDENT")) {
        return self.value_ident!;
    };
    if (self.type.eq("ARGUMENT")) {
        return self.value_argument!;
    };
    if (self.type.eq("INFO")) {
        let v = self.value_info!;
        return v.to_string();
    };

    _panic;
    return "";
}

struct IrBlock {
    name: string,
    elements: IrElementList,
}

method IrBlock to_string(self): string {
    return self.name.concat(self.elements.to_string());
}

struct IrElementListNode {
    node: IrElement,
    next: IrElementList,
}

struct IrElementList {
    list: ref IrElementListNode,
}

method IrElementList to_string(self): string {
    let s = "";
    let n = self.list;
    while _not(_is_nil(n)) {
       s = s.concat(" ").concat(n.node.to_string());
       n = n.next.list;
    };
    return s;
}

func IrElementList_nil(): IrElementList {
    return IrElementList {
        list: nil,
    };
}

method IrElementList cons(self, node: IrElement): IrElementList {
    return IrElementList {
        list: ref IrElementListNode {
            node: node,
            next: self,
        },
    };
}

method IrElementList concat(self, node: IrElementList): IrElementList {
    if _is_nil(self.list) {
        return node;
    } else {
        let current = self.list!;

        return IrElementList {
            list: ref IrElementListNode {
                node: current.node,
                next: current.next.concat(node),
            },
        };
    };
}

method IrElementList reverse(self): IrElementList {
    if _is_nil(self.list) {
        return IrElementList {
            list: nil,
        };
    } else {
        let current = self.list!;

        return current.next.reverse().concat(IrElementList {
            list: ref IrElementListNode {
                node: current.node,
                next: IrElementList {
                    list: nil
                },
            },
        });
    };
}

struct IrElement {
    type: string, // BLOCK or TERM
    term: IrTerm?,
    block: IrBlock?,
}

method IrElement to_string(self): string {
    if (self.type.eq("BLOCK")) {
        return "(".concat(self.block!.to_string()).concat(")");
    };
    if (self.type.eq("TERM")) {
        return self.term!.to_string();
    };

    _panic;
    return "";
}

struct IrParser {
    tokens: TokenList,
}

method IrParser new(tokens: TokenList): IrParser {
    return IrParser {
        tokens: tokens,
    };
}

method IrParser is_eof(self): bool {
    return _is_nil(self.tokens.next);
}

method IrParser expect(self, token_type: string): Token {
    let token = self.next();
    if _not(token.type.eq(token_type)) {
        _panic;
    };

    return token;
}

method IrParser next(self): Token {
    if _is_nil(self.tokens.next) {
        _panic;
        return Token {
            type: "",
            value_string: nil,
            value_int: nil,
        };
    } else {
        let node = self.tokens.next;
        self.tokens = node.next;
        return node.node;
    };
}

method IrParser peek(self): Token {
    if _is_nil(self.tokens.next) {
        _panic;
        return Token {
            type: "",
            value_string: nil,
            value_int: nil,
        };
    } else {
        let node = self.tokens.next;
        return node.node;
    };
}

method IrParser expect_peek(self, type: string): bool {
    let token = self.peek();
    return token.type.eq(type);
}

method IrParser term(self, token: Token): IrTerm {
    if (token.type.eq("IDENT")) {
        return IrTerm {
            type: "IDENT",
            value_bool: nil,
            value_int: nil,
            value_ident: token.value_string,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("NUMBER")) {
        return IrTerm {
            type: "INT",
            value_bool: nil,
            value_int: token.value_int,
            value_ident: nil,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("ARGUMENT")) {
        return IrTerm {
            type: "ARGUMENT",
            value_bool: nil,
            value_int: token.value_int,
            value_ident: nil,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("KEYWORD")) {
        let keyword = token.value_string!;
        if _is_nil(keyword) {
            _panic;
        };

        if (keyword.eq("nil")) {
            return IrTerm {
                type: "NIL",
                value_bool: nil,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };
        if (keyword.eq("true")) {
            return IrTerm {
                type: "BOOL",
                value_bool: true,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };
        if (keyword.eq("false")) {
            return IrTerm {
                type: "BOOL",
                value_bool: false,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };

        _panic;
        return IrTerm {
            type: "",
            value_bool: nil,
            value_int: nil,
            value_ident: nil,
            value_argument: nil,
            value_info: nil,
        };
    };

    _println("unreachable!");
    _println(token.type);
    _panic;
    return IrTerm {
        type: "",
        value_bool: nil,
        value_int: nil,
        value_ident: nil,
        value_argument: nil,
        value_info: nil,
    };
}

method IrParser element(self): IrElement? {
    if self.is_eof() {
        return nil;
    };
    let token = self.next();
    _println(token.type);

    if (token.type.eq("LPAREN")) {
        // block
        let name = self.expect("KEYWORD");
        let name_string = name.value_string!;

        let next = nil as IrElement?;
        let elements = IrElementList_nil();

        // while _not(self.peek().type.eq("RPAREN")) {
        while _not(self.expect_peek("RPAREN")) {
            next = self.element();
            elements = elements.cons(next!);
        };
        self.expect("RPAREN");

        return (IrElement {
            type: "BLOCK",
            term: nil,
            block: IrBlock {
                name: name_string,
                elements: elements.reverse(),
            },
        }) as IrElement?;
    } else {
        return (IrElement {
            type: "TERM",
            term: self.term(token),
            block: nil,
        }) as IrElement?;
    };

    return nil;
}
