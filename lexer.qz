func find_space_pattern(s: substring): int {
    let n = 0;
    while n < s.len() {
        if _not(s.at(n).to_string().eq(" ")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_exact_pattern(s: substring, pattern: string): int {
    let n = 0;
    while n < pattern.len() {
        if _not(s.at(n).to_int() == pattern.at(n).to_int()) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func matches(s: string, pattern: string): bool {
    let n = 0;
    while n < pattern.len() {
        if s.eq(pattern.at(n).to_string()) {
            return true;
        };

        n = n + 1;
    };

    return false;
}

func find_numbers(s: substring): int {
    let n = 0;
    while n < s.len() {
        if _not(matches(s.at(n).to_string(), "012456789")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_identifier(s: substring): int {
    if _not(s.at(0).to_string().eq("$")) {
        return 0;
    };

    let n = find_variable_letters(s.slice_after(1));
    if (n > 0) {
        return n + 1;
    };

    return 0;
}

// [0-9a-zA-Z_]
func find_variable_letters(s: substring): int {
    let n = 0;
    while n < s.len() {
        if _not(matches(s.at(n).to_string(), "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

struct IrLexer {
    input: string,
    position: int,
}

struct Token {
    type: string, // IDENT, KEYWORD, ARGUMENT, NUMBER, LPAREN, RPAREN
    value_string: string?,
    value_int: int?,
}

method IrLexer current_input(self): substring {
    return self.input.slice_after(self.position);
}

struct TokenListNode {
    node: Token,
    next: TokenList,
}
struct TokenList {
    next: ref TokenListNode,
}

method TokenList new() {
    return TokenList {
        next: nil as ref TokenListNode,
    };
}

method TokenList cons(self, node: Token): TokenList {
    return TokenList {
        next: ref TokenListNode {
            node: node,
            next: self,
        },
    };
}

method TokenList concat(self, node: TokenList): TokenList {
    if self.next == nil {
        return node;
    } else {
        let current = self.next!;

        return TokenList {
            next: ref TokenListNode {
                node: current.node,
                next: current.next.concat(node),
            },
        };
    };
}

method TokenList reverse(self): TokenList {
    if self.next == nil {
        return TokenList {
            next: nil,
        };
    } else {
        let current = self.next!;

        return current.next.reverse().concat(TokenList {
            next: ref TokenListNode {
                node: current.node,
                next: TokenList {
                    next: nil
                },
            },
        });
    };
}

method IrLexer next_token(self): Token {
    let current = self.current_input();

    // no return/continue here
    let n = find_space_pattern(current);
    if (n > 0) {
        self.position = self.position + n;
        current = self.input.slice_after(self.position);
    };

    let n = find_exact_pattern(current, "(");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "LPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_exact_pattern(current, ")");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "RPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_numbers(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "NUMBER",
            value_string: nil,
            value_int: current.slice(0, n).parse_int(),
        };
    };

    let n = find_identifier(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "IDENT",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    let n = find_variable_letters(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "KEYWORD",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    _println("unexpected character: ".concat(current.to_string()));
    _panic;
    return Token {
        type: "",
        value_string: nil,
        value_int: nil,
    };
}

method IrLexer run(self): TokenList {
    let len = self.input.len();
    let result = TokenList::new();
    while (self.position < len) {
        let token = self.next_token();
        result = result.cons(token);
    };

    return result.reverse();
}

