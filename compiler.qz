import parser;

func generate(element: IrElement): vector[string] {
    let code = vector[string]::new();

    // first path
    let block = element.into_block();
    let index = 0;
    _start_debugger;
    while index < block!.elements.len() {
        let block = block!.elements.at(index).into_block();
        if block!.name == "func" {
            _println("func");
        } else {
            _println("not func");
        }

        index = index + 1;
    }

    return code;
}

func main() {
    let input = "(module (func $main 0 (return 10)))";
    let IrLexer = IrLexer {
        input: input, 
        position: 0,
    };
    let tokenList = IrLexer.run();

    let parser = IrParser::new(tokenList);
    let element = parser.element()!;
    _println_any(ref element);
    _println(element.to_string());

    _println_any(ref generate(element).len());

    _println("== COMPILE FINISHED");
}

func compiler_test() {
    assert_eq_int(find_space_pattern("fooo".to_substring()), 0);
    assert_eq_int(find_space_pattern("    fooo".to_substring()), 4);
    assert_eq_int(find_space_pattern("    ".to_substring()), 4);

    assert_eq_int(find_exact_pattern("abcde_fg".to_substring(), "abc"), 3);
    assert_eq_int(find_exact_pattern("kabcd".to_substring(), "abc"), 0);

    let l = TokenList::new();
    let t = l.cons(Token {
        type: "A",
        value_string: nil,
        value_int: nil,
    }).cons(Token {
        type: "B",
        value_string: nil,
        value_int: nil,
    }).cons(Token {
        type: "C",
        value_string: nil,
        value_int: nil,
    });
    assert_eq(t.concat(t).next!.node.type, "A");

    assert_eq(t.reverse().next!.node.type, "C");
}
