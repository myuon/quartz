func find_space_pattern(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(s.at(n).eq(" ")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_exact_pattern(s: substring, pattern: string): int {
    let n = 0;
    while (n < pattern.len()) {
        if _not(s.at(n).eq(pattern.at(n))) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func matches(s: string, pattern: string): bool {
    let n = 0;
    while (n < pattern.len()) {
        if s.eq(pattern.at(n)) {
            return true;
        };

        n = n + 1;
    };

    return false;
}

func find_numbers(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "012456789")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_identifier(s: substring): int {
    if _not(s.at(0).eq("$")) {
        return 0;
    };

    let n = find_variable_letters(s.slice_after(1));
    if (n > 0) {
        return n + 1;
    };

    return 0;
}

// [0-9a-zA-Z_]
func find_variable_letters(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

struct Lexer {
    input: string,
    position: int,
}

struct Token {
    type: string,
    value_string: string?,
    value_int: int?,
}

method Lexer next_token(self): Token {
    let current = self.input.slice_after(self.position);

    // no return/continue here
    let n = find_space_pattern(current);
    if (n > 0) {
        self.position = self.position + n;
    };

    let n = find_exact_pattern(current, "(");
    if (n > 0) {
        _start_debugger;
        self.position = self.position + n;

        return Token {
            type: "LPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_exact_pattern(current, ")");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "RPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_numbers(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "NUMBER",
            value_string: nil,
            value_int: current.slice(0, n).parse_int(),
        };
    };

    let n = find_identifier(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "IDENT",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    let n = find_variable_letters(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "VARIABLE",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    return Token {
        type: "",
        value_string: nil,
        value_int: nil,
    };
}

struct IrTerm {
    type: string, // NIL | BOOL | INT | IDENT | ARGUMENT | INFO
    value_bool: bool?,
    value_int: int?,
    value_ident: string?,
    value_argument: string?,
    value_info: int?,
}

struct IrBlock {
    name: string,
    elements: IrElementList,
}

struct IrElementListNode {
    node: IrElement,
    next: IrElementList,
}
struct IrElementList {
    cons: ref IrElementListNode,
}

func IrElementList_nil(): IrElementList {
    return IrElementList {
        cons: _nil_to_ref(nil),
    };
}

method IrElementList cons(self, node: IrElement): IrElementList {
    return IrElementList {
        cons: ref IrElementListNode {
            node: node,
            next: self,
        },
    };
}

struct IrElement {
    type: string, // BLOCK or TERM
    term: IrTerm?,
    block: IrBlock?,
}

method Lexer element(self): IrElement? {
    let token = self.next_token();
    _println(token.type);
    _println(show_int(self.position));

    // block
    if (token.type.eq("LPAREN")) {
        let name = self.next_token();
        assert_eq(name.type, "KEYWORD");
        let name_string = name.value_string as string;

        let next = self.element();
        let elements = IrElementList_nil();
        while _not(next == nil) {
            elements = elements.cons(next as IrElement);
            next = self.element();
        };

        return IrElement {
            type: "BLOCK",
            term: nil,
            block: IrBlock {
                name: name_string,
                elements: elements,
            },
        };
    };

    return nil;
}

func main() {
    let input = "(module (func $main 0 (return 10)))";
    let lexer = Lexer {
        input: input, 
        position: 0,
    };
    lexer.element();

    _println("== COMPILE FINISHED");
}

func compiler_test() {
    assert_eq(show_int(find_space_pattern("fooo".to_substring())), show_int(0));
    assert_eq(show_int(find_space_pattern("    fooo".to_substring())), show_int(4));
    assert_eq(show_int(find_space_pattern("    ".to_substring())), show_int(4));

    assert_eq(show_int(find_exact_pattern("abcde_fg".to_substring(), "abc")), show_int(3));
    assert_eq(show_int(find_exact_pattern("kabcd".to_substring(), "abc")), show_int(0));
}
