func find_space_pattern(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(s.at(n).eq(" ")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_exact_pattern(s: substring, pattern: string): int {
    let n = 0;
    while (n < pattern.len()) {
        if _not(s.at(n).eq(pattern.at(n))) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func matches(s: string, pattern: string): bool {
    let n = 0;
    while (n < pattern.len()) {
        if s.eq(pattern.at(n)) {
            return true;
        };

        n = n + 1;
    };

    return false;
}

func find_numbers(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "012456789")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_identifier(s: substring): int {
    if _not(s.at(0).eq("$")) {
        return 0;
    };

    let n = find_variable_letters(s.slice_after(1));
    if (n > 0) {
        return n + 1;
    };

    return 0;
}

// [0-9a-zA-Z_]
func find_variable_letters(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

struct Lexer {
    input: string,
    position: int,
}

struct Token {
    type: string,
    value_string: string?,
    value_int: int?,
}

method Lexer next_token(self): Token {
    let current = self.input.slice_after(self.position);

    // no return/continue here
    let n = find_space_pattern(current);
    if (n > 0) {
        self.position = self.position + n;
        current = self.input.slice_after(self.position);
    };

    let n = find_exact_pattern(current, "(");
    if (n > 0) {
        _start_debugger;
        self.position = self.position + n;

        return Token {
            type: "LPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_exact_pattern(current, ")");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "RPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_numbers(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "NUMBER",
            value_string: nil,
            value_int: current.slice(0, n).parse_int(),
        };
    };

    let n = find_identifier(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "IDENT",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    let n = find_variable_letters(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "KEYWORD",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    _println("unexpected character: ".concat(current.to_string()));
    _panic;
    return Token {
        type: "",
        value_string: nil,
        value_int: nil,
    };
}

struct IrTerm {
    type: string, // NIL | BOOL | INT | IDENT | ARGUMENT | INFO
    value_bool: bool?,
    value_int: int?,
    value_ident: string?,
    value_argument: string?,
    value_info: int?,
}

method IrTerm int(value: int): IrTerm {
    return IrTerm {
        type: "INT",
        value_bool: nil,
        value_int: value,
        value_ident: nil,
        value_argument: nil,
        value_info: nil,
    };
}

method IrTerm to_string(self): string {
    if (self.type.eq("NIL")) {
        return "nil";
    };
    if (self.type.eq("BOOL")) {
        let b = self.value_bool as bool;
        return b.to_string();
    };
    if (self.type.eq("INT")) {
        let v = self.value_int as int;
        return v.to_string();
    };
    if (self.type.eq("IDENT")) {
        return self.value_ident as string;
    };
    if (self.type.eq("ARGUMENT")) {
        return self.value_argument as string;
    };
    if (self.type.eq("INFO")) {
        let v = self.value_info as int;
        return v.to_string();
    };

    _panic;
    return "";
}

struct IrBlock {
    name: string,
    elements: IrElementList,
}

method IrBlock to_string(self): string {
    return self.name.concat(" ").concat(self.elements.to_string());
}

struct IrElementListNode {
    node: IrElement,
    next: IrElementList,
}

struct IrElementList {
    list: ref IrElementListNode,
}

method IrElementList to_string(self): string {
    let s = "";
    let n = self.list;
    while _not(n == nil) {
       s = s.concat(" ").concat(n.node.to_string());
       n = n.next.list;
    };
    return s;
}

func IrElementList_nil(): IrElementList {
    return IrElementList {
        list: _nil_to_ref(nil),
    };
}

method IrElementList cons(self, node: IrElement): IrElementList {
    return IrElementList {
        list: ref IrElementListNode {
            node: node,
            next: self,
        },
    };
}

struct IrElement {
    type: string, // BLOCK or TERM
    term: IrTerm?,
    block: IrBlock?,
}

method IrElement to_string(self): string {
    if (self.type.eq("BLOCK")) {
        return "(".concat((self.block as IrBlock).name).concat(")");
    };
    if (self.type.eq("TERM")) {
        // FIXME: (self.term as IrTerm).to_string()
        let term = self.term as IrTerm;
        return term.to_string();
    };

    _panic;
    return "";
}

method Lexer element(self): IrElement? {
    let token = self.next_token();

    if (token.type.eq("LPAREN")) {
        // block
        let name = self.next_token();
        assert_eq(name.type, "KEYWORD");
        let name_string = name.value_string as string;

        let next = self.element();
        let elements = IrElementList_nil();
        while _not(next == nil) {
            elements = elements.cons(next as IrElement);
            next = self.element();
        };

        return IrElement {
            type: "BLOCK",
            term: nil,
            block: IrBlock {
                name: name_string,
                elements: elements,
            },
        };
    } else {
        // term
        let term = self.next_token();
        if (term.type.eq("NUMBER")) {
            return IrElement {
                type: "TERM",
                term: IrTerm {
                    type: "NUMBER",
                    value_bool: nil,
                    value_int: term.value_int,
                    value_ident: nil,
                    value_argument: nil,
                    value_info: nil,
                },
                block: nil,
            };
        };
        if (term.type.eq("IDENT")) {
            return IrElement {
                type: "TERM",
                term: IrTerm {
                    type: "IDENT",
                    value_bool: nil,
                    value_int: nil,
                    value_ident: term.value_string,
                    value_argument: nil,
                    value_info: nil,
                },
                block: nil,
            };
        };

        _println(term.type);
        _panic;
        return IrElement {
            type: "",
            term: nil,
            block: nil,
        };
    };

    return nil;
}

func main() {
    let input = "(module (func $main 0 (return 10)))";
    let lexer = Lexer {
        input: input, 
        position: 0,
    };
    let element = lexer.element() as IrElement;
    if (element == nil) {
        _println("nil");
    } else {
        _println(element.to_string());
    };

    _println("== COMPILE FINISHED");
}

func compiler_test() {
    assert_eq(show_int(find_space_pattern("fooo".to_substring())), show_int(0));
    assert_eq(show_int(find_space_pattern("    fooo".to_substring())), show_int(4));
    assert_eq(show_int(find_space_pattern("    ".to_substring())), show_int(4));

    assert_eq(show_int(find_exact_pattern("abcde_fg".to_substring(), "abc")), show_int(3));
    assert_eq(show_int(find_exact_pattern("kabcd".to_substring(), "abc")), show_int(0));
}
