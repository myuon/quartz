func find_space_pattern(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(s.at(n).eq(" ")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_exact_pattern(s: substring, pattern: string): int {
    let n = 0;
    while (n < pattern.len()) {
        if _not(s.at(n).eq(pattern.at(n))) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func matches(s: string, pattern: string): bool {
    let n = 0;
    while (n < pattern.len()) {
        if s.eq(pattern.at(n)) {
            return true;
        };

        n = n + 1;
    };

    return false;
}

func find_numbers(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "012456789")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

func find_identifier(s: substring): int {
    if _not(s.at(0).eq("$")) {
        return 0;
    };

    let n = find_variable_letters(s.slice_after(1));
    if (n > 0) {
        return n + 1;
    };

    return 0;
}

// [0-9a-zA-Z_]
func find_variable_letters(s: substring): int {
    let n = 0;
    while (n < s.len()) {
        if _not(matches(s.at(n), "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_")) {
            return n;
        };

        n = n + 1;
    };

    return n;
}

struct IrLexer {
    input: string,
    position: int,
}

struct Token {
    type: string, // IDENT, KEYWORD, ARGUMENT, NUMBER, LPAREN, RPAREN
    value_string: string?,
    value_int: int?,
}

method IrLexer current_input(self): substring {
    return self.input.slice_after(self.position);
}

struct TokenListNode {
    node: Token,
    next: TokenList,
}
struct TokenList {
    next: ref TokenListNode,
}

method TokenList new_nil() {
    return TokenList {
        next: nil as ref TokenListNode,
    };
}

method TokenList cons(self, node: Token) {
    return TokenList {
        next: ref TokenListNode {
            node: node,
            next: self,
        },
    };
}

method IrLexer next_token(self): Token {
    let current = self.current_input();

    // no return/continue here
    let n = find_space_pattern(current);
    if (n > 0) {
        self.position = self.position + n;
        current = self.input.slice_after(self.position);
    };

    let n = find_exact_pattern(current, "(");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "LPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_exact_pattern(current, ")");
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "RPAREN",
            value_string: nil,
            value_int: nil,
        };
    };

    let n = find_numbers(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "NUMBER",
            value_string: nil,
            value_int: current.slice(0, n).parse_int(),
        };
    };

    let n = find_identifier(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "IDENT",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    let n = find_variable_letters(current);
    if (n > 0) {
        self.position = self.position + n;

        return Token {
            type: "KEYWORD",
            value_string: current.slice(0, n).to_string(),
            value_int: nil,
        };
    };

    _println("unexpected character: ".concat(current.to_string()));
    _panic;
    return Token {
        type: "",
        value_string: nil,
        value_int: nil,
    };
}

method IrLexer run(self): TokenList {
    let len = self.input.len();
    let result = TokenList::new_nil();
    while (self.position < len) {
        _start_debugger;
        _println(self.position.to_string());
        let token = self.next_token();
        result = result.cons(token);
    };

    return result;
}

struct IrTerm {
    type: string, // NIL | BOOL | INT | IDENT | ARGUMENT | INFO
    value_bool: bool?,
    value_int: int?,
    value_ident: string?,
    value_argument: string?,
    value_info: int?,
}

method IrTerm int(value: int): IrTerm {
    return IrTerm {
        type: "INT",
        value_bool: nil,
        value_int: value,
        value_ident: nil,
        value_argument: nil,
        value_info: nil,
    };
}

method IrTerm to_string(self): string {
    if (self.type.eq("NIL")) {
        return "nil";
    };
    if (self.type.eq("BOOL")) {
        let b = self.value_bool as bool;
        return b.to_string();
    };
    if (self.type.eq("INT")) {
        let v = self.value_int as int;
        return v.to_string();
    };
    if (self.type.eq("IDENT")) {
        return self.value_ident as string;
    };
    if (self.type.eq("ARGUMENT")) {
        return self.value_argument as string;
    };
    if (self.type.eq("INFO")) {
        let v = self.value_info as int;
        return v.to_string();
    };

    _panic;
    return "";
}

struct IrBlock {
    name: string,
    elements: IrElementList,
}

method IrBlock to_string(self): string {
    return self.name.concat(" ").concat(self.elements.to_string());
}

struct IrElementListNode {
    node: IrElement,
    next: IrElementList,
}

struct IrElementList {
    list: ref IrElementListNode,
}

method IrElementList to_string(self): string {
    let s = "";
    let n = self.list;
    while _not(n == nil) {
       s = s.concat(" ").concat(n.node.to_string());
       n = n.next.list;
    };
    return s;
}

func IrElementList_nil(): IrElementList {
    return IrElementList {
        list: _nil_to_ref(nil),
    };
}

method IrElementList cons(self, node: IrElement): IrElementList {
    return IrElementList {
        list: ref IrElementListNode {
            node: node,
            next: self,
        },
    };
}

struct IrElement {
    type: string, // BLOCK or TERM
    term: IrTerm?,
    block: IrBlock?,
}

method IrElement to_string(self): string {
    if (self.type.eq("BLOCK")) {
        return "(".concat((self.block as IrBlock).name).concat(")");
    };
    if (self.type.eq("TERM")) {
        // FIXME: (self.term as IrTerm).to_string()
        let term = self.term as IrTerm;
        return term.to_string();
    };

    _panic;
    return "";
}

struct IrParser {
    tokens: TokenList,
}

method IrParser new(tokens: TokenList): IrParser {
    return IrParser {
        tokens: tokens,
    };
}

method IrParser is_eof(self): bool {
    return self.tokens == nil;
}

method IrParser expect(self, token_type: string): Token {
    let token = self.next();
    if _not(token.type.eq(token_type)) {
        _panic;
    };

    return token;
}

method IrParser next(self): Token {
    if (self.tokens.next == nil) {
        _panic;
        return Token {
            type: "",
            value_string: nil,
            value_int: nil,
        };
    } else {
        let node = self.tokens.next as TokenListNode;
        self.tokens = node.next;
        return node.node;
    };
}

method IrParser term(self): IrTerm {
    let token = self.next();

    if (token.type.eq("IDENT")) {
        return IrTerm {
            type: "IDENT",
            value_bool: nil,
            value_int: nil,
            value_ident: token.value_string,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("NUMBER")) {
        return IrTerm {
            type: "INT",
            value_bool: nil,
            value_int: token.value_int,
            value_ident: nil,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("ARGUMENT")) {
        return IrTerm {
            type: "ARGUMENT",
            value_bool: nil,
            value_int: token.value_int,
            value_ident: nil,
            value_argument: nil,
            value_info: nil,
        };
    };
    if (token.type.eq("KEYWORD")) {
        let keyword = token.value_string as string;
        if (keyword == nil) {
            _panic;
        };

        if (keyword.eq("nil")) {
            return IrTerm {
                type: "NIL",
                value_bool: nil,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };
        if (keyword.eq("true")) {
            return IrTerm {
                type: "BOOL",
                value_bool: true,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };
        if (keyword.eq("false")) {
            return IrTerm {
                type: "BOOL",
                value_bool: false,
                value_int: nil,
                value_ident: nil,
                value_argument: nil,
                value_info: nil,
            };
        };

        return _panic as IrTerm;
    };

    return _panic as IrTerm;
}

method IrParser element(self): IrElement? {
    if self.is_eof() {
        return nil;
    };
    let token = self.next();

    if (token.type.eq("LPAREN")) {
        // block
        let name = self.expect("KEYWORD");
        let name_string = name.value_string as string;

        let next = nil as IrElement?;
        let elements = IrElementList_nil();

        while _not(self.next().type.eq("RPAREN")) {
            next = self.element();
            elements = elements.cons(next as IrElement);
        };

        return IrElement {
            type: "BLOCK",
            term: nil,
            block: IrBlock {
                name: name_string,
                elements: elements,
            },
        };
    } else {
        return IrElement {
            type: "TERM",
            term: self.term(),
            block: nil,
        };
    };

    return nil;
}

func main() {
    let input = "(module (func $main 0 (return 10)))";
    let IrLexer = IrLexer {
        input: input, 
        position: 0,
    };
    let tokenList = IrLexer.run();

    let parser = IrParser::new(tokenList);
    let element = parser.element() as IrElement;
    _println(element.to_string());

    _println("== COMPILE FINISHED");
}

func compiler_test() {
    assert_eq(show_int(find_space_pattern("fooo".to_substring())), show_int(0));
    assert_eq(show_int(find_space_pattern("    fooo".to_substring())), show_int(4));
    assert_eq(show_int(find_space_pattern("    ".to_substring())), show_int(4));

    assert_eq(show_int(find_exact_pattern("abcde_fg".to_substring(), "abc")), show_int(3));
    assert_eq(show_int(find_exact_pattern("kabcd".to_substring(), "abc")), show_int(0));
}
