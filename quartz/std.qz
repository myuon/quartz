import quartz::core;

let fd_stdout = 1;

let fd_stderr = 2;

@[build_if(version == "2.6.0"), declare_params(fd as wasm_i32, iovs as wasm_i32, iovs_len as wasm_i32, nread as wasm_i32, result as wasm_i32), declare_namespace("wasi_snapshot_preview1")]
declare fun fd_read(fd: i32, iovs: ptr[byte], iovs_len: i32, nread: i32): i32;

fun print_string(s: string) {
    return write_string(fd_stdout, s);
}

fun write_string(fd: i32, s: string) {
    let l = s.length;
    let d = s.data;
    let n = 0;

    let ciovec = make[ptr[byte]](8); // [address (4byte), length (4byte)]
    set_ciovec(ciovec, d, l);

    let ptr_size = make[ptr[i32]](1);
    _fd_write(fd, ciovec, ptr_size);
}

fun print_vec_string(v: vec[string]) {
    print_string("vec(");
    print_string(v.length.to_string());
    print_string(")[");
    for i in 0..v.length {
        print_string(v.at(i).concat(","));
    }
    print_string("]\n");
}

fun format(f: string, ..arg: vec[string]): string {
    let str = f;
    for i in 0..arg.length {
        let a = arg.at(i);
        str = str.replace_first("{}", a);
    }

    return str;
}

fun print(f: string, ..arg: vec[string]) {
    let result = format(f, ..arg);
    print_string(result);
}

fun println(f: string, ..arg: vec[string]) {
    print(f, ..arg);
    print_string("\n");
}

fun vec_make(capacity: i32): vec[any] {
    let c = capacity;
    if capacity == 0 {
        c = 8;
    }

    return vec {
        data: make[ptr[any]](c),
        length: 0,
        capacity: c,
    };
}

fun vec_push(v: vec[any], e: any) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = make[ptr[any]](new_capacity);
        for i in 0..v.length {
            new_data.at(i) = v.data.at(i);
        }
        if v.data == nil as ptr[any] {
            panic("vec_push: v.data == nil");
        }
        free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at(v: vec[any], n: i32): any {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun vec_extend(v: vec[i32], other: vec[i32]) {
    for i in 0..other.length {
        if v.data == (nil as ptr[any]) {
            panic("vec_extend: v.data == nil");
        }

        v.push(other.at(i));
    }
}

fun vec_pop(v: vec[any]): any {
    if v.length == 0 {
        panic("vec_pop: empty vector");
    }

    let e = v.data.at(v.length - 1);
    v.length = v.length - 1;
    return e;
}

// FIXME: lack of generics
fun vec_make_byte(capacity: i32): vec[byte] {
    if capacity == 0 {
        panic("vec_make: capacity must be greater than 0");
    }

    return vec {
        data: make[ptr[byte]](capacity),
        length: 0,
        capacity: capacity,
    };
}

fun vec_push_byte(v: vec[byte], e: byte) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = make[ptr[byte]](new_capacity);
        for i in 0..v.length {
            new_data.at(i) = v.data.at(i);
        }
        free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at_byte(v: vec[byte], n: i32): byte {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun vec_extend_byte(v: vec[byte], other: vec[byte]) {
    for i in 0..other.length {
        v.push(other.at(i));
    }
}

fun vec_slice(v: vec[any], start: i32, end: i32): vec[any] {
    let result = vec_make(max(end - start, 1));
    for i in start..end {
        result.push(v.at(i));
    }
    return result;
}

fun vec_clone(v: vec[any]): vec[any] {
    let result = vec_make(v.length);
    for i in 0..v.length {
        result.push(v.at(i));
    }
    if result.data == (nil as ptr[any]) {
        panic("vec_clone: result.data == nil");
    }

    return result;
}

fun digit_to_string(digit: i32): string {
    return char_to_string(digit as byte);
}

fun char_to_string(char: byte): string {
    let s = make[ptr[byte]](1);
    s.at(0) = char;

    return string {
        data: s,
        length: 1,
    };
}

fun new_empty_string(length: i32): string {
    return string {
        data: make[ptr[byte]](length),
        length: length,
    };
}

fun is_included(s: string, n: i32, chars: string): bool {
    for i in 0..chars.length {
        if s.data.at(n) == chars.data.at(i) {
            return true;
        }
    }
    return false;
}

fun is_space(s: string, n: i32): bool {
    let c = s.data.at(n) as i32;
    return c == 32 || c == 9 || c == 10 || c == 13;
}

fun is_prefix(s: string, n: i32, prefix: string): bool {
    if s.length < n + prefix.length {
        return false;
    }

    for i in 0..prefix.length {
        if s.data.at(n + i) != prefix.data.at(i) {
            return false;
        }
    }

    return true;
}

fun vec_byte_to_string(b: vec[byte]): string {
    return new_string(b.data, b.length);
}

module bool {
    fun to_string(self): string {
        if self {
            return "true";
        } else {
            return "false";
        }
    }
}

fun max(a: i32, b: i32): i32 {
    if a > b {
        return a;
    } else {
        return b;
    }
}

fun min(a: i32, b: i32): i32 {
    if a < b {
        return a;
    } else {
        return b;
    }
}

module i32 {
    fun to_string(self): string {
        if self == 0 {
            return "0";
        }
        if self < 0 {
            return "-".concat((0 - self).to_string());
        }

        let digit = 0;
        let tmp = self;
        while tmp > 0 {
            tmp = tmp / 10;
            digit = digit + 1;
        }

        let str = make[ptr[byte]](digit);
        tmp = self;
        for i in 0..digit {
            let d = tmp % 10;
            str.at(digit - i - 1) = ((d + 48) as byte);
            tmp = tmp / 10;
        }

        return string {
            data: str,
            length: digit,
        };
    }

    fun parse(s: string): i32 {
        let negative = false;
        let n = 0;
        for i in 0..s.length {
            if i == 0 && s.data.at(i) == 45 as byte {
                negative = true;
                continue;
            }

            let c = s.data.at(i) as i32;
            if (c < 48 || c > 57) {
                panic("i32.parse: invalid character: ".concat(digit_to_string(c)));
            }
            n = n * 10 + (c - 48);
        }

        if negative {
            return 0 - n;
        } else {
            return n;
        }
    }

    fun max(self, other: i32): i32 {
        if self > other {
            return self;
        } else {
            return other;
        }
    }

    fun min(self, other: i32): i32 {
        if self < other {
            return self;
        } else {
            return other;
        }
    }
}

@[test]
fun test_i32_to_string() {
    assert_eq(1234.to_string(), "1234");
    assert_eq((0-1234).to_string(), "-1234");
    assert_eq(0.to_string(), "0");
}

@[test]
fun test_i32_parse() {
    assert_eq(i32::parse("1234"), 1234);
    assert_eq(i32::parse("-1234"), 0-1234);
    assert_eq(i32::parse("0"), 0);
}

@[test]
fun test_i32_max() {
    assert_eq(1234.max(5678), 5678);
    assert_eq(5678.max(1234), 5678);
    assert_eq(1234.max(1234), 1234);
}

@[test]
fun test_i32_min() {
    assert_eq(1234.min(5678), 1234);
    assert_eq(5678.min(1234), 1234);
    assert_eq(1234.min(1234), 1234);
}

module u32 {
    fun to_string(self): string {
        if self == (0 as u32) {
            return "0";
        }

        let digit = 0;
        let tmp = self;
        while tmp > (0 as u32) {
            tmp = tmp / (10 as u32);
            digit = digit + 1;
        }

        let str = make[ptr[byte]](digit);
        tmp = self;
        for i in 0..digit {
            let d = tmp % (10 as u32);
            str.at(digit - i - 1) = ((d as i32 + 48) as byte);
            tmp = tmp / (10 as u32);
        }

        return string {
            data: str,
            length: digit,
        };
    }

    fun parse(s: string): u32 {
        let n = 0 as u32;
        for i in 0..s.length {
            let c = s.data.at(i) as i32;
            if (c < 48 || c > 57) {
                panic("u32.parse: invalid character: ".concat(digit_to_string(c)));
            }
            n = n * (10 as u32) + ((c - 48) as u32);
        }
        return n;
    }
}

fun i32_to_i64(n: i32): i64 {
    if n < 0 {
        return i64 {
            hi: 0 - 1,
            lo: n,
        };
    } else {
        return i64 {
            hi: 0,
            lo: n,
        };
    }
}

fun i64_to_i32(n: i64): i32 {
    return n.lo;
}

struct i64 {
    hi: i32,
    lo: i32,
}

module i64 {
    fun new(hi: i32, lo: i32): i64 {
        return i64 {
            hi: hi,
            lo: lo,
        };
    }

    fun div(self, other: i64): i64 {
        let hi = make[ptr[i32]](1);
        let lo = make[ptr[i32]](1);

        div_i64_hilo(self.hi, self.lo, other.hi, other.lo, hi, lo);

        return i64 {
            hi: hi.at(0),
            lo: lo.at(0),
        };
    }

    fun mod(self, other: i64): i64 {
        let hi = make[ptr[i32]](1);
        let lo = make[ptr[i32]](1);

        mod_i64_hilo(self.hi, self.lo, other.hi, other.lo, hi, lo);

        return i64 {
            hi: hi.at(0),
            lo: lo.at(0),
        };
    }

    fun to_string(self): string {
        let result = make[vec[byte]]();

        let n = self;
        if n.hi == 0 && n.lo == 0 {
            return "0";
        }

        while n.hi != 0 || n.lo != 0 {
            let r = n.mod(i64 { hi: 0, lo: 10 });
            if r.hi != 0 {
                panic("i64.to_string: r.hi != 0");
            }

            result.push((r.lo + 48) as byte);
            n = n.div(i64 { hi: 0, lo: 10 });
        }

        return vec_byte_to_string(result).reverse();
    }
}

struct string {
    data: ptr[byte],
    length: i32,
}

module string {
    fun concat(self, s: string): string {
        let new_length = self.length + s.length;
        let new_data = make[ptr[byte]](new_length);

        for i in 0..self.length {
            new_data.at(i) = self.data.at(i);
        }
        for j in 0..s.length {
            new_data.at(self.length + j) = s.data.at(j);
        }

        return new_string(new_data, new_length);
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.data.at(i) != other.data.at(i) {
                return false;
            }
        }

        return true;
    }

    fun not_equal(self, other: string): bool {
        return !self.equal(other);
    }

    fun slice(self, start: i32, end: i32): string {
        return string {
            data: self.data.offset(start),
            length: end.min(self.length) - start,
        };
    }

    fun slice_start(self, start: i32): string {
        return self.slice(start.min(self.length), self.length);
    }

    fun at(self, n: i32): byte {
        return self.data.at(n);
    }

    fun repeat(self, n: i32): string {
        let new_length = self.length * n;
        let new_data = make[ptr[byte]](new_length);

        for i in 0..n {
            for j in 0..self.length {
                new_data.at(i * self.length + j) = self.data.at(j);
            }
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun to_string(self): string {
        return self;
    }

    fun find_first(self, haystack: string): i32? {
        let n = 0;
        while n <= self.length - haystack.length {
            if is_prefix(self, n, haystack) {
                return n?;
            } else {
                n = n + 1;
            }
        }

        return nil;
    }

    fun replace_first(self, from: string, to: string): string {
        let n = self.find_first(from);
        if n == nil {
            return self;
        }

        return self.slice(0, n!).concat(to).concat(self.slice_start(n! + from.length));
    }

    fun find_all(self, haystack: string): vec[i32] {
        let result = make[vec[i32]]();
        let n = 0;

        while n <= self.length - haystack.length {
            if is_prefix(self, n, haystack) {
                result.push(n);
                n = n + haystack.length;
            } else {
                n = n + 1;
            }
        }

        return result;
    }

    fun replace_all(self, from: string, to: string): string {
        let result = self;
        let n = 0;

        while n <= result.length - from.length {
            if is_prefix(result, n, from) {
                result = result.slice(0, n).concat(to).concat(result.slice_start(n + from.length));
                n = n + to.length;
            } else {
                n = n + 1;
            }
        }

        return result;
    }

    fun format(self, ..arg: vec[string]): string {
        return format(self, ..arg);
    }

    fun compare_lte(self, other: string): bool {
        if self.length < other.length {
            return true;
        } else if self.length > other.length {
            return false;
        } else {
            for i in 0..self.length {
                let a = self.data.at(i) as i32;
                let b = other.data.at(i) as i32;
                if a < b {
                    return true;
                } else if a > b {
                    return false;
                }
            }

            return true;
        }
    }

    fun split(self, sep: string): vec[string] {
        let result = make[vec[string]]();
        let n = 0;

        while n < self.length {
            let m = self.slice_start(n).find_first(sep);
            if m == nil {
                result.push(self.slice(n, self.length));
                return result;
            } else {
                result.push(self.slice(n, n + m!));
                n = n + m! + sep.length;
            }
        }

        return result;
    }

    fun lines(self): vec[string] {
        return self.split("\n");
    }

    fun line_counts(self): vec[i32] {
        let result = make[vec[i32]]();
        let n = 0;

        while n < self.length {
            let m = self.slice_start(n).find_first("\n");
            if m == nil {
                result.push(self.length - n);
                return result;
            } else {
                result.push(m!);
                n = n + m! + 1;
            }
        }

        return result;
    }

    fun escape_with(self, char: byte): string {
        let s = self;
        let result = make[vec[byte]]();
        let n = 0;

        result.push(char);

        while n < s.length {
            if s.at(n) == 10 as byte {
                result.push(92 as byte);
                result.push(110 as byte);
                n = n + 1;
            } else if char == 34 as byte && is_prefix(s, n, "\"") {
                result.push(92 as byte);
                result.push(34 as byte);
                n = n + 1;
            } else if s.at(n) == 0 as byte {
                result.push(92 as byte);
                result.push(48 as byte);
                n = n + 1;
            } else if s.at(n) == 92 as byte {
                result.push(92 as byte);
                result.push(92 as byte);
                n = n + 1;
            } else {
                result.push(s.at(n) as byte);
                n = n + 1;
            }
        }

        result.push(char);

        return vec_byte_to_string(result);
    }

    fun escape(self): string {
        return self.escape_with(34 as byte);
    }

    fun escape_raw(self): string {
        return self.escape_with(96 as byte);
    }

    fun starts_with(self, prefix: string): bool {
        return is_prefix(self, 0, prefix);
    }

    fun reverse(self): string {
        let result = make[vec[byte]]();
        for i in 0..self.length {
            result.push(self.data.at(self.length - i - 1));
        }
        return vec_byte_to_string(result);
    }

    fun from_byte(b: byte): string {
        let p = make[ptr[byte]](1);
        p.at(0) = b;

        return string {
            data: p,
            length: 1,
        };
    }
}

@[test]
fun test_string_concat() {
    assert_eq("abc".concat("def"), "abcdef");
    assert_eq("abc".concat("def").concat("ghi").concat("jkl"), "abcdefghijkl");
    assert_eq("".concat("abc"), "abc");
}

@[test]
fun test_string_slice() {
    assert_eq("abc".slice(0, 1), "a");
    assert_eq("abcdefghijklmn".slice(7, 12), "hijkl");
    assert_eq("abc".slice(0, 10), "abc");
}

@[test]
fun test_string_slice_start() {
    assert_eq("abc".slice_start(0), "abc");
    assert_eq("abcdefghijklmn".slice_start(7), "hijklmn");
    assert_eq("abc".slice_start(10), "");
}

@[test]
fun test_string_repeat() {
    assert_eq("abc".repeat(0), "");
    assert_eq("abc".repeat(1), "abc");
    assert_eq("abc".repeat(2), "abcabc");
    assert_eq("abc".repeat(3), "abcabcabc");
}

@[test]
fun test_find_first() {
    assert_eq("abcdefgh".find_first("def"), 3?);
    assert_eq("abcdefgh".find_first("uuuu"), nil);
}

@[test]
fun test_replace_first() {
    assert_eq("abcdefgh".replace_first("def", "xyz"), "abcxyzgh");
    assert_eq("abcdefghdef".replace_first("def", "xyz"), "abcxyzghdef");
    assert_eq("abcdefgh".replace_first("uuuu", "xyz"), "abcdefgh");
}

@[test]
fun test_find_all() {
    assert_eq("abcdefgh".find_all("def"), make[vec[i32]](3));
    assert_eq("abcdefghdef".find_all("def"), make[vec[i32]](3, 8));
    assert_eq("abcdefgh".find_all("uuuu"), make[vec[i32]]());
}

@[test]
fun test_replace_all() {
    assert_eq("abcdefgh".replace_all("def", "xyz"), "abcxyzgh");
    assert_eq("abcdefghdef".replace_all("def", "xyz"), "abcxyzghxyz");
    assert_eq("abcdefgh".replace_all("uuuu", "xyz"), "abcdefgh");
}

@[test]
fun test_compare_lte() {
    assert_eq("abc".compare_lte("abc"), true);
    assert_eq("abc".compare_lte("abcd"), true);
    assert_eq("abc".compare_lte("ab"), false);
    assert_eq("abc".compare_lte("abb"), false);
}

@[test]
fun test_split() {
    assert_eq("abc".split("b"), make[vec[string]]("a", "c"));
    assert_eq("abc".split("bc"), make[vec[string]]("a"));
    assert_eq("abc".split("abc"), make[vec[string]](""));
    assert_eq("abc".split("def"), make[vec[string]]("abc"));
    assert_eq("abcbdbebfbg".split("b"), make[vec[string]]("a", "c", "d", "e", "f", "g"));
}

@[test]
fun test_lines() {
    assert_eq("abc\ndef\nhij".lines(), make[vec[string]]("abc", "def", "hij"));
    assert_eq("a\n\n".lines(), make[vec[string]]("a", ""));
}

@[test]
fun test_line_counts() {
    assert_eq("abc\ndef\nhij".line_counts(), make[vec[i32]](3, 3, 3));
    assert_eq("a\n\n".line_counts(), make[vec[i32]](1, 0));
}

@[test]
fun test_starts_with() {
    assert_eq("abc".starts_with("a"), true);
    assert_eq("abc".starts_with("ab"), true);
    assert_eq("abc".starts_with("abc"), true);
    assert_eq("abc".starts_with("abcd"), false);
    assert_eq("abc".starts_with("b"), false);
    assert_eq("".starts_with("b"), false);
    assert_eq("abc".starts_with(""), true);
}

@[test]
fun test_reverse() {
    assert_eq("abc".reverse(), "cba");
    assert_eq("".reverse(), "");
}

struct stringbuilder {
    data: vec[byte],
}

module stringbuilder {
    fun new(): stringbuilder {
        return stringbuilder {
            data: make[vec[byte]](),
        };
    }

    fun append(self, s: string) {
        for i in 0..s.length {
            self.data.push(s.data.at(i));
        }
    }

    fun to_string(self): string {
        return new_string(self.data.data, self.data.length);
    }
}

fun panic(s: string, ..arg: vec[string]): any {
    println(s, ..arg);
    print_stacktrace();

    return abort();
}

fun print_stacktrace() {
    print_string("=== stack trace ===\n");

    let bp = _bp as ptr[ptr[byte]];
    while true {
        print_string("  ");
        print_string(bp.at(0) as string);
        print_string("\n");

        let next_bp = ((bp as ptr[ptr[byte]]).offset(1) as ptr[ptr[byte]]).at(0) as ptr[ptr[byte]];
        if (bp.at(0) as string) == "main_main" {
            break;
        }

        bp = next_bp;
    }
}

// used in compiler
let strings_count = 0;

fun dump_strings() {
    println("[dump_strings]");

    for i in 0..strings_count {
        let s = strings_ptr as ptr[string];
        // println((i.to_string()).concat("[").concat((s.at(i) as i32).to_string()).concat("]: ").concat((strings_ptr as ptr[string]).at(i)));
        println(s.at(i));
    }
}

struct MapEntry {
    key: string?,
    value: any,
}

struct Map {
    count: i32,
    capacity: i32,
    entries: ptr[MapEntry],
}

fun map_make(): Map {
    return Map {
        count: 0,
        capacity: 0,
        entries: nil as ptr[MapEntry],
    };
}

fun map_at(map: Map, key: string): any {
    if map.count == 0 {
        return panic("map_at[empty]: key ".concat(key).concat(" not found"));
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        return panic("map_at: key ".concat(key).concat(" not found"));
    } else {
        return entry.value;
    }
}

fun map_has(map: Map, key: string): bool {
    if map.count == 0 {
        return false;
    }

    let entry = map_find_entry(map, key);
    return entry.key != nil;
}

fun map_insert(map: Map, key: string, value: any) {
    if (map.count + 1) * 2 > map.capacity {
        let new_capacity = map.capacity * 2;
        if new_capacity == 0 {
            new_capacity = 8;
        }

        let entries = make[ptr[MapEntry]](new_capacity);

        for i in 0..new_capacity {
            entries.at(i) = MapEntry {
                key: nil,
                value: nil as any,
            };
        }

        let new_map = Map {
            count: 0,
            capacity: new_capacity,
            entries: entries,
        };

        for i in 0..map.capacity {
            let entry = map.entries.at(i);
            if entry.key == nil {
                continue;
            }

            let target = map_find_entry(new_map, entry.key!);
            target.key = entry.key;
            target.value = entry.value;
            new_map.count = new_map.count + 1;
        }

        map.entries = entries;
        map.capacity = new_capacity;
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        entry.key = key?;
        entry.value = value;
        map.count = map.count + 1;
    } else {
        entry.value = value;
    }
}

fun map_find_entry(map: Map, key: string): MapEntry {
    let hash = hash_string(key, key.length);
    let index = (hash % (map.capacity as u32)) as i32;
    if (index < 0) {
        return panic("map_find_entry: index < 0") as MapEntry;
    }

    let entry = map.entries.at(index);
    while true {
        if entry.key == nil || entry.key!.equal(key) {
            return entry;
        }
        index = (index + 1) % map.capacity;
        entry = map.entries.at(index);
    }

    return panic("unreachable") as MapEntry;
}

fun map_list_keys(map: Map): vec[string] {
    let result = make[vec[string]]();
    for i in 0..map.capacity {
        if map.entries.at(i).key != nil {
            result.push(map.entries.at(i).key!);
        }
    }

    return result;
}

fun hash_string(key: string, length: i32): u32 {
    let hash = 2166136261 as u32;
    for i in 0..length {
        hash = xor_u32(hash, key.data.at(i) as u32);
        hash = hash * (16777619 as u32);
    }
    return hash;
}

@[test]
fun test_map_count() {
    let m = make[map[string, i32]]();
    let text = "lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";
    for i in 0..text.length {
        let c = string::from_byte(text.at(i));
        if !m.has(c) {
            m.insert(c, 0);
        }

        m.insert(c, m.at(c) + 1);
    }

    assert_eq(m.at("a"), 7);
    assert_eq(m.at("b"), 1);
    assert_eq(m.at("c"), 4);
}

fun read_stdin_byte(): byte {
    let buffer_len = 1;
    let buffer = make[ptr[byte]](buffer_len);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, buffer, buffer_len);

    let nread = make[ptr[byte]](8);

    let err = _fd_read(0, ciovec, 1, nread);
    if err != 0 {
        panic("[read_stdin_byte] fd_read {}", err.to_string());
    }

    let n = read_i32_from_bytes_le(nread, 0);

    return buffer.at(0);
}

fun stdin(): string {
    let str = make[vec[byte]]();

    let b = read_stdin_byte();
    while b != 0 as byte {
        str.push(b);

        b = read_stdin_byte();
    }

    return vec_byte_to_string(str);
}

fun get_stack_objects(): vec[ptr[any]] {
    let result = make[vec[ptr[any]]]();
    let p = _sp;
    while p < stack_limit {
        result.push((p as ptr[any]).at(0) as ptr[any]);

        p = p + (sizeof[ptr[any]]() as u32);
    }

    return result;
}

fun print_stack() {
    let p = _sp;
    while p < stack_limit {
        println("{}: {}", p.to_string(), derive::to_string((p as ptr[any]).at(0)));

        p = p + (sizeof[ptr[byte]]() as u32);
    }
}

let heap_root_ptr: u32 = 0 as u32;

@[no_allocation]
fun free(p: ptr[any]) {
    let header = Header::from_data_ptr(p);
    header.set_is_free(true);

    let next = header.get_next();
    if next.get_is_free() {
        header.set_size(header.get_size() + next.get_size() + Header::sizeof());
    }
}

fun print_header(name: string, header: Header) {
    println(
        "{} [size: {}, next: {}]",
        name,
        header.get_size().to_string(),
        (header.get_next() as u32).to_string(),
    );
}

fun print_heap_objects() {
    let count = 0;
    let count_alive = 0;
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() {
            print_header((header as u32).to_string(), header);
            count_alive = count_alive + 1;
        } else {
            println("free space {} [size: {}]", (header as u32).to_string(), header.get_size().to_string());
        }

        header = header.get_next();
        count = count + 1;
    }

    println("{} [END]", (header as u32).to_string());
    println("{} objects alive of {} blocks in total", count_alive.to_string(), count.to_string());
}

fun count_heap_objects(
): struct {
    alive: i32,
    total: i32,
} {
    let count = 0;
    let count_alive = 0;
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() {
            count_alive = count_alive + 1;
        }

        header = header.get_next();
        count = count + 1;
    }

    return struct {
        alive: count_alive,
        total: count,
    };
}

struct error {
    message: string,
    detail: vec[any],
}

module error {
    fun new(message: string): error {
        return error {
            message: message,
            detail: make[vec[any]](),
        };
    }

    fun context(self, detail: any): error {
        self.detail.push(detail);

        return self;
    }
}

fun or_error_context(this: any or error, detail: any): any or error {
    let result or err = this;
    if err != nil {
        return _ or err!.context(detail);
    }

    // FIXME: `return result!` won't work
    return result! or _;
}

// used in compiler
let type_reps_count = 0;

fun load_type_rep(id: i32): ptr[any] {
    if type_reps_ptr == (nil as ptr[ptr[any]]) {
        panic("load_type_rep: type_reps_ptr == 0");
    }

    let p = (type_reps_ptr as ptr[ptr[any]]).at(id);
    if !types::is_pointer(p) {
        panic("load_type_rep: not a pointer");
    }

    return p;
}

fun is_address_type_rep(p: ptr[any]): bool {
    if !types::is_pointer(p) {
        return false;
    }

    let p_address = p as i32;
    let type_reps_ptr_address = type_reps_ptr as i32;

    return p_address >= type_reps_ptr_address && p_address < ((type_reps_ptr as ptr[any]).offset(
        type_reps_count,
    )) as i32;
}

fun is_a_record(p: ptr[ptr[any]]): bool {
    if !types::is_pointer(p) {
        return false;
    }
    if p == (nil as ptr[ptr[any]]) {
        return false;
    }

    let header = Header::from_data_ptr(p as ptr[byte]);
    return is_address_type_rep(header.get_type_rep());
}

@[test]
fun test_is_a_record() {
    assert(!is_a_record(nil as ptr[ptr[any]]));
    assert(!is_a_record(10 as ptr[ptr[any]]));
    assert(is_a_record(make[vec[i32]](1,2,3) as ptr[ptr[any]]));
    assert(is_a_record("string" as ptr[ptr[any]]));
}

struct TypeRep {
    nilptr: nil,
    kind: i32,
    name: string,
    size_of_params: i32,
    params: ptr[TypeRep],
    size_of_fields: i32,
    fields: ptr[string],
}

module TypeRep {
    fun sizeof(self): i32 {
        if self.name.equal("byte") {
            return 1;
        }

        return 8;
    }

    fun vec_params(self): vec[TypeRep] {
        let result = make[vec[TypeRep]]();
        for i in 0..self.size_of_params {
            result.push(self.params.at(i));
        }

        return result;
    }

    fun vec_fields(self): vec[string] {
        let result = make[vec[string]]();
        for i in 0..self.size_of_fields {
            result.push(self.fields.at(i));
        }

        return result;
    }
}

module reflection {
    fun get_type_rep_ptr(t: any): ptr[any] {
        return Header::from_data_ptr(t).get_type_rep();
    }

    @[no_allocation]
    fun parse_type_rep(t: ptr[any]): TypeRep {
        if !types::is_pointer(t) {
            debug(error_invalid_type);
            panic("Not a pointer");
        }
        if t.at(0) != nil {
            debug(error_invalid_type);
            debug(t.at(0));
            panic("Not a type rep");
        }

        return t as TypeRep;
    }

    fun get_type_rep(t: any): TypeRep {
        if types::is_pointer(t) {
            if t == nil {
                return TypeRep {
                    nilptr: nil,
                    kind: 1,
                    name: "nil",
                    size_of_params: 0,
                    params: nil as ptr[TypeRep],
                    size_of_fields: 0,
                    fields: nil as ptr[string],
                };
            }

            if is_a_record(t) {
                let header = Header::from_data_ptr((t as ptr[byte]));
                let rep = header.get_type_rep().at(0);

                return reflection::parse_type_rep(rep);
            }

            return TypeRep {
                nilptr: nil,
                kind: 1,
                name: "ptr",
                size_of_params: 1,
                params: make[vec[TypeRep]]((t as ptr[any]).at(0)).data,
                size_of_fields: 0,
                fields: nil as ptr[string],
            };
        }
        if reflection::is_bool(t) {
            return TypeRep {
                nilptr: nil,
                kind: 1,
                name: "bool",
                size_of_params: 0,
                params: nil as ptr[TypeRep],
                size_of_fields: 0,
                fields: nil as ptr[string],
            };
        }

        return TypeRep {
            nilptr: nil,
            kind: 1,
            name: "i32",
            size_of_params: 0,
            params: nil as ptr[TypeRep],
            size_of_fields: 0,
            fields: nil as ptr[string],
        };
    }

    @[no_allocation]
    fun is_pointer(t: any): bool {
        return _reflection_is_pointer(t);
    }

    fun is_bool(t: any): bool {
        return _reflection_is_bool(t);
    }

    fun assert_pointer(t: any) {
        if !types::is_pointer(t) {
            panic("assert_pointer");
        }
    }

    fun print_type(t: any) {
        let rep = get_type_rep(t);
        if rep.size_of_params == 0 {
            println(rep.name);
        } else {
            println("{}<{}>", rep.name, derive::to_string(rep.vec_params()));
        }
    }
}

module derive {
    fun to_string_internal(t: any, pretty: bool, depth: i32): string {
        let sep = "";
        if pretty {
            sep = "\n";
        }
        let indent = " ";
        if pretty {
            indent = " ".repeat(depth * 4);
        }

        let rep = reflection::get_type_rep(t);
        if rep.name.equal("string") {
            return format(`"{}"`, t as string);
        }
        if rep.name.equal("i32") {
            return (t as i32).to_string();
        }
        if rep.name.equal("bool") {
            return (t as bool).to_string();
        }
        if rep.name.equal("vec") {
            let s = format("vec(");
            let v = t as vec[any];
            for i in 0..v.length {
                if i > 0 {
                    s = s.concat(", ");
                }
                s = s.concat(derive::to_string_internal(v.at(i), pretty, depth + 1));
            }
            return s.concat(")");
        }
        if rep.name.equal("optional") {
            return format("({})?", derive::to_string_internal((t as any?)!, pretty, depth + 1));
        }
        if rep.name.equal("nil") {
            return "nil";
        }
        if rep.name.equal("byte") {
            return ((t as byte) as i32).to_string();
        }
        if rep.name.equal("ptr") {
            return format("<#{}>", (t as i32).to_string());
        }
        if rep.name == "Map" {
            let s = format("map(");
            let v = t as map[any, any];
            let keys = v.list_keys();
            for k in 0..keys.length {
                let key = keys.at(k);
                let value = v.at(key);
                if k > 0 {
                    s = s.concat(", ");
                }
                s = s.concat(format("{}:{}", derive::to_string_internal(key, pretty, depth + 1), derive::to_string_internal(value, pretty, depth + 1)));
            }

            return s.concat(")");
        }

        if rep.kind == 2 {
            // enum
            let s = format("{} {{}", rep.name, sep);

            let tag = (t as ptr[any]).at(0) as i32;
            let tag_name = rep.fields.at(tag);

            let v = (t as ptr[any]).at(1);
            s = s.concat(format(" {}: {} }", tag_name, derive::to_string_internal(v, pretty, depth + 1)));

            return s;
        }

        let s = format("{} {{}", rep.name, sep);
        let fields = rep.vec_fields();
        for i in 0..fields.length {
            if i > 0 {
                s = s.concat(format(",{}", sep));
            }
            let f = fields.at(i);
            let v = (t as ptr[any]).at(i);
            s = s.concat(format("{}{}: {}", indent, f, derive::to_string_internal(v, pretty, depth + 1)));
        }

        return s.concat(" }");
    }

    fun to_string(t: any): string {
        return derive::to_string_internal(t, false, 1);
    }

    fun to_string_pretty(t: any): string {
        return derive::to_string_internal(t, true, 1);
    }
}

@[test]
fun test_derive_to_string() {
    assert_eq(derive::to_string(1), "1");
    assert_eq(derive::to_string(true), "true");
    assert_eq(derive::to_string("abc"), "\"abc\"");
    assert_eq(derive::to_string(make[vec[string]]("a", "b", "cdef\nghi")), "vec(\"a\", \"b\", \"cdef\nghi\")");

    let m = make[map[string, i32]]();
    m.insert("abc", 1);
    m.insert("def", 2);
    assert_eq(derive::to_string(m), "map(\"abc\":1, \"def\":2)");
}

fun file_open(path: string, oflags: i32, rights: i32): i32 {
    // TODO: check preopened directories
    let dirfd = 4;

    let fd = make[ptr[byte]](8);
    let err = _path_open(dirfd, 0, path.data, path.length, oflags, rights, 0, 0, fd as ptr[i32]);
    if err != 0 {
        panic("[file_write] path_open {}", err.to_string());
    }

    // TODO: what if fd is over 255?
    let fd_n = fd.at(0) as i32;

    return fd_n;
}

fun file_close(fd: i32) {
    let err = _fd_close(fd);
    if err != 0 {
        panic("fd_close {}", err.to_string());
    }
}

fun read_i32_from_bytes_le(p: ptr[byte], offset: i32): i32 {
    let result = 0;

    for i in offset..(offset + 4) {
        result = result | ((p.at(i) as i32) << (i * 8));
    }

    return result;
}

fun read_filestat_get(fd: i32): ptr[byte] {
    let stat = make[ptr[byte]](72);
    let err = _fd_filestat_get(fd, stat);
    if err != 0 {
        panic("fd_filestat_get {}", err.to_string());
    }

    return stat;
}

fun file_read(path: string): string {
    let fd_n = file_open(path, 0, 1 << 1);

    let filestat = read_filestat_get(fd_n);
    let size = read_i32_from_bytes_le(filestat, 24);

    let buffer_len = size;
    let buffer = make[ptr[byte]](buffer_len);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, buffer, buffer_len);

    let nread = make[ptr[byte]](8);

    let err = _fd_read(fd_n, ciovec, 1, nread);
    if err != 0 {
        panic("fd_read {}", err.to_string());
    }

    let n = read_i32_from_bytes_le(nread, 0);
    let v = new_string(buffer, n);

    file_close(fd_n);

    return v;
}

fun file_write(path: string, content: string) {
    let fd_n = file_open(path, 9, 1 << 6);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, content.data, content.length);

    let ptr_size = make[ptr[i32]](1);
    let err = _fd_write(fd_n, ciovec, ptr_size);
    if err != 0 {
        panic("[file_write] fd_write {}", err.to_string());
    }

    file_close(fd_n);
}

@[no_allocation]
fun perform_gc() {
    // mark
    let p = _sp;
    while p < stack_limit {
        let data = (p as ptr[any]).at(0);
        mark(data);

        p = p + (sizeof[ptr[any]]() as u32);
    }

    // sweep
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() && !header.get_is_marked() && is_collectable(header.get_data_ptr()) {
            free(header.get_data_ptr());
        }
        if header.get_is_marked() {
            header.set_is_marked(false);
        }

        header = header.get_next();
    }
}

@[no_allocation]
fun is_pointer_on_stack(p: ptr[ptr[byte]]): bool {
    return (p as u32) >= _sp && (p as u32) < stack_limit;
}

@[no_allocation]
fun is_collectable(p: ptr[byte]): bool {
    return (p as u32) >= (heap_root_ptr as u32) && !is_pointer_on_stack(p as ptr[ptr[byte]]);
}

@[no_allocation]
fun mark(value: any) {
    if !types::is_pointer(value) {
        return;
    }

    let value_ptr = value as ptr[byte];
    if value_ptr == (nil as ptr[byte]) {
        return;
    } else if is_stack_pointer(value_ptr) {
        mark(value_ptr.at(0));
        return;
    } else {
        let header = Header::from_data_ptr(value_ptr);

        // checks if it's a valid header
        let size = header.get_size();
        if !types::is_i32(size) {
            debug(error_invalid_type);
            debug(size);
            abort();
        }
        if !is_typerep_pointer(header.get_type_rep() as ptr[byte]) {
            debug(error_invalid_type);
            debug(header.get_type_rep());
            abort();
        }
        // /checks

        if header.get_is_marked() {
            return;
        }

        header.set_is_marked(true);

        let rep = (header.get_type_rep() as ptr[TypeRep]).at(0);
        if rep.nilptr != nil {
            debug(error_invalid_type);
            debug(rep.nilptr);
            abort();
        }

        if rep.name == "vec" {
            let value_vec = value as vec[any];
            for i in 0..value_vec.length {
                let cell = value_vec.at(i);
                if types::is_pointer(cell) {
                    mark(cell);
                }
            }

            return;
        }

        // For an object [size, header_flags, type_rep | data...],
        // inspect the data part and mark the pointers in it.
        //
        // DISCUSSION: Should we have a bitmap of which bytes are pointers in the data part?
        let data_size = (header.get_size() - Header::sizeof()) as i32;

        let cell_ptr = header.get_data_ptr();
        for i in 0..data_size {
            let cell = cell_ptr.at(i);
            if types::is_pointer(cell) {
                mark(cell);
            }
        }
    }
}

module types {
    fun is_i32(value: any): bool {
        return get_typetag(value) == 0;
    }

    fun is_pointer(value: any): bool {
        return get_typetag(value) == 1;
    }

    fun is_bool(value: any): bool {
        return get_typetag(value) == 2;
    }

    fun is_byte(value: any): bool {
        return get_typetag(value) == 4;
    }
}

@[test]
fun test_types_is_i32() {
    assert(types::is_i32(1));
    assert(!types::is_i32(true));
    assert(!types::is_i32("abc"));
    assert(!types::is_i32(make[vec[i32]](1,2,3)));
}

@[test]
fun test_types_is_pointer() {
    assert(!types::is_pointer(1));
    assert(!types::is_pointer(true));
    assert(types::is_pointer("abc"));
    assert(types::is_pointer(make[vec[i32]](1,2,3)));
}

@[test]
fun test_types_is_bool() {
    assert(!types::is_bool(1));
    assert(types::is_bool(true));
    assert(!types::is_bool("abc"));
    assert(!types::is_bool(make[vec[i32]](1,2,3)));
}

@[test]
fun test_types_is_byte() {
    assert(!types::is_byte(1));
    assert(!types::is_byte(true));
    assert(!types::is_byte("abc"));
    assert(types::is_byte("abc".at(0)));
}

fun i32_from_bytes(b0: byte, b1: byte, b2: byte, b3: byte): i32 {
    return (b0 as i32) | ((b1 as i32) << 8) | ((b2 as i32) << 16) | ((b3 as i32) << 24);
}

fun read_until_null(p: ptr[byte]): string {
    let n = 0;
    while (p.at(n) as i32) != 0 {
        n = n + 1;
    }

    return new_string(p, n);
}

fun environs(): map[string, string] {
    let count = make[ptr[i32]](2);
    let buf_size = make[ptr[i32]](2);

    let result = _environ_sizes_get(count, buf_size);
    if result != 0 {
        panic("environ_sizes_get {}", result.to_string());
    }

    let count_i32 = _load_wasmi32(count);
    let buf_size_i32 = _load_wasmi32(buf_size);

    let buf_index = make[ptr[ptr[byte]]](count_i32);
    let buf = make[ptr[byte]](buf_size_i32);

    let result = _environ_get(buf_index, buf);
    if result != 0 {
        panic("environ_get {}", result.to_string());
    }

    let buf_index_ptrbyte = buf_index as ptr[byte];

    let mp = make[map[string, string]]();

    for i in 0..count_i32 {
        let p = i32_from_bytes(buf_index_ptrbyte.at(i * 4 + 0), buf_index_ptrbyte.at(i * 4 + 1), buf_index_ptrbyte.at(i * 4 + 2), buf_index_ptrbyte.at(i * 4 + 3)) as ptr[byte];
        let kv = read_until_null(p).split("=");
        if kv.length == 1 {
            mp.insert(kv.at(0), "");
        } else {
            mp.insert(kv.at(0), kv.at(1));
        }
    }

    return mp;
}

fun args(): vec[string] {
    let count = make[ptr[i32]](2);
    let buf_size = make[ptr[i32]](2);

    let result = _args_sizes_get(count, buf_size);
    if result != 0 {
        panic("args_sizes_get {}", result.to_string());
    }

    let count_i32 = _load_wasmi32(count);
    let buf_size_i32 = _load_wasmi32(buf_size);

    let buf_index = make[ptr[ptr[byte]]](count_i32);
    let buf = make[ptr[byte]](buf_size_i32);

    let result = _args_get(buf_index, buf);
    if result != 0 {
        panic("args_get {}", result.to_string());
    }

    let buf_index_ptrbyte = buf_index as ptr[byte];

    let args = make[vec[string]]();

    for i in 0..count_i32 {
        let p = i32_from_bytes(buf_index_ptrbyte.at(i * 4 + 0), buf_index_ptrbyte.at(i * 4 + 1), buf_index_ptrbyte.at(i * 4 + 2), buf_index_ptrbyte.at(i * 4 + 3)) as ptr[byte];
        let arg = read_until_null(p);
        args.push(arg);
    }

    return args;
}

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert_eq(a: any, b: any) {
    if derive::to_string(a) != derive::to_string(b) {
        panic("assert_eq failed: {} != {}", derive::to_string(a), derive::to_string(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}
