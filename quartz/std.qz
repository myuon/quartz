fun print_string(s: string) {
    let l = s.length;
    let d = s.data;
    let n = 0;

    let ciovec = make[ptr[byte]](8); // [address (4byte), length (4byte)]
    set_ciovec(ciovec, d, l);

    let ptr_size = make[ptr[i32]](1);
    _fd_write(1, ciovec, ptr_size);
}

fun print_vec_string(v: vec[string]) {
    print_string("vec(");
    print_string(v.length.to_string());
    print_string(")[");
    for i in 0..v.length {
        print_string(v.at(i).concat(","));
    }
    print_string("]\n");
}

fun format(f: string, ..arg: vec[string]): string {
    let str = f;
    for i in 0..arg.length {
        let a = arg.at(i);
        str = str.replace_first("{}", a);
    }

    return str;
}

fun print(f: string, ..arg: vec[string]) {
    let result = format(f, ..arg);
    print_string(result);
}

fun println(f: string, ..arg: vec[string]) {
    print(f, ..arg);
    print_string("\n");
}

fun vec_make(capacity: i32): vec[any] {
    let c = capacity;
    if capacity == 0 {
        c = 8;
    }

    return vec {
        data: make[ptr[any]](capacity),
        length: 0,
        capacity: c,
    };
}

fun vec_push(v: vec[any], e: any) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = make[ptr[any]](new_capacity);
        for i in 0..v.length {
            new_data.at(i) = v.data.at(i);
        }
        free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at(v: vec[any], n: i32): any {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun vec_extend(v: vec[i32], other: vec[i32]) {
    for i in 0..other.length {
        v.push(other.at(i));
    }
}

fun vec_pop(v: vec[any]): any {
    if v.length == 0 {
        panic("vec_pop: empty vector");
    }

    let e = v.data.at(v.length - 1);
    v.length = v.length - 1;
    return e;
}

// FIXME: lack of generics
fun vec_make_byte(capacity: i32): vec[byte] {
    if capacity == 0 {
        panic("vec_make: capacity must be greater than 0");
    }

    return vec {
        data: make[ptr[byte]](capacity),
        length: 0,
        capacity: capacity,
    };
}

fun vec_push_byte(v: vec[byte], e: byte) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = make[ptr[byte]](new_capacity);
        for i in 0..v.length {
            new_data.at(i) = v.data.at(i);
        }
        free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at_byte(v: vec[byte], n: i32): byte {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun vec_extend_byte(v: vec[byte], other: vec[byte]) {
    for i in 0..other.length {
        v.push(other.at(i));
    }
}

fun vec_slice(v: vec[any], start: i32, end: i32): vec[any] {
    let result = vec_make(max(end - start, 1));
    for i in start..end {
        result.push(v.at(i));
    }
    return result;
}

fun vec_clone(v: vec[any]): vec[any] {
    let result = vec_make(v.length);
    for i in 0..v.length {
        result.push(v.at(i));
    }
    return result;
}

fun digit_to_string(digit: i32): string {
    return char_to_string(digit as byte);
}

fun char_to_string(char: byte): string {
    let s = make[ptr[byte]](1);
    s.at(0) = char;

    return string {
        data: s,
        length: 1,
    };
}

fun new_empty_string(length: i32): string {
    return string {
        data: make[ptr[byte]](length),
        length: length,
    };
}

fun new_string(p: ptr[byte], length: i32): string {
    return string {
        data: p,
        length: length,
    };
}

fun is_included(s: string, n: i32, chars: string): bool {
    for i in 0..chars.length {
        if s.data.at(n) == chars.data.at(i) {
            return true;
        }
    }
    return false;
}

fun is_space(s: string, n: i32): bool {
    let c = s.data.at(n) as i32;
    return c == 32 || c == 9 || c == 10 || c == 13;
}

fun is_prefix(s: string, n: i32, prefix: string): bool {
    if s.length < n + prefix.length {
        return false;
    }

    for i in 0..prefix.length {
        if s.data.at(n + i) != prefix.data.at(i) {
            return false;
        }
    }

    return true;
}

fun vec_byte_to_string(b: vec[byte]): string {
    return new_string(b.data, b.length);
}

module bool {
    fun to_string(self): string {
        if self {
            return "true";
        } else {
            return "false";
        }
    }
}

fun max(a: i32, b: i32): i32 {
    if a > b {
        return a;
    } else {
        return b;
    }
}

fun min(a: i32, b: i32): i32 {
    if a < b {
        return a;
    } else {
        return b;
    }
}

module i32 {
    fun to_string(self): string {
        if self == 0 {
            return "0";
        }
        if self < 0 {
            return "-".concat((0-self).to_string());
        }

        let digit = 0;
        let tmp = self;
        while tmp > 0 {
            tmp = tmp / 10;
            digit = digit + 1;
        }

        let str = make[ptr[byte]](digit);
        tmp = self;
        for i in 0..digit {
            let d = tmp % 10;
            str.at(digit - i - 1) = ((d + 48) as byte);
            tmp = tmp / 10;
        }

        return string {
            data: str,
            length: digit,
        };
    }

    fun parse(s: string): i32 {
        let n = 0;
        for i in 0..s.length {
            let c = s.data.at(i) as i32;
            if (c < 48 || c > 57) {
                panic("i32.parse: invalid character: ".concat(digit_to_string(c)));
            }
            n = n * 10 + (c - 48);
        }
        return n;
    }
}

module u32 {
    fun to_string(self): string {
        if self == (0 as u32) {
            return "0";
        }

        let digit = 0;
        let tmp = self;
        while tmp > (0 as u32) {
            tmp = tmp / (10 as u32);
            digit = digit + 1;
        }

        let str = make[ptr[byte]](digit);
        tmp = self;
        for i in 0..digit {
            let d = tmp % (10 as u32);
            str.at(digit - i - 1) = ((d as i32 + 48) as byte);
            tmp = tmp / (10 as u32);
        }

        return string {
            data: str,
            length: digit,
        };
    }

    fun parse(s: string): u32 {
        let n = 0 as u32;
        for i in 0..s.length {
            let c = s.data.at(i) as i32;
            if (c < 48 || c > 57) {
                panic("u32.parse: invalid character: ".concat(digit_to_string(c)));
            }
            n = n * (10 as u32) + ((c - 48) as u32);
        }
        return n;
    }
}

fun i32_to_i64(n: i32): i64 {
    if n < 0 {
        return i64 {
            hi: 0 - 1,
            lo: n,
        };
    } else {
        return i64 {
            hi: 0,
            lo: n,
        };
    }
}

fun i64_to_i32(n: i64): i32 {
    return n.lo;
}

struct i64 {
    hi: i32,
    lo: i32,
}

module i64 {
    fun to_string(self): string {
        let result = make[vec[byte]]();

        let digit = 0;
        let p = i64_to_string_at(self.hi, self.lo, digit);
        while p != (0 - 1) {
            result.push((p + 48) as byte);
            digit = digit + 1;
            p = i64_to_string_at(self.hi, self.lo, digit);
        }

        return vec_byte_to_string(result);
    }

    fun new(hi: i32, lo: i32): i64 {
        return i64 {
            hi: hi,
            lo: lo,
        };
    }
}

struct string {
    data: ptr[byte],
    length: i32,
}

module string {
    fun concat(self, s: string): string {
        let new_length = self.length + s.length;
        let new_data = make[ptr[byte]](new_length);

        for i in 0..self.length {
            new_data.at(i) = self.data.at(i);
        }
        for j in 0..s.length {
            new_data.at(self.length + j) = s.data.at(j);
        }

        return new_string(new_data, new_length);
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.data.at(i) != other.data.at(i) {
                return false;
            }
        }

        return true;
    }

    fun not_equal(self, other: string): bool {
        return !self.equal(other);
    }

    fun slice(self, start: i32, end: i32): string {
        return string {
            data: self.data.offset(start),
            length: end - start,
        };
    }

    fun slice_start(self, start: i32): string {
        return self.slice(start, self.length);
    }

    fun at(self, n: i32): byte {
        return self.data.at(n);
    }

    fun repeat(self, n: i32): string {
        let new_length = self.length * n;
        let new_data = make[ptr[byte]](new_length);

        for i in 0..n {
            for j in 0..self.length {
                new_data.at(i * self.length + j) = self.data.at(j);
            }
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun to_string(self): string {
        return self;
    }

    fun find_first(self, haystack: string): i32? {
        let n = 0;
        while n <= self.length - haystack.length {
            if is_prefix(self, n, haystack) {
                return n?;
            } else {
                n = n + 1;
            }
        }

        return nil;
    }

    fun replace_first(self, from: string, to: string): string {
        let n = self.find_first(from);
        if n == nil {
            return self;
        }

        return self.slice(0, n!).concat(to).concat(self.slice_start(n! + from.length));
    }

    fun find_all(self, haystack: string): vec[i32] {
        let result = make[vec[i32]](0);
        let n = 0;

        while n <= self.length - haystack.length {
            if is_prefix(self, n, haystack) {
                result.push(n);
                n = n + haystack.length;
            } else {
                n = n + 1;
            }
        }

        return result;
    }

    fun replace(self, from: string, to: string): string {
        let result = self;
        let n = 0;

        while n <= result.length - from.length {
            if is_prefix(result, n, from) {
                result = result.slice(0, n).concat(to).concat(result.slice_start(n + from.length));
                n = n + to.length;
            } else {
                n = n + 1;
            }
        }

        return result;
    }

    fun format(self, ..arg: vec[string]): string {
        return format(self, ..arg);
    }

    fun compare_lte(self, other: string): bool {
        if self.length < other.length {
            return true;
        } else if self.length > other.length {
            return false;
        } else {
            for i in 0..self.length {
                let a = self.data.at(i) as i32;
                let b = other.data.at(i) as i32;
                if a < b {
                    return true;
                } else if a > b {
                    return false;
                }
            }

            return true;
        }
    }

    fun split(self, sep: string): vec[string] {
        let result = make[vec[string]]();
        let n = 0;

        while n < self.length {
            let m = self.slice_start(n).find_first(sep);
            if m == nil {
                result.push(self.slice(n, self.length));
                return result;
            } else {
                result.push(self.slice(n, n + m!));
                n = n + m! + sep.length;
            }
        }

        return result;
    }

    fun lines(self): vec[string] {
        return self.split("\n");
    }

    fun line_counts(self): vec[i32] {
        let result = make[vec[i32]]();
        let n = 0;

        while n < self.length {
            let m = self.slice_start(n).find_first("\n");
            if m == nil {
                result.push(self.length - n);
                return result;
            } else {
                result.push(m!);
                n = n + m! + 1;
            }
        }

        return result;
    }

    fun escape_with(self, char: byte): string {
        let s = self;
        let result = make[vec[byte]]();
        let n = 0;

        result.push(char);

        while n < s.length {
            if s.at(n) == 10 as byte {
                result.push(92 as byte);
                result.push(110 as byte);
                n = n + 1;
            } else if char == 34 as byte && is_prefix(s, n, "\"") {
                result.push(92 as byte);
                result.push(34 as byte);
                n = n + 1;
            } else if s.at(n) == 0 as byte {
                result.push(92 as byte);
                result.push(48 as byte);
                n = n + 1;
            } else if s.at(n) == 92 as byte {
                result.push(92 as byte);
                result.push(92 as byte);
                n = n + 1;
            } else {
                result.push(s.at(n) as byte);
                n = n + 1;
            }
        }

        result.push(char);

        return vec_byte_to_string(result);
    }

    fun escape(self): string {
        return self.escape_with(34 as byte);
    }

    fun escape_raw(self): string {
        return self.escape_with(96 as byte);
    }

    fun starts_with(self, prefix: string): bool {
        return is_prefix(self, 0, prefix);
    }
}

struct stringbuilder {
    data: vec[byte],
}

module stringbuilder {
    fun new(): stringbuilder {
        return stringbuilder {
            data: make[vec[byte]](),
        };
    }

    fun append(self, s: string) {
        for i in 0..s.length {
            self.data.push(s.data.at(i));
        }
    }

    fun to_string(self): string {
        return new_string(self.data.data, self.data.length);
    }
}

fun panic(s: string, ..arg: vec[string]): any {
    println(s, ..arg);
    print_stacktrace();

    return abort();
}

fun print_stacktrace() {
    let bp = _bp as ptr[ptr[byte]];

    print_string("=== stack trace ===\n");

    print_string("  ");
    print_string(bp.at(0) as string);
    print_string("\n");
}

// used in compiler
let strings_ptr = 0;

let strings_count = 0;

fun load_string(index: i32): string {
    if strings_ptr == 0 {
        panic("strings_ptr is nil");
    }

    return (strings_ptr as ptr[string]).at(index);
}

fun dump_strings() {
    println("[dump_strings]");

    for i in 0..strings_count {
        let s = strings_ptr as ptr[string];
        // println((i.to_string()).concat("[").concat((s.at(i) as i32).to_string()).concat("]: ").concat((strings_ptr as ptr[string]).at(i)));
        println(s.at(i));
    }
}

struct MapEntry {
    key: string?,
    value: any,
}

struct Map {
    count: i32,
    capacity: i32,
    entries: ptr[MapEntry],
}

fun map_make(): Map {
    return Map {
        count: 0,
        capacity: 0,
        entries: nil as ptr[MapEntry],
    };
}

fun map_at(map: Map, key: string): any {
    if map.count == 0 {
        return panic("map_at[empty]: key ".concat(key).concat(" not found"));
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        return panic("map_at: key ".concat(key).concat(" not found"));
    } else {
        return entry.value;
    }
}

fun map_has(map: Map, key: string): bool {
    if map.count == 0 {
        return false;
    }

    let entry = map_find_entry(map, key);
    return entry.key != nil;
}

fun map_insert(map: Map, key: string, value: any) {
    if (map.count + 1) * 2 > map.capacity {
        let new_capacity = map.capacity * 2;
        if new_capacity == 0 {
            new_capacity = 8;
        }

        let entries = make[ptr[MapEntry]](new_capacity);

        for i in 0..new_capacity {
            entries.at(i) = MapEntry {
                key: nil,
                value: nil as any,
            };
        }

        let new_map = Map {
            count: 0,
            capacity: new_capacity,
            entries: entries,
        };

        for i in 0..map.capacity {
            let entry = map.entries.at(i);
            if entry.key == nil {
                continue;
            }

            let target = map_find_entry(new_map, entry.key!);
            target.key = entry.key;
            target.value = entry.value;
            new_map.count = new_map.count + 1;
        }

        map.entries = entries;
        map.capacity = new_capacity;
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        entry.key = key?;
        entry.value = value;
        map.count = map.count + 1;
    } else {
        entry.value = value;
    }
}

fun map_find_entry(map: Map, key: string): MapEntry {
    let hash = hash_string(key, key.length);
    let index = (hash % (map.capacity as u32)) as i32;
    if (index < 0) {
        return panic("map_find_entry: index < 0") as MapEntry;
    }

    let entry = map.entries.at(index);
    while true {
        if entry.key == nil || entry.key!.equal(key) {
            return entry;
        }
        index = (index + 1) % map.capacity;
        entry = map.entries.at(index);
    }

    return panic("unreachable") as MapEntry;
}

fun map_list_keys(map: Map): vec[string] {
    let result = make[vec[string]]();
    for i in 0..map.capacity {
        if map.entries.at(i).key != nil {
            result.push(map.entries.at(i).key!);
        }
    }

    return result;
}

fun hash_string(key: string, length: i32): u32 {
    let hash = 2166136261 as u32;
    for i in 0..length {
        hash = xor_u32(hash, key.data.at(i) as u32);
        hash = hash * (16777619 as u32);
    }
    return hash;
}

fun read_stdin_byte(): byte {
    let buffer_len = 1;
    let buffer = make[ptr[byte]](buffer_len);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, buffer, buffer_len);

    let nread = make[ptr[byte]](8);

    let err = _fd_read(0, ciovec, 1, nread);
    if err != 0 {
        panic("[read_stdin_byte] fd_read {}", err.to_string());
    }

    let n = read_i32_from_bytes_le(nread, 0);

    return buffer.at(0);
}

fun stdin(): string {
    let str = make[vec[byte]]();

    let b = read_stdin_byte();
    while b != 0 as byte {
        str.push(b);

        b = read_stdin_byte();
    }

    return vec_byte_to_string(str);
}

// 1.5 * 1024 * 1024 * 1024
let stack_limit: u32 = 1610612736 as u32;

// used in compiler
let _sp: u32 = 1610612736 as u32;

let _bp: u32 = 1610612736 as u32;

fun push_memstack(value: ptr[any]) {
    if !reflection::is_pointer(value) {
        panic("push_memstack: value is not a pointer");
    }

    let sp_ptr = _sp as ptr[ptr[byte]];
    sp_ptr.at(0) = value;

    _sp = _sp - (sizeof[ptr[any]]() as u32);

    if (_sp - (32 as u32)) < memory_block_limit {
        panic("StackOverflow");
    }
}

fun prologue() {
    push_memstack(_bp as ptr[any]);

    _bp = _sp;
}

fun epilogue() {
    _sp = _bp;

    let bp_ptr = (_bp as ptr[ptr[byte]]).offset(1);
    _bp = bp_ptr.at(0) as u32;

    // FIXME: when _bp == 0?
    if _bp != (0 as u32) && (_bp < _sp || _bp > stack_limit) {
        debug(_bp);
        debug(stack_limit);
        panic("StackUnderflow");
    }
}

fun get_stack_objects(): vec[ptr[any]] {
    let result = make[vec[ptr[any]]]();
    let p = _sp;
    while p < stack_limit {
        result.push((p as ptr[any]).at(0) as ptr[any]);

        p = p + (sizeof[ptr[any]]() as u32);
    }

    return result;
}

fun print_stack() {
    let p = _sp;
    while p < stack_limit {
        println("{}: {}", p.to_string(), derive::to_string((p as ptr[any]).at(0)));

        p = p + (8 as u32);
    }
}

let alloc_ptr: u32 = 0 as u32;

let heap_root_ptr: u32 = 0 as u32;

// 1 * 1024 * 1024 * 1024
let memory_block_limit: u32 = 1073741824 as u32;

fun alloc(size: i32): ptr[any] {
    let size_ = size;
    if size % sizeof[i32]() != 0 {
        size_ = ((size + sizeof[i32]() - 1) / sizeof[i32]()) * sizeof[i32]();
    }
    if size == 0 {
        return nil as ptr[any];
    }

    let current = alloc_ptr;
    alloc_ptr = alloc_ptr + (size_ as u32);

    let block = find_free_block(size_ as u32);
    if !block.get_is_free() {
        debug(7);
        abort();
    }

    // split
    block.set_size(block.get_size() - (size_ as u32) - Header::sizeof());
    if block.get_size() <= (0 as u32) {
        panic("alloc: block.size <= 0");
    }
    block.set_is_free(true);

    let current = block.get_next();
    current.set_size(size_ as u32);
    current.set_is_free(false);

    return current.get_data_ptr();
}

fun find_free_block(size: u32): Header {
    if (heap_root_ptr as ptr[any]) == (nil as ptr[any]) {
        let current = Header::from_ptr(alloc_ptr as ptr[any]);
        current.set_size(memory_block_limit);
        current.set_is_free(true);
        heap_root_ptr = alloc_ptr;
    }

    let current = Header::from_ptr(heap_root_ptr as ptr[any]);
    while !(current.get_is_free() && current.get_size() >= size) {
        current = current.get_next();

        if (current as u32) > memory_block_limit {
            debug(4);
            abort();
        }
    }

    return current;
}

fun free(p: ptr[any]) {
    let header = Header::from_data_ptr(p);
    header.set_is_free(true);

    let next = header.get_next();
    if next.get_is_free() {
        header.set_size(header.get_size() + next.get_size() + Header::sizeof());
    }
}

fun bit_not_u32(x: u32): u32 {
    return xor_u32(x, 4294967295); // 2^32 - 1
}

// size: u32,
// header_flags: u32,
struct Header {
}

module Header {
    fun sizeof(): u32 {
        return (sizeof[u32]() + sizeof[u32]()) as u32;
    }

    fun offset(): u32 {
        return 2 as u32;
    }

    fun from_ptr(p: ptr[byte]): Header {
        return p as Header;
    }

    fun from_data_ptr(p: ptr[byte]): Header {
        return Header::from_ptr(p.offset(0 - (Header::sizeof() as i32)));
    }

    fun get_next(self): Header {
        return Header::from_ptr((self as ptr[byte]).offset((Header::sizeof() + self.get_size()) as i32));
    }

    fun get_data_ptr(self): ptr[byte] {
        return (self as ptr[byte]).offset(Header::sizeof() as i32);
    }

    fun get_is_free(self): bool {
        return (self.get_header_flags() & 1 as u32) == (1 as u32);
    }

    fun set_is_free(self, value: bool) {
        if value {
            self.set_header_flags(self.get_header_flags() | (1 as u32));
        } else {
            self.set_header_flags(self.get_header_flags() & bit_not_u32(1 as u32));
        }
    }

    fun get_is_marked(self): bool {
        return (self.get_header_flags() & 2 as u32) == 2 as u32;
    }

    fun set_is_marked(self, value: bool) {
        if value {
            self.set_header_flags(self.get_header_flags() | (2 as u32));
        } else {
            self.set_header_flags(self.get_header_flags() & bit_not_u32(2 as u32));
        }
    }

    fun get_size(self): u32 {
        return (self as ptr[any]).at(0);
    }

    fun set_size(self, value: u32) {
        (self as ptr[any]).at(0) = value;
    }

    fun get_header_flags(self): u32 {
        return (self as ptr[any]).at(1);
    }

    fun set_header_flags(self, value: u32) {
        (self as ptr[any]).at(1) = value;
    }
}

fun print_header(name: string, header: Header) {
    println(
        "{} [size: {}, next: {}]",
        name,
        header.get_size().to_string(),
        (header.get_next() as u32).to_string(),
    );
}

fun print_heap_objects() {
    let count = 0;
    let count_alive = 0;
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() {
            print_header((header as u32).to_string(), header);
            count_alive = count_alive + 1;
        } else {
            println("free space {} [size: {}]", (header as u32).to_string(), header.get_size().to_string());
        }

        header = header.get_next();
        count = count + 1;
    }

    println("{} [END]", (header as u32).to_string());
    println("{} objects alive of {} blocks in total", count_alive.to_string(), count.to_string());
}

fun count_heap_objects(
): struct {
    alive: i32,
    total: i32,
} {
    let count = 0;
    let count_alive = 0;
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() {
            count_alive = count_alive + 1;
        }

        header = header.get_next();
        count = count + 1;
    }

    return struct {
        alive: count_alive,
        total: count,
    };
}

struct error {
    message: string,
    detail: vec[any],
}

module error {
    fun new(message: string): error {
        return error {
            message: message,
            detail: make[vec[any]](),
        };
    }

    fun context(self, detail: any): error {
        self.detail.push(detail);

        return self;
    }
}

fun or_error_context(this: any or error, detail: any): any or error {
    let result or err = this;
    if err != nil {
        return _ or err!.context(detail);
    }

    // FIXME: `return result!` won't work
    return result! or _;
}

// used in compiler
let type_reps_ptr = nil;

let type_reps_count = 0;

fun load_type_rep(id: i32): ptr[any] {
    if type_reps_ptr == nil {
        panic("load_type_rep: type_reps_ptr == 0");
    }

    let p = (type_reps_ptr as ptr[ptr[any]]).at(id);
    if !reflection::is_pointer(p) {
        panic("load_type_rep: not a pointer");
    }

    return p;
}

fun get_type_rep_address(rep_id: i32): ptr[ptr[any]] {
    if type_reps_ptr == nil {
        panic("get_type_rep_address: type_reps_ptr == 0");
    }

    return (type_reps_ptr as ptr[ptr[any]]).offset(rep_id);
}

fun is_address_type_rep(p: ptr[any]): bool {
    if !reflection::is_pointer(p) {
        return false;
    }

    let p_address = p as i32;
    let type_reps_ptr_address = type_reps_ptr as i32;

    return p_address >= type_reps_ptr_address && p_address < ((type_reps_ptr as ptr[any]).offset(
        type_reps_count,
    )) as i32;
}

fun is_a_record(p: ptr[ptr[any]]): bool {
    if !reflection::is_pointer(p) {
        return false;
    }

    return is_address_type_rep(p.at(0));
}

struct TypeRep {
    kind: i32,
    name: string,
    params: vec[TypeRep],
    fields: vec[string],
}

module TypeRep {
    fun sizeof(self): i32 {
        if self.name.equal("byte") {
            return 1;
        }

        return 8;
    }
}

module reflection {
    fun get_type_rep_ptr(t: any): ptr[any] {
        let index = reflection_get_type_rep_id(t);

        return load_type_rep(index);
    }

    // [nil, kind, rep_name, size of params, *params, size of fields, *fields]
    fun parse_type_rep(t: ptr[any]): TypeRep {
        if !reflection::is_pointer(t) {
            panic("Not a pointer");
        }
        if t.at(0) != nil {
            panic("Not a type rep");
        }

        let kind = t.at(1) as i32;
        let name = t.at(2) as string;
        let params_size = t.at(3) as i32;
        let params_ptr = (t.at(4) as ptr[ptr[any]]).offset(1);
        let fields_size = t.at(5) as i32;
        let fields_ptr = (t.at(6) as ptr[string]).offset(1);

        let params = make[vec[TypeRep]]();
        for i in 0..params_size {
            let rep = parse_type_rep(params_ptr.at(i));
            params.push(rep);
        }

        let fields = make[vec[string]]();
        for i in 0..fields_size {
            fields.push(fields_ptr.at(i));
        }

        return TypeRep {
            kind: kind,
            name: name,
            params: params,
            fields: fields,
        };
    }

    fun get_type_rep(t: any): TypeRep {
        if reflection::is_pointer(t) {
            if t == nil {
                return TypeRep {
                    kind: 1,
                    name: "nil",
                    params: make[vec[TypeRep]](),
                    fields: make[vec[string]](),
                };
            }

            if is_a_record(t) {
                return parse_type_rep((t as ptr[ptr[any]]).at(0).at(0));
            }

            return TypeRep {
                kind: 1,
                name: "ptr",
                params: make[vec[TypeRep]]((t as ptr[any]).at(0)),
                fields: make[vec[string]](),
            };
        }
        if reflection::is_bool(t) {
            return TypeRep {
                kind: 1,
                name: "bool",
                params: make[vec[TypeRep]](),
                fields: make[vec[string]](),
            };
        }

        return TypeRep {
            kind: 1,
            name: "i32",
            params: make[vec[TypeRep]](),
            fields: make[vec[string]](),
        };
    }

    fun is_pointer(t: any): bool {
        return _reflection_is_pointer(t);
    }

    fun is_bool(t: any): bool {
        return _reflection_is_bool(t);
    }

    fun assert_pointer(t: any) {
        if !is_pointer(t) {
            panic("assert_pointer");
        }
    }

    fun print_type(t: any) {
        let rep = get_type_rep(t);
        if rep.params.length == 0 {
            println(rep.name);
        } else {
            println("{}<{}>", rep.name, derive::to_string(rep.params));
        }
    }
}

module derive {
    fun to_string_internal(t: any, pretty: bool, depth: i32): string {
        let sep = "";
        if pretty {
            sep = "\n";
        }
        let indent = " ";
        if pretty {
            indent = " ".repeat(depth * 4);
        }

        let rep = reflection::get_type_rep(t);
        if rep.name.equal("string") {
            return format(`"{}"`, t as string);
        }
        if rep.name.equal("i32") {
            return (t as i32).to_string();
        }
        if rep.name.equal("bool") {
            return (t as bool).to_string();
        }
        if rep.name.equal("vec") {
            let s = format("vec(");
            let v = t as vec[any];
            for i in 0..v.length {
                if i > 0 {
                    s = s.concat(", ");
                }
                s = s.concat(derive::to_string_internal(v.at(i), pretty, depth + 1));
            }
            return s.concat(")");
        }
        if rep.name.equal("optional") {
            return format("({})?", derive::to_string_internal((t as any?)!, pretty, depth + 1));
        }
        if rep.name.equal("nil") {
            return "nil";
        }
        if rep.name.equal("byte") {
            return ((t as byte) as i32).to_string();
        }
        if rep.name.equal("ptr") {
            return format("<#{}>", (t as i32).to_string());
        }

        if rep.kind == 2 {
            // enum
            let s = format("{} {{}", rep.name, sep);

            let tag = (t as ptr[any]).offset(1).at(0) as i32;
            let tag_name = rep.fields.at(tag);

            let v = (t as ptr[any]).offset(1).at(1);
            s = s.concat(format(" {}: {} }", tag_name, derive::to_string_internal(v, pretty, depth + 1)));

            return s;
        }

        let s = format("{} {{}", rep.name, sep);
        for i in 0..rep.fields.length {
            if i > 0 {
                s = s.concat(format(",{}", sep));
            }
            let f = rep.fields.at(i);
            let v = (t as ptr[any]).offset(1).at(i);
            s = s.concat(format("{}{}: {}", indent, f, derive::to_string_internal(v, pretty, depth + 1)));
        }

        return s.concat(" }");
    }

    fun to_string(t: any): string {
        return derive::to_string_internal(t, false, 1);
    }

    fun to_string_pretty(t: any): string {
        return derive::to_string_internal(t, true, 1);
    }
}

fun file_open(path: string, oflags: i32, rights: i32): i32 {
    // TODO: check preopened directories
    let dirfd = 4;

    let fd = make[ptr[byte]](8);
    let err = _path_open(dirfd, 0, path.data, path.length, oflags, rights, 0, 0, fd as ptr[i32]);
    if err != 0 {
        panic("[file_write] path_open {}", err.to_string());
    }

    // TODO: what if fd is over 255?
    let fd_n = fd.at(0) as i32;

    return fd_n;
}

fun file_close(fd: i32) {
    let err = _fd_close(fd);
    if err != 0 {
        panic("fd_close {}", err.to_string());
    }
}

fun read_i32_from_bytes_le(p: ptr[byte], offset: i32): i32 {
    let result = 0;

    for i in offset..(offset + 4) {
        result = result | ((p.at(i) as i32) << (i * 8));
    }

    return result;
}

fun read_filestat_get(fd: i32): ptr[byte] {
    let stat = make[ptr[byte]](72);
    let err = _fd_filestat_get(fd, stat);
    if err != 0 {
        panic("fd_filestat_get {}", err.to_string());
    }

    return stat;
}

fun file_read(path: string): string {
    let fd_n = file_open(path, 0, 1 << 1);

    let filestat = read_filestat_get(fd_n);
    let size = read_i32_from_bytes_le(filestat, 24);

    let buffer_len = size;
    let buffer = make[ptr[byte]](buffer_len);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, buffer, buffer_len);

    let nread = make[ptr[byte]](8);

    let err = _fd_read(fd_n, ciovec, 1, nread);
    if err != 0 {
        panic("fd_read {}", err.to_string());
    }

    let n = read_i32_from_bytes_le(nread, 0);
    let v = new_string(buffer, n);

    file_close(fd_n);

    return v;
}

fun file_write(path: string, content: string) {
    let fd_n = file_open(path, 9, 1 << 6);

    let ciovec = make[ptr[byte]](8);
    set_ciovec(ciovec, content.data, content.length);

    let ptr_size = make[ptr[i32]](1);
    let err = _fd_write(fd_n, ciovec, ptr_size);
    if err != 0 {
        panic("[file_write] fd_write {}", err.to_string());
    }

    file_close(fd_n);
}

fun args_string(): string {
    let result = make[vec[byte]]();
    let n = get_args_len();
    for i in 0..n {
        result.push(get_args_at(i));
    }

    return vec_byte_to_string(result);
}

fun args(): vec[string] {
    let result = make[vec[string]]();
    let s = args_string();

    while true {
        let n = s.find_first(" ");
        if n == nil {
            result.push(s);
            break;
        }

        result.push(s.slice(0, n!));
        s = s.slice(n! + 1, s.length);
    }

    return result;
}

fun validate_address(address: i32) {
    let p = address as ptr[any];
    if p == nil as ptr[any] {
        println((_bp as ptr[any]).at(0) as string);
        debug(4);
        abort();
    }
}

fun perform_gc() {
    // mark
    let p = _sp;
    while p < stack_limit {
        let data = (p as ptr[any]).at(0) as ptr[any];
        if is_pointer_on_stack(data) {
            p = p + (sizeof[ptr[any]]() as u32);
            continue;
        }

        let d = data.at(0);

        if reflection::is_pointer(d) {
            let header = Header::from_ptr(d as ptr[any]);
            mark_and_load(header);
        } else if d != 0 {
            // FIXME: why?
            panic("perform_gc: not a pointer");
        }

        p = p + (sizeof[ptr[any]]() as u32);
    }

    println("mark");

    // sweep
    let header = Header::from_ptr(heap_root_ptr as ptr[any]);
    while header.get_size() > (0 as u32) {
        if !header.get_is_free() && !header.get_is_marked() {
            free(header.get_data_ptr());
        }
        if header.get_is_marked() {
            header.set_is_marked(false);
        }

        header = header.get_next();
    }

    println("sweep");
}

fun is_pointer_on_stack(p: ptr[ptr[byte]]): bool {
    return (p as u32) >= _sp && (p as u32) < stack_limit;
}

fun mark_and_load(object: Header) {
    if object.get_is_free() {
        return;
    }
    if object.get_is_marked() {
        return;
    }
    if is_pointer_on_stack(object as ptr[ptr[byte]]) {
        return;
    }

    object.set_is_marked(true);

    let rep = reflection::get_type_rep(object.get_data_ptr());
    if rep.name.equal("vec") {
        for k in (object as vec[any]) {
            if reflection::is_pointer(k) {
                mark_and_load(Header::from_data_ptr(k));
            }
        }
    } else if rep.name.equal("optional") {
        let v = (object as any?)!;
        if reflection::is_pointer(v) {
            mark_and_load(Header::from_data_ptr(v));
        }
    } else if rep.name.equal("ptr") {
        let v = (object as ptr[any]).at(0);
        if reflection::is_pointer(v) {
            mark_and_load(Header::from_data_ptr(v));
        }
    } else if rep.kind == 2 {
        let v = (object as ptr[any]).offset(1).at(1);
        if reflection::is_pointer(v) {
            mark_and_load(Header::from_data_ptr(v));
        }
    } else {
        for i in 0..rep.fields.length {
            let v = (object as ptr[any]).offset(1).at(i);
            if reflection::is_pointer(v) {
                mark_and_load(Header::from_data_ptr(v));
            }
        }
    }
}

