fun println(s: string) {
    let l = s.length;
    let d = s.data;
    let n = 0;

    // >>
    write_stdout(62 as byte);
    write_stdout(62 as byte);
    write_stdout(32 as byte);

    while n < l {
        write_stdout(d.at(n));
        n = n + 1;
    }

    // $\newline
    write_stdout(36 as byte);
    write_stdout(10 as byte);
}

fun vec_make(init_capacity: i32, size: i32): vec[i32] {
    let capacity = init_capacity;
    let length = 0;
    let data = alloc(capacity * size);
    return vec {
        data: data,
        length: length,
        capacity: capacity,
    };
}

fun vec_push(v: vec[i32], e: i32) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = alloc(new_capacity);
        mem_copy(v.data, new_data, v.length * sizeof[i32]());
        mem_free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun digit_to_string(digit: i32): string {
    return char_to_string(digit as byte);
}

fun char_to_string(char: byte): string {
    let s = make[array[byte,1]]();
    s.at(0) = char;

    return string {
        data: s.data,
        length: s.length,
    };
}

fun new_empty_string(length: i32): string {
    return string {
        data: alloc(length) as ptr[byte],
        length: length,
    };
}

fun is_included(s: string, n: i32, chars: string): bool {
    for i in 0..chars.length {
        if s.data.at(n) == chars.data.at(i) {
        return true;
        }
    }
    return false;
}

fun is_space(s: string, n: i32): bool {
    let c = s.data.at(n) as i32;
    return c == 32 || c == 9 || c == 10 || c == 13;
}

fun is_prefix(s: string, n: i32, prefix: string): bool {
    if s.length < n + prefix.length {
        return false;
    }

    for i in 0..prefix.length {
        if s.data.at(n + i) != prefix.data.at(i) {
        return false;
        }
    }

    return true;
}

fun vec_byte_to_string(b: vec[byte]): string {
    return string {
        data: b.data as ptr[byte],
        length: b.length,
    };
}

module i32 {
    fun to_string(self): string {
        if self == 0 {
            return "0";
        }

        let digit = 0;
        let tmp = self;
        while tmp > 0 {
            tmp = tmp / 10;
            digit = digit + 1;
        }

        let str = alloc(digit) as ptr[byte];
        tmp = self;
        for i in 0..digit {
            let d = tmp % 10;
            str.at(digit - i - 1) = ((d + 48) as byte);
            tmp = tmp / 10;
        }

        return string {
            data: str,
            length: digit,
        };
    }
}

module string {
    fun concat(self, s: string): string {
        let new_length = self.length + s.length;
        let new_data = alloc(new_length) as ptr[byte];

        for i in 0..self.length {
            new_data.at(i) = self.data.at(i);
        }
        for i in 0..s.length {
            new_data.at(self.length + i) = s.data.at(i);
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.data.at(i) != other.data.at(i) {
                return false;
            }
        }

        return true;
    }

    fun slice(self, start: i32, end: i32): string {
        return string {
            data: self.data.offset(start),
            length: end - start,
        };
    }

    fun slice_start(self, start: i32): string {
        return self.slice(start, self.length);
    }
}

fun panic(s: string) {
    println(s);
    abort();
}

// used in compiler
let strings = 0;

fun dump_strings() {
    println("strings: ".concat(strings.to_string()));

    for i in 0..105 {
        let s = strings as ptr[string];
        println((i.to_string()).concat("[").concat((s.at(i) as i32).to_string()).concat("]: ").concat((strings as ptr[string]).at(i)));
    }
}
