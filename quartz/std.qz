fun println(s: string) {
    let l = s.length;
    let d = s.data;
    let n = 0;

    // >>
    write_stdout(62 as byte);
    write_stdout(62 as byte);
    write_stdout(32 as byte);

    while n < l {
        write_stdout(d.at(n));
        n = n + 1;
    }

    // $\newline
    write_stdout(36 as byte);
    write_stdout(10 as byte);
}

fun vec_make(init_capacity: i32, size: i32): vec[i32] {
    let capacity = init_capacity;
    let length = 0;
    let data = alloc(capacity * size);
    return vec {
        data: data,
        length: length,
        capacity: capacity,
    };
}

fun vec_push(v: vec[i32], e: i32) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = alloc(new_capacity);
        mem_copy(v.data, new_data, v.length * sizeof[i32]());
        mem_free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at(v: vec[i32], n: i32): i32 {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun digit_to_string(digit: i32): string {
    return char_to_string(digit as byte);
}

fun char_to_string(char: byte): string {
    let s = make[array[byte,1]]();
    s.at(0) = char;

    return string {
        data: s.data,
        length: s.length,
    };
}

fun new_empty_string(length: i32): string {
    return string {
        data: alloc(length) as ptr[byte],
        length: length,
    };
}

fun is_included(s: string, n: i32, chars: string): bool {
    for i in 0..chars.length {
        if s.data.at(n) == chars.data.at(i) {
        return true;
        }
    }
    return false;
}

fun is_space(s: string, n: i32): bool {
    let c = s.data.at(n) as i32;
    return c == 32 || c == 9 || c == 10 || c == 13;
}

fun is_prefix(s: string, n: i32, prefix: string): bool {
    if s.length < n + prefix.length {
        return false;
    }

    for i in 0..prefix.length {
        if s.data.at(n + i) != prefix.data.at(i) {
        return false;
        }
    }

    return true;
}

fun vec_byte_to_string(b: vec[byte]): string {
    return string {
        data: b.data as ptr[byte],
        length: b.length,
    };
}

module bool {
    fun to_string(self): string {
        if self {
            return "true";
        } else {
            return "false";
        }
    }
}

module i32 {
    fun to_string(self): string {
        if self == 0 {
            return "0";
        }

        let digit = 0;
        let tmp = self;
        while tmp > 0 {
            tmp = tmp / 10;
            digit = digit + 1;
        }

        let str = alloc(digit) as ptr[byte];
        tmp = self;
        for i in 0..digit {
            let d = tmp % 10;
            str.at(digit - i - 1) = ((d + 48) as byte);
            tmp = tmp / 10;
        }

        return string {
            data: str,
            length: digit,
        };
    }
}

module string {
    fun concat(self, s: string): string {
        let new_length = self.length + s.length;
        let new_data = alloc(new_length) as ptr[byte];

        for i in 0..self.length {
            new_data.at(i) = self.data.at(i);
        }
        for i in 0..s.length {
            new_data.at(self.length + i) = s.data.at(i);
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.data.at(i) != other.data.at(i) {
                return false;
            }
        }

        return true;
    }

    fun slice(self, start: i32, end: i32): string {
        return string {
            data: self.data.offset(start),
            length: end - start,
        };
    }

    fun slice_start(self, start: i32): string {
        return self.slice(start, self.length);
    }

    fun at(self, n: i32): string {
        return char_to_string(self.data.at(n));
    }
}

fun panic(s: string) {
    println(s);
    abort();
}

// used in compiler
let strings_ptr = 0;
let strings_count = 0;

fun dump_strings() {
    println("[dump_strings]");

    for i in 0..strings_count {
        let s = strings_ptr as ptr[string];
        println((i.to_string()).concat("[").concat((s.at(i) as i32).to_string()).concat("]: ").concat((strings_ptr as ptr[string]).at(i)));
    }
}

type MapEntry = {
    key: string?,
    value: any,
};

type Map = {
    count: i32,
    capacity: i32,
    entries: vec[MapEntry]
};

fun map_make() {
    return Map {
        count: 0,
        capacity: 0,
        entries: make[vec[MapEntry]](),
    };
}

fun map_at(map: Map, key: string): any {
    if map.count == 0 {
        return nil as any;
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        return nil as any;
    } else {
        return entry.value;
    }
}

fun map_insert(map: Map, key: string, value: any) {
    if (map.count + 1) * 2 > map.capacity {
        let new_capacity = map.capacity * 2;
        if map.capacity == 0 {
            new_capacity = 8;
        }
        let new_entries = make[vec[MapEntry]](new_capacity);

        for i in 0..map.capacity {
            let entry = map.entries.at(i);
            if entry.key != nil {
                let hash = hash_string(entry.key!, entry.key!.length);
                let index = i64_to_i32(hash % i32_to_i64(new_capacity));

                let new_entry = new_entries.at(index);
                while new_entry.key != nil {
                    index = (index + 1) % new_capacity;
                    new_entry = new_entries.at(index);
                }

                new_entry.key = entry.key;
                new_entry.value = entry.value;
            }
        }

        map.capacity = new_capacity;
        map.entries = new_entries;
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        entry.key = key?;
        entry.value = value;
        map.count = map.count + 1;
    } else {
        entry.value = value;
    }
}

fun map_find_entry(map: Map, key: string): MapEntry {
    let hash = hash_string(key, key.length);
    let index = i64_to_i32(hash % i32_to_i64(map.capacity));

    let entry = map.entries.at(index);
    while entry.key != nil {
        if entry.key!.equal(key) {
            return entry;
        }
        index = (index + 1) % map.capacity;
        entry = map.entries.at(index);
    }

    return entry;
}

fun hash_string(key: string, length: i32): i64 {
    let hash = 2166136261 as i64;
    for i in 0..length {
        hash = xor_i64(hash, i32_to_i64(key.data.at(i) as i32));
        hash = hash * i32_to_i64(16777619);
    }
    return hash;
}
