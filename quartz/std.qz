fun print_string(s: string) {
    let l = s.length;
    let d = s.data;
    let n = 0;

    while n < l {
        write_stdout(d.at(n));
        n = n + 1;
    }
}

fun println(format: string, ..arg: vec[string]) {
    let str = format;
    for i in 0..arg.length {
        let a = arg.at(i);
        str = str.replace_first("{}", a);
    }

    print_string(str);

    // \newline
    write_stdout(10 as byte);
}

fun format(f: string, ..arg: vec[string]): string {
    let str = f;
    for i in 0..arg.length {
        let a = arg.at(i);
        str = str.replace_first("{}", a);
    }

    return str;
}

fun print(format: string, ..arg: vec[string]) {
    let str = format;
    for i in 0..arg.length {
        let a = arg.at(i);
        str = str.replace_first("{}", a);
    }

    print_string(str);
}

fun vec_make(init_capacity: i32, size: i32): vec[i32] {
    let capacity = init_capacity;
    let length = 0;
    let data = alloc(capacity * size);
    return vec {
        data: data,
        length: length,
        capacity: capacity,
    };
}

fun vec_push(v: vec[i32], e: i32) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = alloc(new_capacity);
        mem_copy(v.data, new_data, v.length * sizeof[i32]());
        mem_free(v.data);
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}

fun vec_at(v: vec[i32], n: i32): i32 {
    if n >= v.length {
        panic("vec_at: out of range: ".concat(n.to_string()));
    }

    return v.data.at(n);
}

fun vec_extend(v: vec[i32], other: vec[i32]) {
    for i in 0..other.length {
        vec_push(v, other.at(i));
    }
}

fun digit_to_string(digit: i32): string {
    return char_to_string(digit as byte);
}

fun char_to_string(char: byte): string {
    let s = make[array[byte,1]]();
    s.at(0) = char;

    return string {
        data: s.data,
        length: s.length,
    };
}

fun new_empty_string(length: i32): string {
    return string {
        data: alloc(length) as ptr[byte],
        length: length,
    };
}

fun is_included(s: string, n: i32, chars: string): bool {
    for i in 0..chars.length {
        if s.data.at(n) == chars.data.at(i) {
        return true;
        }
    }
    return false;
}

fun is_space(s: string, n: i32): bool {
    let c = s.data.at(n) as i32;
    return c == 32 || c == 9 || c == 10 || c == 13;
}

fun is_prefix(s: string, n: i32, prefix: string): bool {
    if s.length < n + prefix.length {
        return false;
    }

    for i in 0..prefix.length {
        if s.data.at(n + i) != prefix.data.at(i) {
        return false;
        }
    }

    return true;
}

fun vec_byte_to_string(b: vec[byte]): string {
    return string {
        data: b.data as ptr[byte],
        length: b.length,
    };
}

module bool {
    fun to_string(self): string {
        if self {
            return "true";
        } else {
            return "false";
        }
    }
}

module i32 {
    fun to_string(self): string {
        if self == 0 {
            return "0";
        }

        let digit = 0;
        let tmp = self;
        while tmp > 0 {
            tmp = tmp / 10;
            digit = digit + 1;
        }

        let str = alloc(digit) as ptr[byte];
        tmp = self;
        for i in 0..digit {
            let d = tmp % 10;
            str.at(digit - i - 1) = ((d + 48) as byte);
            tmp = tmp / 10;
        }

        return string {
            data: str,
            length: digit,
        };
    }
}

module string {
    fun concat(self, s: string): string {
        let new_length = self.length + s.length;
        let new_data = alloc(new_length) as ptr[byte];

        for i in 0..self.length {
            new_data.at(i) = self.data.at(i);
        }
        for i in 0..s.length {
            new_data.at(self.length + i) = s.data.at(i);
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.data.at(i) != other.data.at(i) {
                return false;
            }
        }

        return true;
    }

    fun slice(self, start: i32, end: i32): string {
        return string {
            data: self.data.offset(start),
            length: end - start,
        };
    }

    fun slice_start(self, start: i32): string {
        return self.slice(start, self.length);
    }

    fun at(self, n: i32): string {
        return char_to_string(self.data.at(n));
    }

    fun repeat(self, n: i32): string {
        let new_length = self.length * n;
        let new_data = alloc(new_length) as ptr[byte];

        for i in 0..n {
            for j in 0..self.length {
                new_data.at(i * self.length + j) = self.data.at(j);
            }
        }

        return string {
            data: new_data,
            length: new_length,
        };
    }

    fun to_string(self): string {
        return self;
    }

    fun find_first(self, haystack: string): i32? {
        let n = 0;
        while n <= self.length - haystack.length {
            if is_prefix(self, n, haystack) {
                return n?;
            } else {
                n = n + 1;
            }
        }

        return nil;
    }

    fun replace_first(self, from: string, to: string): string {
        let n = self.find_first(from);
        if n == nil {
            return self;
        }

        return self.slice(0, n!).concat(to).concat(self.slice_start(n! + from.length));
    }
}

fun panic(s: string) {
    println(s);
    abort();
}

// used in compiler
let strings_ptr = 0;
let strings_count = 0;

fun dump_strings() {
    println("[dump_strings]");

    for i in 0..strings_count {
        let s = strings_ptr as ptr[string];
        println((i.to_string()).concat("[").concat((s.at(i) as i32).to_string()).concat("]: ").concat((strings_ptr as ptr[string]).at(i)));
    }
}

type MapEntry = {
    key: string?,
    value: any,
};

type Map = {
    count: i32,
    capacity: i32,
    entries: ptr[MapEntry]
};

fun map_make(): Map {
    return Map {
        count: 0,
        capacity: 0,
        entries: nil as ptr[MapEntry],
    };
}

fun map_at(map: Map, key: string): any {
    if map.count == 0 {
        panic("map_at: key ".concat(key).concat(" not found"));
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        panic("map_at: key ".concat(key).concat(" not found"));
    } else {
        return entry.value;
    }
}

fun map_has(map: Map, key: string): bool {
    if map.count == 0 {
        return false;
    }

    let entry = map_find_entry(map, key);
    return entry.key != nil;
}

fun map_insert(map: Map, key: string, value: any) {
    if (map.count + 1) * 2 > map.capacity {
        let new_capacity = map.capacity * 2;
        if new_capacity == 0 {
            new_capacity = 8;
        }

        let entries = alloc(new_capacity) as ptr[MapEntry];

        for i in 0..new_capacity {
            if i < map.capacity {
                entries.at(i) = map.entries.at(i);
            } else {
                entries.at(i) = MapEntry {
                    key: nil,
                    value: nil as any,
                };
            }
        }

        map.entries = entries;
        map.capacity = new_capacity;
    }

    let entry = map_find_entry(map, key);
    if entry.key == nil {
        entry.key = key?;
        entry.value = value;
        map.count = map.count + 1;
    } else {
        entry.value = value;
    }
}

fun map_find_entry(map: Map, key: string): MapEntry {
    let hash = hash_string(key, key.length);
    let index = i64_to_i32(hash % i32_to_i64(map.capacity));

    let entry = map.entries.at(index);
    while true {
        if entry.key == nil || entry.key!.equal(key) {
            return entry;
        }
        index = (index + 1) % map.capacity;
        entry = map.entries.at(index);
    }
}

fun hash_string(key: string, length: i32): i64 {
    let hash = 2166136261 as i64;
    for i in 0..length {
        hash = xor_i64(hash, i32_to_i64(key.data.at(i) as i32));
        hash = hash * i32_to_i64(16777619);
    }
    return hash;
}

fun stdin(): string {
    let str = make[vec[byte]]();

    let b = read_stdin();
    while b as i32 != 0 {
        str.push(b);

        b = read_stdin();
    }

    return vec_byte_to_string(str);
}
