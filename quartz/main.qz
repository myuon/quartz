import quartz::std;
import quartz::lexer;

fun test() {
    if !string_equal("hello", "hello") {
        println("string_equal failed");
    }
    if string_equal("hello", "world") {
        println("string_equal failed");
    }
    if !is_space("hoge fuga", 4) {
        println("is_space failed");
    }
    if !string_equal(slice("hoge fuga", 0, 4), "hoge") {
        println("slice failed");
        println(slice("hoge fuga", 0, 4));
    }
    if !string_equal(slice_start("hoge fuga", 2), "ge fuga") {
        println("slice_start failed");
        println(slice_start("hoge fuga", 2));
    }
    if !string_equal("hoge".concat(" fuga"), "hoge fuga") {
        println("string_concat failed");
        println("hoge".concat(" fuga"));
    }
}

fun main() {
    test();

    let lexer = Lexer::new();
    lexer.run(`
fun main(): i32 {
    let x: i32 = 10;
    return x + 1;
}
`);

    let tokens = lexer.tokens;
    for i in 0..tokens.length {
        let token = tokens.at(i);
        println("lexeme: ".concat(token.lexeme));
        if token.string_value != nil {
            println("string_value: ".concat(token.string_value!));
        }
    }

    debug_i32(lexer.tokens.length);
}
