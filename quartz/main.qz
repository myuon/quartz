import quartz::std;
import quartz::path;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;
import quartz::value;
import quartz::compiler;
import quartz::location;
import quartz::formatter;

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}

fun test() {
    assert_eq_string("hoge", "hoge");
    assert(is_space("hoge fuga", 4));
    assert_eq_string("hoge fuga".slice(0, 4), "hoge");
    assert_eq_string("hoge fuga".slice_start(2), "ge fuga");
    assert_eq_string("hoge".concat(" fuga"), "hoge fuga");
    assert_eq_string("hoge".repeat(3), "hogehogehoge");

    assert_eq_string(derive::to_string(false), "false");
    assert_eq_string(derive::to_string(1), "1");
    assert_eq_string(derive::to_string("hello"), "\"hello\"");
    assert_eq_string(
        derive::to_string(struct {
            name: "foo",
            age: 20,
        }),
        `struct { name: "foo", age: 20 }`,
    );
    assert_eq_string(derive::to_string(4?), "(4)?");

    let v = make[vec[i32]]();
    v.push(1);
    v.push(2);
    v.push(3);
    assert_eq_string(derive::to_string(v), "vec(1, 2, 3)");

    assert(reflection::is_pointer("foo"));
    assert(!reflection::is_pointer(10));
    assert(!reflection::is_pointer(true));
    assert(!reflection::is_pointer("foo".at(1)));

    assert_eq_string((1024 as i64).to_string(), "1024");
    assert_eq_string((1 as i64).to_string(), "1");
}

enum CliCommand {
    compile: struct {
        output: string?,
        stdin: bool?,
        input: string?,
    },
    run: struct {
        stdin: bool?,
        input: string?,
    },
    format: struct {
        input: string?,
        write: bool?,
    },
    check: struct {
        input: string?,
    },
    check_type: struct {
        input: string?,
        line: i32,
        column: i32,
    },
}

module CliCommand {
    fun parse(args: vec[string]): CliCommand or error {
        if args.at(0).equal("compile") {
            let i = 1;
            let compile = struct {
                output: nil,
                stdin: nil,
                input: nil,
            };

            while i < args.length {
                if args.at(i).equal("-o") {
                    compile.output = args.at(i + 1)?;
                    i = i + 1;
                } else if args.at(i).equal("--output") {
                    compile.output = args.at(i + 1)?;
                    i = i + 1;
                } else if args.at(i).equal("--stdin") {
                    compile.stdin = true?;
                } else {
                    break;
                }

                i = i + 1;
            }

            if compile.stdin == nil {
                compile.input = args.at(i)?;
            }

            return CliCommand {
                compile: compile,
            };
        } else if args.at(0).equal("run") {
            let i = 1;
            let run = struct {
                stdin: nil,
                input: nil,
            };

            while i < args.length {
                if args.at(i).equal("-o") {
                    run.stdin = true?;
                }
            }

            return CliCommand {
                run: run,
            };
        } else if args.at(0).equal("format") {
            let i = 1;
            let format_ = struct {
                input: nil,
                write: nil,
            };

            while i < args.length {
                if args.at(i).equal("-w") {
                    format_.write = true?;
                } else {
                    break;
                }

                i = i + 1;
            }

            format_.input = args.at(i)?;

            return CliCommand {
                format: format_,
            };
        } else if args.at(0).equal("check") {
            let i = 1;
            let check = struct {
                input: nil,
            };

            check.input = args.at(i)?;

            return CliCommand {
                check: check,
            };
        } else if args.at(0).equal("check-type") {
            let i = 1;
            let check_type = struct {
                input: nil,
                line: 0,
                column: 0,
            };

            while i < args.length {
                if args.at(i).equal("--line") {
                    check_type.line = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--column") {
                    check_type.column = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else {
                    break;
                }

                i = i + 1;
            }

            check_type.input = args.at(i)?;

            return CliCommand {
                check_type: check_type,
            };
        } else {
            return _ or error::new(format("unknown command: {}", derive::to_string(args)));
        }
    }
}

fun main() {
    test();

    let args = args();
    let command or err = CliCommand::parse(args.slice(1, args.length));
    if err != nil {
        panic(err!.message);
    }

    let command = command!;
    if command.compile != nil {
        let compile = command.compile!;

        let input = "";
        if compile.input != nil {
            input = file_read(compile.input!);
        } else if compile.stdin != nil {
            input = stdin();
        } else {
            panic("no input");
        }

        let result or err = run(input);
        if err != nil {
            panic(err!.message);
        }

        println("compiled: writing wat to {}", compile.output!);
        file_write(compile.output!, result!);

        return nil;
    } else if command.run != nil {
        let runc = command.run!;

        let input = "";
        if runc.input != nil {
            input = file_read(runc.input!);
        } else if runc.stdin != nil {
            input = stdin();
        } else {
            panic("no input");
        }

        let result or err = run(input);
        if err != nil {
            panic(err!.message);
        }

        println("{}", result!);
    } else if command.format != nil {
        let f = command.format!;

        let input = file_read(f.input!);
        let result or err = run_format(input);
        if err != nil {
            panic(err!.message);
        }

        println("{}", result!);
    } else if command.check != nil {
        let check = command.check!;

        let input = file_read(check.input!);

        let compiler = Compiler::new();
        let result or err = compiler.check(input);
        if err != nil {
            panic(err!.message);
        }
    } else if command.check_type != nil {
        let check_type = command.check_type!;

        let input = file_read(check_type.input!);

        let compiler = Compiler::new();
        let result or err = compiler.check_type(input, check_type.line, check_type.column);
        if err != nil {
            panic(err!.message);
        }

        if result != nil {
            println(result!);
        }
    } else {
        println("unknown args: {}", derive::to_string(args));
        println("{}", args.at(1));

        return nil;
    }

    return nil;
}

fun run(input_: string): string or error {
    let compiler = Compiler::new();
    return compiler.compile(input_).try;
}

fun run_format(input_: string): string or error {
    let lexer = Lexer::new();
    lexer.run(input_).try;

    let comments = make[vec[Token]]();
    for token in lexer.tokens {
        if token.lexeme.equal("comment") {
            comments.push(token);
        }
    }

    let parser = Parser::new();
    let module_ = parser.run(lexer.tokens).try;

    let formatter = Formatter::new(input_, comments, 0);
    return formatter.format(module_);
}

