import quartz::std;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;

fun test() {
    if !"hello".equal("hello") {
        panic("string_equal failed: hello vs hello");
    }
    if "hello".equal("world") {
        panic("string_equal failed: hello vs world");
    }
    if !is_space("hoge fuga", 4) {
        panic("is_space failed");
    }
    if !"hoge fuga".slice(0, 4).equal("hoge") {
        panic("slice failed");
    }
    if !"hoge fuga".slice_start(2).equal("ge fuga") {
        panic("slice_start failed");
    }
    if !"hoge".concat(" fuga").equal("hoge fuga") {
        panic("string_concat failed");
    }
    if !"hoge".repeat(3).equal("hogehogehoge") {
        panic("string_repeat failed");
    }
}

// example input:
//
// fun main(): i32 {
//     let x: i32 = 10;
//     return x + 1;
// }

fun main() {
    // dump_strings();
    test();

    println(run(stdin()));
}

fun run(input: string): string {
    let lexer = Lexer::new();
    lexer.run(input);

    let parser = Parser::new();
    let result = parser.run(lexer.tokens);

    let typechecker = Typechecker::new();
    typechecker.function(result);

    let irgen = IrCodeGenerator::new();
    let term = irgen.function(result);

    let gen = Generator::new();
    let code = gen.run(term);

    return code;
}
