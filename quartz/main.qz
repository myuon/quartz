import quartz::std;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;

fun test() {
    if !"hello".equal("hello") {
        panic("string_equal failed: hello vs hello");
    }
    if "hello".equal("world") {
        panic("string_equal failed: hello vs world");
    }
    if !is_space("hoge fuga", 4) {
        panic("is_space failed");
    }
    if !"hoge fuga".slice(0, 4).equal("hoge") {
        panic("slice failed");
    }
    if !"hoge fuga".slice_start(2).equal("ge fuga") {
        panic("slice_start failed");
    }
    if !"hoge".concat(" fuga").equal("hoge fuga") {
        panic("string_concat failed");
    }
    if !"hoge".repeat(3).equal("hogehogehoge") {
        panic("string_repeat failed");
    }
}

fun main() {
    // dump_strings();
    test();

    let result or err = run(stdin());
    if err != nil {
        // reflection::print_type(err as byte);
        panic(err!.message);
    }

    println(result!);
}

fun run(input: string): string or error {
    let lexer = Lexer::new();
    lexer.run(input).try;
    // println("lexer");

    let parser = Parser::new();
    let result = parser.run(lexer.tokens).try;
    // println("parser");

    let typechecker = Typechecker::new();
    typechecker.module_(result).try;
    // println("typecheck");

    let irgen = IrCodeGenerator::new();
    irgen.globals = typechecker.globals;
    let term = irgen.module_(result);
    // println("irgen: {}", term.to_string());

    let gen = Generator::new();
    gen.set_globals(typechecker.globals);
    let code = gen.run(term);

    return code;
}
