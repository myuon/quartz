import quartz::std;
import quartz::path;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;
import quartz::value;
import quartz::compiler;

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}

fun test() {
    assert_eq_string("hoge", "hoge");
    assert(is_space("hoge fuga", 4));
    assert_eq_string("hoge fuga".slice(0, 4), "hoge");
    assert_eq_string("hoge fuga".slice_start(2), "ge fuga");
    assert_eq_string("hoge".concat(" fuga"), "hoge fuga");
    assert_eq_string("hoge".repeat(3), "hogehogehoge");

    assert_eq_string(derive::to_string(false), "false");
    assert_eq_string(derive::to_string(1), "1");
    assert_eq_string(derive::to_string("hello"), "\"hello\"");
    assert_eq_string(
        derive::to_string(struct {
            name: "foo",
            age: 20,
        }),
        `struct { name: "foo", age: 20 }`,
    );
    assert_eq_string(derive::to_string(4?), "(4)?");

    let v = make[vec[i32]]();
    v.push(1);
    v.push(2);
    v.push(3);
    assert_eq_string(derive::to_string(v), "vec(1, 2, 3)");

    assert(reflection::is_pointer("foo"));
    assert(!reflection::is_pointer(10));
    assert(!reflection::is_pointer(true));
    assert(!reflection::is_pointer("foo".at(1)));

    assert_eq_string((1024 as i64).to_string(), "1024");
    assert_eq_string((1 as i64).to_string(), "1");
}

fun main() {
    test();

    let args = args();
    if args.at(1).equal("compile") {
        if args.at(2).equal("-o") {
            let file = args.at(3);

            let input = "";
            if args.length >= 5 {
                input = file_read(args.at(4));
            } else {
                input = stdin();
            }

            let result or err = run(input);
            if err != nil {
                panic(err!.message);
            }
        }
    } else {
        println("{}", derive::to_string(args));
        println("{}", args.at(1));

        return nil;
    }

    let result or err = run(stdin());
    if err != nil {
        panic(err!.message);
    }

    println(result!);
}

fun run(input_: string): string or error {
    let compiler = Compiler::new();
    return compiler.compile(input_).try;
}

