import quartz::std;
import quartz::path;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;
import quartz::value;
import quartz::compiler;

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}

fun test() {
    assert_eq_string("hoge", "hoge");
    assert(is_space("hoge fuga", 4));
    assert_eq_string("hoge fuga".slice(0, 4), "hoge");
    assert_eq_string("hoge fuga".slice_start(2), "ge fuga");
    assert_eq_string("hoge".concat(" fuga"), "hoge fuga");
    assert_eq_string("hoge".repeat(3), "hogehogehoge");

    assert_eq_string(derive::to_string(false), "false");
    assert_eq_string(derive::to_string(1), "1");
    assert_eq_string(derive::to_string("hello"), "\"hello\"");
    assert_eq_string(
        derive::to_string(struct {
            name: "foo",
            age: 20,
        }),
        `struct { name: "foo", age: 20 }`,
    );
    assert_eq_string(derive::to_string(4?), "(4)?");

    let v = make[vec[i32]]();
    v.push(1);
    v.push(2);
    v.push(3);
    assert_eq_string(derive::to_string(v), "vec(1, 2, 3)");

    assert(reflection::is_pointer("foo"));
    assert(!reflection::is_pointer(10));
    assert(!reflection::is_pointer(true));
    assert(!reflection::is_pointer("foo".at(1)));

    assert_eq_string((1024 as i64).to_string(), "1024");
    assert_eq_string((1 as i64).to_string(), "1");
}

fun main() {
    // dump_strings();
    test();

    let result or err = run(stdin());
    if err != nil {
        panic(err!.message);
    }

    println(result!);
}

fun run(input_: string): string or error {
    // let content = file_read("quartz/std.qz");
    // let input = content.concat(input_);
    let input = `
let quartz_std_strings_ptr = 0;

fun load_string(index: i32): string {
    return (quartz_std_strings_ptr as ptr[string]).at(index);
}

module string {
    fun at(self, n: i32): byte {
        return self.data.at(n);
    }

    fun equal(self, other: string): bool {
        if self.length != other.length {
            return false;
        }

        for i in 0..self.length {
            if self.at(i) != other.at(i) {
                return false;
            }
        }

        return true;
    }
}

fun quartz_std_new_string(p: ptr[byte], length: i32): string {
    return string {
        data: p,
        length: length,
    };
}

fun quartz_std_vec_make(capacity: i32): vec[i32] {
    return vec {
        data: make[ptr[i32]](capacity),
        length: 0,
        capacity: capacity,
    };
}

fun quartz_std_vec_push(v: vec[i32], e: i32) {
    if (v.length + 1) == v.capacity {
        let new_capacity = v.capacity * 2;
        let new_data = make[ptr[i32]](new_capacity);
        for i in 0..v.length {
            new_data.at(i) = v.data.at(i);
        }
        v.data = new_data;
        v.capacity = new_capacity;
    }

    v.data.at(v.length) = e;
    v.length = v.length + 1;
}
`.concat(
        input_,
    );

    let lexer = Lexer::new();
    lexer.run(input).try;
    // println("lexer");

    let parser = Parser::new();
    let result = parser.run(lexer.tokens).try;
    // println("parser");

    let typechecker = Typechecker::new();
    typechecker.module_(result).try;
    // println("typecheck");

    let irgen = IrCodeGenerator::new();
    irgen.globals = typechecker.globals;
    let term = irgen.run(result).try;

    // println("irgen: {}", term.to_string());

    let gen = Generator::new();
    gen.set_globals(typechecker.globals);
    gen.set_strings(irgen.strings.strings);
    let code = gen.run(term);

    return code;
}

