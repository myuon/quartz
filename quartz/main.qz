import quartz::std;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;
import quartz::value;

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}

fun test() {
    assert_eq_string("hoge", "hoge");
    assert(is_space("hoge fuga", 4));
    assert_eq_string("hoge fuga".slice(0, 4), "hoge");
    assert_eq_string("hoge fuga".slice_start(2), "ge fuga");
    assert_eq_string("hoge".concat(" fuga"), "hoge fuga");
    assert_eq_string("hoge".repeat(3), "hogehogehoge");

    assert_eq_string(derive::to_string(false), "false");
    assert_eq_string(derive::to_string(1), "1");
    assert_eq_string(derive::to_string("hello"), "\"hello\"");
    assert_eq_string(
        derive::to_string(struct {
            name: "foo",
            age: 20,
        }),
        `struct { name: "foo", age: 20 }`,
    );
    assert_eq_string(derive::to_string(4?), "(4)?");

    let v = make[vec[i32]]();
    v.push(1);
    v.push(2);
    v.push(3);
    assert_eq_string(derive::to_string(v), "vec(1, 2, 3)");

    assert(reflection::is_pointer("foo"));
    assert(!reflection::is_pointer(10));
    assert(!reflection::is_pointer(true));
    assert(!reflection::is_pointer("foo".at(1)));
}

fun main() {
    // dump_strings();
    test();

    let result or err = run(stdin());
    if err != nil {
        panic(err!.message);
    }

    println(result!);
}

fun run(input: string): string or error {
    let lexer = Lexer::new();
    lexer.run(input).try;
    // println("lexer");

    let parser = Parser::new();
    let result = parser.run(lexer.tokens).try;
    // println("parser");

    let typechecker = Typechecker::new();
    typechecker.module_(result).try;
    // println("typecheck");

    let irgen = IrCodeGenerator::new();
    irgen.globals = typechecker.globals;
    let term = irgen.module_(result).try;

    // println("irgen: {}", term.to_string());

    let gen = Generator::new();
    gen.set_globals(typechecker.globals);
    let code = gen.run(term);

    return code;
}

