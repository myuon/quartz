import quartz::std;
import quartz::path;
import quartz::lexer;
import quartz::parser;
import quartz::ast;
import quartz::ir;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::typecheck;
import quartz::value;
import quartz::compiler;
import quartz::location;
import quartz::formatter;
import quartz::json;
import quartz::errors;

fun assert_eq_string(a: string, b: string) {
    if !a.equal(b) {
        panic("assert_eq_string failed: ".concat(a).concat(" != ").concat(b));
    }
}

fun assert(a: bool) {
    if !a {
        panic("assert failed");
    }
}

fun test() {
    assert_eq_string("hoge", "hoge");
    assert(is_space("hoge fuga", 4));
    assert_eq_string("hoge fuga".slice(0, 4), "hoge");
    assert_eq_string("hoge fuga".slice_start(2), "ge fuga");
    assert_eq_string("hoge".concat(" fuga"), "hoge fuga");
    assert_eq_string("hoge".repeat(3), "hogehogehoge");

    assert_eq_string(
        derive::to_string("apple/banana/orange/lime".split("/")),
        derive::to_string(make[vec[string]]("apple", "banana", "orange", "lime")),
    );

    assert_eq_string(derive::to_string(false), "false");
    assert_eq_string(derive::to_string(1), "1");
    assert_eq_string(derive::to_string("hello"), "\"hello\"");
    assert_eq_string(
        derive::to_string(struct {
            name: "foo",
            age: 20,
        }),
        `struct { name: "foo", age: 20 }`,
    );
    assert_eq_string(derive::to_string(4?), "(4)?");

    let v = make[vec[i32]]();
    v.push(1);
    v.push(2);
    v.push(3);
    assert_eq_string(derive::to_string(v), "vec(1, 2, 3)");

    assert(reflection::is_pointer("foo"));
    assert(!reflection::is_pointer(10));
    assert(!reflection::is_pointer(true));
    assert(!reflection::is_pointer("foo".at(1)));

    assert_eq_string((1024 as i64).to_string(), "1024");
    assert_eq_string((1 as i64).to_string(), "1");
}

struct ArgCommand {
    command: string,
    args: vec[string],
    options: map[string, string],
}

struct ArgParser {
}

module ArgParser {
    fun parse(args: vec[string]): ArgCommand {
        let command = args.at(0);
        let command_args = make[vec[string]]();
        let options = make[map[string, string]]();

        let i = 1;
        while i < args.length {
            let arg = args.at(i);
            if arg.starts_with("--") {
                options.insert(arg.slice_start(2), args.at(i + 1));
                i = i + 1;
            } else {
                command_args.push(arg);
            }

            i = i + 1;
        }

        return ArgCommand {
            command: command,
            args: command_args,
            options: options,
        };
    }
}

enum CliCommand {
    compile: struct {
        output: string?,
        stdin: bool?,
        input: string?,
    },
    run: struct {
        stdin: bool?,
        input: string?,
    },
    format: struct {
        input: string?,
        stdin: bool?,
        write: bool?,
    },
    check: struct {
        input: string?,
    },
    check_type: struct {
        input: string?,
        line: i32,
        column: i32,
    },
    go_to_def: struct {
        input: string?,
        project: string?,
        line: i32,
        column: i32,
    },
    completion: struct {
        input: string?,
        line: i32,
        column: i32,
        stdin: bool,
        dot: bool,
    },
}

module CliCommand {
    fun parse(args: vec[string]): CliCommand or error {
        if args.at(0).equal("compile") {
            let i = 1;
            let compile = struct {
                output: nil,
                stdin: nil,
                input: nil,
            };

            while i < args.length {
                if args.at(i).equal("-o") {
                    compile.output = args.at(i + 1)?;
                    i = i + 1;
                } else if args.at(i).equal("--output") {
                    compile.output = args.at(i + 1)?;
                    i = i + 1;
                } else if args.at(i).equal("--stdin") {
                    compile.stdin = true?;
                } else {
                    break;
                }

                i = i + 1;
            }

            if compile.stdin == nil {
                compile.input = args.at(i)?;
            }

            return CliCommand {
                compile: compile,
            };
        } else if args.at(0).equal("run") {
            let i = 1;
            let run = struct {
                stdin: nil,
                input: nil,
            };

            while i < args.length {
                if args.at(i).equal("-o") {
                    run.stdin = true?;
                }
            }

            return CliCommand {
                run: run,
            };
        } else if args.at(0).equal("format") {
            let i = 1;
            let format_ = struct {
                input: nil,
                stdin: nil,
                write: nil,
            };

            while i < args.length {
                if args.at(i).equal("-w") {
                    format_.write = true?;
                } else if args.at(i).equal("--write") {
                    format_.write = true?;
                } else if args.at(i).equal("--stdin") {
                    format_.stdin = true?;
                } else {
                    break;
                }

                i = i + 1;
            }

            if format_.stdin == nil {
                format_.input = args.at(i)?;
            }

            return CliCommand {
                format: format_,
            };
        } else if args.at(0).equal("check") {
            let i = 1;
            let check = struct {
                input: nil,
            };

            check.input = args.at(i)?;

            return CliCommand {
                check: check,
            };
        } else if args.at(0).equal("check-type") {
            let i = 1;
            let check_type = struct {
                input: nil,
                line: 0,
                column: 0,
            };

            while i < args.length {
                if args.at(i).equal("--line") {
                    check_type.line = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--column") {
                    check_type.column = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--project") {
                    i = i + 1;
                } else {
                    check_type.input = args.at(i)?;
                }

                i = i + 1;
            }

            return CliCommand {
                check_type: check_type,
            };
        } else if args.at(0).equal("go-to-def") {
            let i = 1;
            let go_to_def = struct {
                input: nil,
                project: nil,
                line: 0,
                column: 0,
            };

            while i < args.length {
                if args.at(i).equal("--line") {
                    go_to_def.line = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--column") {
                    go_to_def.column = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--project") {
                    go_to_def.project = args.at(i + 1)?;
                    i = i + 1;
                } else {
                    go_to_def.input = args.at(i)?;
                }

                i = i + 1;
            }

            return CliCommand {
                go_to_def: go_to_def,
            };
        } else if args.at(0).equal("completion") {
            let i = 1;
            let completion = struct {
                input: nil,
                line: 0,
                column: 0,
                stdin: false,
                dot: false,
            };

            while i < args.length {
                if args.at(i).equal("--line") {
                    completion.line = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--column") {
                    completion.column = i32::parse(args.at(i + 1));
                    i = i + 1;
                } else if args.at(i).equal("--stdin") {
                    completion.stdin = true;
                } else if args.at(i).equal("--dot") {
                    completion.dot = true;
                } else if args.at(i).equal("--project") {
                    i = i + 1;
                } else {
                    completion.input = args.at(i)?;
                }

                i = i + 1;
            }

            return CliCommand {
                completion: completion,
            };
        } else {
            return _ or error::new(format("unknown command: {}", derive::to_string(args)));
        }
    }
}

fun main() {
    test();

    let args = args();
    let command or err = CliCommand::parse(args.slice(1, args.length));
    if err != nil {
        panic(err!.message);
    }

    let command = command!;
    if command.compile != nil {
        let compile = command.compile!;

        let input = "";
        if compile.input != nil {
            input = file_read(compile.input!);
        } else if compile.stdin != nil {
            input = stdin();
        } else {
            panic("no input");
        }

        let result or err = run(input);
        if err != nil {
            panic(err!.message);
        }

        println("compiled: writing wat to {}", compile.output!);
        file_write(compile.output!, result!);

        return nil;
    } else if command.run != nil {
        let runc = command.run!;

        let input = "";
        if runc.input != nil {
            input = file_read(runc.input!);
        } else if runc.stdin != nil {
            input = stdin();
        } else {
            panic("no input");
        }

        let result or err = run(input);
        if err != nil {
            panic(err!.message);
        }

        println("{}", result!);
    } else if command.format != nil {
        let f = command.format!;

        let input = "";
        if f.input != nil {
            input = file_read(f.input!);
        } else if f.stdin != nil {
            input = stdin();
        } else {
            panic("no input");
        }

        let result or err = run_format(input);
        if err != nil {
            panic(err!.message);
        }

        if f.write != nil {
            file_write(f.input!, result!);
        } else {
            println("{}", result!);
        }
    } else if command.check != nil {
        let check = command.check!;

        let input = file_read(check.input!);

        let compiler = Compiler::new();
        let result or err = compiler.check(input);
        if err != nil {
            let message = make[map[string, Json]]();
            message.insert(
                "message",
                Json {
                    t_string: err!.message,
                },
            );
            message.insert(
                "start",
                Json {
                    t_array: make[vec[Json]](
                        Json {
                            t_i32: 0,
                        },
                        Json {
                            t_i32: 0,
                        },
                    ),
                },
            );
            message.insert(
                "end",
                Json {
                    t_array: make[vec[Json]](
                        Json {
                            t_i32: 0,
                        },
                        Json {
                            t_i32: 0,
                        },
                    ),
                },
            );

            println(Json {
                t_array: make[vec[Json]](Json {
                    t_object: message,
                }),
            }.to_string());
            return;
        }

        println("[]");
    } else if command.check_type != nil {
        let check_type = command.check_type!;

        let input = file_read(check_type.input!);

        let compiler = Compiler::new();
        let result or err = compiler.check_type(check_type.input!, input, check_type.line, check_type.column);
        if err != nil {
            return;
        }

        if result != nil {
            println(result!);
        }
    } else if command.go_to_def != nil {
        let go_to_def = command.go_to_def!;

        let path_segments = go_to_def.input!.split(".").at(0).split("/");
        let path = Path::new(path_segments.at(path_segments.length - 2), path_segments.at(path_segments.length - 1));

        let input = file_read(go_to_def.input!);

        let compiler = Compiler::new();
        let result or err = compiler.go_to_def(input, path, go_to_def.line, go_to_def.column);
        if err != nil {
            println(err!.message);
            return;
        }

        if result != nil {
            let items = make[map[string, Json]]();
            items.insert(
                "file",
                Json {
                    t_string: format("{}/{}.qz", go_to_def.project!, result!.module_name),
                },
            );

            let start = make[map[string, Json]]();
            start.insert(
                "line",
                Json {
                    t_i32: result!.start.line,
                },
            );
            start.insert(
                "column",
                Json {
                    t_i32: result!.start.column,
                },
            );

            let end = make[map[string, Json]]();
            end.insert(
                "line",
                Json {
                    t_i32: result!.end.line,
                },
            );
            end.insert(
                "column",
                Json {
                    t_i32: result!.end.column,
                },
            );

            items.insert(
                "start",
                Json {
                    t_object: start,
                },
            );
            items.insert(
                "end",
                Json {
                    t_object: end,
                },
            );

            println(Json {
                t_object: items,
            }.to_string());
        }
    } else if command.completion != nil {
        let completion = command.completion!;

        let input = "";
        if completion.stdin {
            input = stdin();
        } else if completion.input != nil {
            input = file_read(completion.input!);
        } else {
            panic("no input");
        }

        let compiler = Compiler::new();
        let result or err = compiler.completion(
            input,
            Path::new("main"),
            completion.line,
            completion.column,
            completion.dot,
        );
        if err != nil {
            println(err!.message);
            return;
        }

        if result != nil {
            let items = make[vec[Json]]();
            for r in result! {
                let item = make[map[string, Json]]();
                item.insert(
                    "kind",
                    Json {
                        t_string: r.kind,
                    },
                );
                item.insert(
                    "label",
                    Json {
                        t_string: r.label,
                    },
                );
                item.insert(
                    "detail",
                    Json {
                        t_string: r.text,
                    },
                );

                items.push(Json {
                    t_object: item,
                });
            }

            let container = make[map[string, Json]]();
            container.insert(
                "items",
                Json {
                    t_array: items,
                },
            );

            println(Json {
                t_object: container,
            }.to_string());
        }
    } else {
        println("unknown args: {}", derive::to_string(args));
        println("{}", args.at(1));

        return nil;
    }

    return nil;
}

fun run(input_: string): string or error {
    let compiler = Compiler::new();
    return compiler.compile(input_, false).try;
}

fun run_format(input_: string): string or error {
    let lexer = Lexer::new();
    lexer.run(input_).try;

    let comments = make[vec[Token]]();
    for token in lexer.tokens {
        if token.lexeme.equal("comment") {
            comments.push(token);
        }
    }

    let parser = Parser::new();
    let module_ = parser.run(lexer.tokens, false).try;

    let formatter = Formatter::new(input_, comments, 0);

    return formatter.format(module_);
}

