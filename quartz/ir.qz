import quartz::ast;

struct IrTerm {
    t_nil: bool?,
    t_i32: i32?,
    t_ident: string?,
    t_func: IrFunc?,
    t_call: IrCall?,
    t_let: IrLet?,
    t_return: IrReturn?,
    t_module: struct {
        elements: vec[IrTerm],
    }?,
    t_global_let: struct {
        name: string,
        type_: IrType,
        value: IrTerm,
    }?,
    t_assign: struct {
        lhs: string,
        rhs: IrTerm,
    }?,
    t_if: struct {
        condition: IrTerm,
        then_term: IrTerm,
        else_term: IrTerm,
    }?,
    t_while: struct {
        condition: IrTerm,
        block: IrTerm,
        cleanup: IrTerm?,
    }?,
    t_seq: struct {
        terms: vec[IrTerm],
    }?,
    t_store: struct {
        type_: IrType,
        address: IrTerm,
        offset: IrTerm,
        value: IrTerm,
        raw_offset: i32,
    }?,
    t_load: struct {
        type_: IrType,
        address: IrTerm,
        offset: IrTerm,
        raw_offset: i32,
    }?,
    t_sizeof: struct {
        type_: IrType,
    }?,
    t_string: i32?,
    t_data: struct {
        data: string,
        offset: i32,
    }?,
    t_discard: IrTerm?,
    t_inst: string?,
    t_bool: bool?,
    t_and: struct {
        lhs: IrTerm,
        rhs: IrTerm,
    }?,
    t_or: struct {
        lhs: IrTerm,
        rhs: IrTerm,
    }?,
    t_continue: bool?,
    t_break: bool?,
    t_size: IrType?,
    t_u32: u32?,
}

module IrTerm {
    fun to_string(self): string {
        return derive::to_string_pretty(self);
    }

    fun ident(name: string): IrTerm {
        return IrTerm {
            t_ident: name?,
            ..nil,
        };
    }

    fun i32(value: i32): IrTerm {
        return IrTerm {
            t_i32: value?,
            ..nil,
        };
    }

    fun find_locals(self): vec[string] {
        let locals = make[vec[string]]();

        if self.t_let != nil {
            locals.push(self.t_let!.name);
            locals.extend(self.t_let!.value.find_locals());
        }
        if self.t_call != nil {
            locals.extend(self.t_call!.callee.find_locals());
            for arg in self.t_call!.args {
                locals.extend(arg.find_locals());
            }
        }
        if self.t_seq != nil {
            for term in self.t_seq!.terms {
                locals.extend(term.find_locals());
            }
        }
        if self.t_if != nil {
            locals.extend(self.t_if!.condition.find_locals());
            locals.extend(self.t_if!.then_term.find_locals());
            locals.extend(self.t_if!.else_term.find_locals());
        }
        if self.t_while != nil {
            locals.extend(self.t_while!.condition.find_locals());
            locals.extend(self.t_while!.block.find_locals());
            if self.t_while!.cleanup != nil {
                locals.extend(self.t_while!.cleanup!.find_locals());
            }
        }
        if self.t_store != nil {
            locals.extend(self.t_store!.address.find_locals());
            locals.extend(self.t_store!.offset.find_locals());
            locals.extend(self.t_store!.value.find_locals());
        }
        if self.t_load != nil {
            locals.extend(self.t_load!.address.find_locals());
            locals.extend(self.t_load!.offset.find_locals());
        }
        if self.t_assign != nil {
            locals.extend(self.t_assign!.rhs.find_locals());
        }
        if self.t_return != nil {
            locals.extend(self.t_return!.value.find_locals());
        }
        if self.t_assign != nil {
            locals.extend(self.t_assign!.rhs.find_locals());
        }
        if self.t_discard != nil {
            locals.extend(self.t_discard!.find_locals());
        }
        if self.t_and != nil {
            locals.extend(self.t_and!.lhs.find_locals());
            locals.extend(self.t_and!.rhs.find_locals());
        }
        if self.t_or != nil {
            locals.extend(self.t_or!.lhs.find_locals());
            locals.extend(self.t_or!.rhs.find_locals());
        }

        return locals;
    }
}

struct IrFunc {
    name: string,
    params: vec[struct {
        name: string,
        type_: IrType,
    }],
    body: vec[IrTerm],
    result_type: IrType,
}

struct IrCall {
    callee: IrTerm,
    args: vec[IrTerm],
}

struct IrLet {
    name: string,
    type_: IrType,
    value: IrTerm,
}

struct IrReturn {
    value: IrTerm,
}

struct IrType {
    t_nil: bool?,
    t_i32: bool?,
    t_address: bool?,
    t_byte: bool?,
    t_bool: bool?,
    t_any: bool?,
}

module IrType {
    fun new(t: Type): IrType {
        if t.t_nil != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_i32 != nil {
            return IrType {
                t_i32: true?,
                ..nil,
            };
        }
        if t.t_ident != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_byte != nil {
            return IrType {
                t_byte: true?,
                ..nil,
            };
        }
        if t.t_ptr != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_optional != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_bool != nil {
            return IrType {
                t_bool: true?,
                ..nil,
            };
        }
        if t.t_vec != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_or != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_any != nil {
            return IrType {
                t_any: true?,
                ..nil,
            };
        }
        if t.t_u32 != nil {
            return IrType {
                t_i32: true?,
                ..nil,
            };
        }
        if t.t_struct != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }
        if t.t_map != nil {
            return IrType {
                t_address: true?,
                ..nil,
            };
        }

        return panic("unknown type: {} (IrType::new)", t.to_string());
    }

    fun to_string(self): string {
        return derive::to_string(self);
    }

    fun is_nil(self): bool {
        return self.t_nil != nil;
    }

    fun sizeof(self): i32 {
        if self.t_byte != nil {
            return 1;
        } else {
            return 8;
        }
    }
}

