import quartz::ast;

type IrTerm = {
    t_nil: bool?,
    t_i32: string?,
    t_ident: string?,
    t_func: IrFunc?,
    t_call: IrCall?,
    t_let: IrLet?,
    t_return: IrReturn?,
    t_module: struct {
        elements: vec[IrTerm],
    }?,
    t_global_let: struct {
        name: string,
        type_: IrType,
        value: IrTerm,
    }?,
    t_assign: struct {
        lhs: string,
        rhs: IrTerm,
    }?,
    t_if: struct {
        condition: IrTerm,
        then_term: IrTerm,
        else_term: IrTerm,
    }?,
    t_while: struct {
        condition: IrTerm,
        block: IrTerm,
        cleanup: IrTerm?,
    }?,
    t_seq: struct {
        terms: vec[IrTerm],
    }?,
    t_store: struct {
        type_: IrType,
        address: IrTerm,
        offset: IrTerm,
        value: IrTerm,
    }?,
};

module IrTerm {
    fun to_string(self): string {
        if self.t_nil != nil {
            return "nil";
        }
        if self.t_i32 != nil {
            return self.t_i32!;
        }
        if self.t_ident != nil {
            return self.t_ident!;
        }
        if self.t_func != nil {
            let result = "func ".concat(self.t_func!.name).concat(" (");
            for i in 0..self.t_func!.params.length {
                let p = self.t_func!.params.at(i);
                result = result.concat(p.name).concat(": ").concat(p.type_.to_string());
                if i != self.t_func!.params.length - 1 {
                    result = result.concat(", ");
                }
            }
            result = result.concat(") -> ").concat(self.t_func!.result_type.to_string()).concat(" {");
            for i in 0..self.t_func!.body.length {
                let p = self.t_func!.body.at(i);
                result = result.concat(" ").concat(p.to_string());
            }
            result = result.concat(" }");

            return result;
        }
        if self.t_call != nil {
            let result = "".concat(self.t_call!.callee.to_string()).concat("(");
            for i in 0..self.t_call!.args.length {
                let p = self.t_call!.args.at(i);
                result = result.concat(p.to_string());
                if i != self.t_call!.args.length - 1 {
                    result = result.concat(", ");
                }
            }
            result = result.concat(")");

            return result;
        }
        if self.t_let != nil {
            return format(
                "(let ${} {})",
                self.t_let!.name,
                self.t_let!.value.to_string(),
            );
        }
        if self.t_return != nil {
            let result = "return ".concat(self.t_return!.value.to_string());

            return result;
        }
        if self.t_module != nil {
            let result = "module";
            for i in 0..self.t_module!.elements.length {
                let p = self.t_module!.elements.at(i);
                result = result.concat(" ").concat(p.to_string());
            }

            return result;
        }
    }

    fun ident(name: string): IrTerm {
        return IrTerm{
            t_ident: name?,
            ..nil,
        };
    }

    fun i32(value: i32): IrTerm {
        return IrTerm{
            t_i32: value.to_string()?,
            ..nil,
        };
    }
}

type IrFunc = {
    name: string,
    params: vec[struct {
        name: string,
        type_: IrType,
    }],
    body: vec[IrTerm],
    result_type: IrType,
    locals: vec[string],
};

type IrCall = {
    callee: IrTerm,
    args: vec[IrTerm],
};

type IrLet = {
    name: string,
    type_: IrType,
    value: IrTerm,
};

type IrReturn = {
    value: IrTerm,
};

type IrType = {
    t_nil: bool?,
    t_i32: bool?,
    t_address: bool?,
};

module IrType {
    fun new(t: Type): IrType {
        if t.t_nil != nil {
            return IrType{
                t_nil: true?,
                ..nil,
            };
        }
        if t.t_i32 != nil {
            return IrType{
                t_i32: true?,
                ..nil,
            };
        }

        panic("unknown type: {}", t.to_string());
    }

    fun to_string(self): string {
        if self.t_nil != nil {
            return "nil";
        }
        if self.t_i32 != nil {
            return "i32";
        }

        panic("unknown type");
    }

    fun is_nil(self): bool {
        return self.t_nil != nil;
    }

    fun sizeof(self): i32 {
        if self.t_nil != nil {
            return 4;
        }
        if self.t_i32 != nil {
            return 4;
        }
        if self.t_address != nil {
            return 4;
        }

        panic("unknown type");
    }
}
