import quartz::ast;
import quartz::ir;
import quartz::value;

let MODE_READABLE_WASM = true;

struct Generator {
    writer: string,
    depth: i32,
    index: i32,
    globals: map[string, Type],
}

module Generator {
    fun new(): Generator {
        return Generator {
            writer: "",
            depth: 0,
            index: 0,
            globals: make[map[string, Type]](),
        };
    }

    fun start(self) {
        self.new_statement();
        self.write("(");
        self.depth = self.depth + 1;
        self.index = 0;
    }

    fun end(self) {
        self.depth = self.depth - 1;
        self.index = 0;
        self.write(")");
    }

    fun write(self, str: string) {
        if self.index == 0 {
            self.writer = self.writer.concat(str);
        } else {
            self.writer = self.writer.concat(" ").concat(str);
        }
        self.index = self.index + 1;
    }

    fun new_statement(self) {
        if self.index > 0 {
            self.writer = self.writer.concat("\n").concat(" ".repeat(self.depth * 2));
        }
        self.index = 0;
    }

    fun set_globals(self, globals: map[string, Type]) {
        self.globals = globals;
    }

    fun generate(self): string {
        return self.writer;
    }

    fun run(self, m: IrTerm): string {
        self.start();
        self.write("module");

        if m.t_module != nil {
            for i in 0..m.t_module!.elements.length {
                let element = m.t_module!.elements.at(i);

                if element.t_func != nil {
                    self.function(element.t_func!);
                    continue;
                }
                if element.t_global_let != nil {
                    self.global_let(element.t_global_let!);
                    continue;
                }

                panic("expected function");
            }
        } else {
            panic("expected module");
        }

        self.start();
        self.write("global");
        self.write("$heap_ptr (mut i64) (i64.const 8)");
        self.end();

        self.start();
        self.write("memory 1");
        self.end();

        self.start();
        self.write(
            `func $alloc (param $size i64) (result i64)
    (local $p i64)

    global.get $heap_ptr
    local.set $p

    global.get $heap_ptr
    local.get $size
    i64.add
    global.set $heap_ptr

    local.get $p
`,
        );
        self.end();

        self.start();
        self.write("export \"main\" (func $main)");
        self.end();

        self.end();

        return self.generate();
    }

    fun global_let(
        self,
        global_let: struct {
            name: string,
            type_: IrType,
            value: IrTerm,
        },
    ) {
        self.start();
        self.write(format("global ${} (mut {})", global_let.name, global_let.type_.to_string()));
        self.start();
        self.expression(global_let.value);
        self.end();
        self.end();
    }

    fun function(self, func: IrFunc) {
        self.start();
        self.write("func");
        self.write("$".concat(func.name));

        for i in 0..func.params.length {
            let p = func.params.at(i);
            self.write("(param $".concat(p.name).concat(" ").concat(p.type_.to_string()).concat(")"));
        }

        if !func.result_type.is_nil() {
            self.write("(result i64)");
        }

        for statement in func.body {
            let locals = statement.find_locals();
            for local in locals {
                self.new_statement();
                self.start();
                self.write(format("local ${} {}", local, "i32"));
                self.end();
            }
        }

        for i in 0..func.body.length {
            self.expression(func.body.at(i));
        }

        self.end();
    }

    fun expression(self, expr: IrTerm) {
        if expr.t_ident != nil {
            if self.globals.has(expr.t_ident!) {
                self.write("global.get");
            } else {
                self.write("local.get");
            }
            self.write(format("${}", expr.t_ident!));
            return;
        }
        if expr.t_i32 != nil {
            if MODE_READABLE_WASM {
                self.new_statement();
                self.write(format(";; {}", expr.t_i32!.to_string()));
            }

            self.write_value(Value {
                t_i32: expr.t_i32!?,
                ..nil,
            });
            return;
        }
        if expr.t_let != nil {
            self.new_statement();
            self.expression(expr.t_let!.value);
            self.expression_left_value(IrTerm {
                t_ident: expr.t_let!.name?,
                ..nil,
            });
            return;
        }
        if expr.t_return != nil {
            self.new_statement();
            self.expression(expr.t_return!.value);

            self.new_statement();
            self.write("return");
            return;
        }
        if expr.t_call != nil {
            for i in 0..expr.t_call!.args.length {
                self.new_statement();
                self.expression(expr.t_call!.args.at(i));
            }

            self.new_statement();

            let callee = expr.t_call!.callee;
            if callee.t_ident != nil {
                let ident = callee.t_ident!;
                if ident.equal("add") {
                    self.write("i64.add");
                    return;
                }
                if ident.equal("sub") {
                    self.write("i64.sub");
                    return;
                }
                if ident.equal("mult") {
                    self.write("call $i32_mul");
                    return;
                }
                if ident.equal("equal") {
                    self.write("i64.eq");
                    return;
                }
                if ident.equal("lt") {
                    self.write("i64.lt_s");
                    return;
                }

                self.write("call $".concat(ident));
                return;
            } else {
                panic("not implemented: call");
            }

            return;
        }
        if expr.t_assign != nil {
            self.expression(expr.t_assign!.rhs);

            self.new_statement();
            if self.globals.has(expr.t_assign!.lhs) {
                self.write("global.set");
            } else {
                self.write("local.set");
            }
            self.write(format("${}", expr.t_assign!.lhs));

            return;
        }
        if expr.t_if != nil {
            self.new_statement();
            self.expression(expr.t_if!.condition);
            self.convert_stack_to_bool();

            self.start();
            self.write("if");

            self.start();
            self.write("then");
            self.expression(expr.t_if!.then_term);
            self.end();

            self.start();
            self.write("else");
            self.expression(expr.t_if!.else_term);
            self.end();

            self.end();

            return;
        }
        if expr.t_seq != nil {
            for i in 0..expr.t_seq!.terms.length {
                self.expression(expr.t_seq!.terms.at(i));
            }
            return;
        }
        if expr.t_while != nil {
            // [while(cond) {block, cleanup}]

            // (block $exit
            //     (loop $loop
            //         (block $continue
            //             (br_if $exit (i32.eqz (cond)))
            //             ($body)
            //         )

            //         ($cleanup)
            //         (br $loop)
            //     )
            // )

            self.new_statement();
            self.start();
            self.write("block");
            self.write("$exit");

            self.start();
            self.write("loop");
            self.write("$loop");

            self.start();
            self.write("block");
            self.write("$continue");

            self.expression(expr.t_while!.condition);
            self.convert_stack_to_bool();

            self.new_statement();
            self.write("i32.eqz");
            self.new_statement();
            self.write("br_if $exit");

            self.expression(expr.t_while!.block);
            self.end();

            if expr.t_while!.cleanup != nil {
                self.expression(expr.t_while!.cleanup!);
            }

            self.new_statement();
            self.write("br $loop");

            self.end();
            self.end();

            return;
        }
        if expr.t_load != nil {
            self.new_statement();
            self.expression(expr.t_load!.address);

            self.new_statement();
            self.expression(expr.t_load!.offset);

            self.convert_stack_to_i32_2();

            self.new_statement();
            self.write("i32.add");

            let load_size = expr.t_load!.type_.sizeof() * 8;
            let suffix = "";
            if load_size != 64 {
                suffix = format("{}_u", load_size.to_string());
            }

            self.new_statement();
            self.write(format("{}.load{}", Value::wasm_type(), suffix));
            self.write("offset=8");

            if expr.t_load!.type_.t_byte != nil {
                self.new_statement();
                self.write("i64.const 32");

                self.new_statement();
                self.write("i64.shl");

                self.new_statement();
                self.write("i64.const 4");

                self.new_statement();
                self.write("i64.xor");
            }

            return;
        }
        if expr.t_store != nil {
            self.new_statement();
            self.expression(expr.t_store!.address);

            self.new_statement();
            self.expression(expr.t_store!.offset);

            self.convert_stack_to_i32_2();

            self.new_statement();
            self.write("i32.add");

            self.new_statement();
            self.expression(expr.t_store!.value);

            let store_size = expr.t_store!.type_.sizeof() * 8;

            if store_size != 64 {
                self.new_statement();
                self.write(format("i64.const 32"));

                self.new_statement();
                self.write(format("i64.shr_u"));
            }

            let suffix = "";
            if store_size != 64 {
                suffix = format("{}", store_size.to_string());
            }

            self.new_statement();
            self.write(format("i64.store{}", suffix));
            self.write("offset=8");

            return;
        }
        if expr.t_sizeof != nil {
            let size = expr.t_sizeof!.type_.sizeof();

            self.new_statement();
            self.write(format(";; {} (sizeof)", size.to_string()));

            self.new_statement();
            self.write_value(Value {
                t_i32: size?,
                ..nil,
            });

            return;
        }

        panic("not implemented: expr, {}", expr.to_string());
    }

    fun expression_left_value(self, expr: IrTerm) {
        if expr.t_ident != nil {
            self.new_statement();
            if self.globals.has(expr.t_ident!) {
                self.write("global.set");
            } else {
                self.write("local.set");
            }
            self.write(format("${}", expr.t_ident!));
            return;
        }

        panic("not implemented: expr_lhs");
    }

    fun write_value(self, value: Value) {
        self.new_statement();
        self.write(format("{}.const {}", Value::wasm_type(), value.as_i64().to_string()));
    }

    fun convert_stack_to_i32_2(self) {
        self.new_statement();
        self.write("global.set $_value_i32_1");

        self.convert_stack_to_i32_1();

        self.new_statement();
        self.write("global.get $_value_i32_1");

        self.convert_stack_to_i32_1();
    }

    fun convert_stack_to_i32_1(self) {
        self.new_statement();
        self.write("global.set $_value_i32_0");

        self.new_statement();
        self.write("global.get $_value_i32_0");

        self.new_statement();
        self.write("i64.extend_i32_u");
    }

    fun convert_stack_from_i32_1(self) {
        self.new_statement();
        self.write("i64.extend_i32_s");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");
    }

    fun convert_stack_from_bool_1(self) {
        self.new_statement();
        self.write("i64.extend_i32_s");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");

        self.new_statement();
        self.write("i64.const 2");

        self.new_statement();
        self.write("i64.or");
    }

    fun convert_stack_to_bool(self) {
        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shr_u");

        self.new_statement();
        self.write("i64.const 1");

        self.new_statement();
        self.write("i64.and");

        self.new_statement();
        self.write("i32.wrap_i64");
    }

    fun generate_op_arithmetic(self, code: string) {
        self.convert_stack_to_i32_2();
        self.write(format("i32.{}", code));
        self.convert_stack_from_i32_1();
    }

    fun generate_op_comparison(self, code: string) {
        self.convert_stack_to_i32_2();
        self.write(format("i32.{}", code));
        self.convert_stack_from_bool_1();
    }
}

