import quartz::ast;
import quartz::ir;
import quartz::value;
import quartz::path;
import quartz::ir_code_gen;

let MODE_READABLE_WASM = true;

fun escape(s: string): string {
    let result = make[vec[byte]]();
    let n = 0;

    result.push(34 as byte);

    while n < s.length {
        if s.at(n) == 10 as byte {
            result.push(92 as byte);
            result.push(110 as byte);
            n = n + 1;
        } else if is_prefix(s, n, "\"") {
            result.push(92 as byte);
            result.push(34 as byte);
            n = n + 1;
        } else if s.at(n) == 0 as byte {
            result.push(92 as byte);
            result.push(48 as byte);
            n = n + 1;
        } else if s.at(n) == 92 as byte {
            result.push(92 as byte);
            result.push(92 as byte);
            n = n + 1;
        } else {
            result.push(s.at(n) as byte);
            n = n + 1;
        }
    }

    result.push(34 as byte);

    return vec_byte_to_string(result);
}

struct Generator {
    writer: stringbuilder,
    depth: i32,
    index: i32,
    globals: map[string, LType],
    strings: vec[string],
    type_reps: vec[InternalTypeRep],
    main_signature_result: IrType?,
    start_terms: vec[IrTerm],
    current_function_name: string,
    mode_validate_address: bool,
}

module Generator {
    fun new(validate_address: bool): Generator {
        return Generator {
            writer: stringbuilder::new(),
            depth: 0,
            index: 0,
            globals: make[map[string, LType]](),
            strings: make[vec[string]](),
            type_reps: make[vec[InternalTypeRep]](),
            main_signature_result: nil as IrType?,
            start_terms: make[vec[IrTerm]](),
            current_function_name: "",
            mode_validate_address: validate_address,
        };
    }

    fun start(self) {
        self.new_statement();
        self.write("(");
        self.depth = self.depth + 1;
        self.index = 0;
    }

    fun end(self) {
        self.depth = self.depth - 1;
        self.index = 0;
        self.write(")");
    }

    fun write(self, str: string) {
        if self.index == 0 {
            self.writer.append(str);
        } else {
            self.writer.append(" ");
            self.writer.append(str);
        }
        self.index = self.index + 1;
    }

    fun new_statement(self) {
        if self.index > 0 {
            self.writer.append("\n");
            self.writer.append(" ".repeat(self.depth * 4));
        }
        self.index = 0;
    }

    fun set_globals(self, globals: map[string, LType]) {
        self.globals = globals;
    }

    fun set_strings(self, strings: vec[string]) {
        self.strings = strings;
    }

    fun set_type_reps(self, type_reps: vec[InternalTypeRep]) {
        self.type_reps = type_reps;
    }

    fun set_start_terms(self, start: vec[IrTerm]) {
        self.start_terms = start;
    }

    fun generate(self): string {
        return self.writer.to_string();
    }

    fun decl(self, element: IrTerm) {
        if element.t_func != nil {
            self.function(element.t_func!);
        } else if element.t_global_let != nil {
            self.global_let(element.t_global_let!);
        } else if element.t_module != nil {
            for i in 0..element.t_module!.elements.length {
                self.decl(element.t_module!.elements.at(i));
            }
        } else if element.t_data != nil {
            self.start();
            self.write("data");
            self.write(format("(i32.const {})", element.t_data!.offset.to_string()));

            self.write(escape(element.t_data!.data));
            self.end();
        } else if element.t_comment != nil {
            self.new_statement();
            self.write(format(" ;; {}", escape(element.t_comment!)));
        } else {
            panic("decl: {}", element.to_string());
        }
    }

    fun run(self, m: IrTerm, entrypoint: string, data_section_offset: i32): string {
        self.start();
        self.write("module");

        self.start();
        self.write(`import "env" "debug" (func $debug (param i64) (result i64))`);
        self.end();

        self.start();
        self.write(`import "env" "abort" (func $abort (result i64))`);
        self.end();

        self.start();
        self.write(
            `import "env" "i64_to_string_at" (func $i64_to_string_at (param i64) (param i64) (param i64) (result i64))`,
        );
        self.end();

        self.start();
        self.write(`import "env" "get_args_len" (func $get_args_len (result i64))`);
        self.end();

        self.start();
        self.write(`import "env" "get_args_at" (func $get_args_at (param i64) (result i64))`);
        self.end();

        self.start();
        self.write(`import "wasi_unstable" "fd_write" (func $fd_write (param i32 i32 i32 i32) (result i32))`);
        self.end();

        self.start();
        self.write(
            `import "wasi_unstable" "path_open" (func $path_open (param i32 i32 i32 i32 i32 i64 i64 i32 i32) (result i32))`,
        );
        self.end();

        self.start();
        self.write(`import "wasi_unstable" "fd_close" (func $fd_close (param i32) (result i32))`);
        self.end();

        self.start();
        self.write(`import "wasi_unstable" "fd_read" (func $fd_read (param i32 i32 i32 i32) (result i32))`);
        self.end();

        self.start();
        self.write(
            `import "wasi_unstable" "fd_filestat_get" (func $fd_filestat_get (param i32 i32) (result i32))`,
        );
        self.end();

        self.start();
        self.write(
            `func $_fd_read (param $fd i64) (param $iovs i64) (param $iovs_len i64) (param $nread i64) (result i64)
    local.get $fd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $iovs
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $iovs_len
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $nread
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    call $fd_read
    i64.extend_i32_u
    i64.const 32
    i64.shl

    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $_fd_filestat_get (param $fd i64) (param $buf i64) (result i64)
    local.get $fd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $buf
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    call $fd_filestat_get
    i64.extend_i32_u
    i64.const 32
    i64.shl

    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $_fd_write (param $fd i64) (param $ciovec i64) (param $ptr_size i64) (result i64)
    local.get $fd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $ciovec
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    i32.const 1

    local.get $ptr_size
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    call $fd_write
    i64.extend_i32_u
    i64.const 32
    i64.shl

    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $set_ciovec (param $ptr i64) (param $x i64) (param $y i64) (result i64)
    local.get $ptr
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $x
    i64.const 32
    i64.shr_u
    i32.wrap_i64
    i32.store

    local.get $ptr
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $y
    i64.const 32
    i64.shr_u
    i32.wrap_i64
    i32.store offset=4

    i64.const 1
    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $_path_open
    (param $dirfd i64)
    (param $dirflags i64)
    (param $path i64)
    (param $path_len i64)
    (param $o_flags i64)
    (param $fs_rights_base i64)
    (param $fs_rights_inheriting i64)
    (param $fs_flags i64)
    (param $fd i64)
    (result i64)

    local.get $dirfd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $dirflags
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $path
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $path_len
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $o_flags
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $fs_rights_base
    i64.const 32
    i64.shr_u
    i32.wrap_i64
    i64.extend_i32_s

    local.get $fs_rights_inheriting
    i64.const 32
    i64.shr_u
    i32.wrap_i64
    i64.extend_i32_s

    local.get $fs_flags
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    local.get $fd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    call $path_open

    i64.extend_i32_s
    i64.const 32
    i64.shl

    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $_fd_close (param $fd i64) (result i64)
    local.get $fd
    i64.const 32
    i64.shr_u
    i32.wrap_i64

    call $fd_close
    i64.extend_i32_s
    i64.const 32
    i64.shl

    return
`,
        );
        self.end();

        if m.t_module != nil {
            for i in 0..m.t_module!.elements.length {
                let element = m.t_module!.elements.at(i);

                self.decl(element);
            }
        } else {
            panic("expected module");
        }

        self.global_let(struct {
            name: "_value_i32_1",
            type_: IrType {
                t_i32: true,
            },
            value: IrTerm {
                t_i32: 0,
            },
        });

        self.global_let(struct {
            name: "_value_i64_1",
            type_: IrType {
                t_address: true,
            },
            value: IrTerm {
                t_i32: 0,
            },
        });

        self.global_let(struct {
            name: "_raw_i64_1",
            type_: IrType {
                t_address: true,
            },
            value: IrTerm {
                t_i32: 0,
            },
        });

        self.global_let(struct {
            name: "_raw_i64_2",
            type_: IrType {
                t_address: true,
            },
            value: IrTerm {
                t_i32: 0,
            },
        });

        self.start();
        self.write("memory (export \"memory\") 50000");
        self.end();

        self.start();
        self.write(
            `func $_reflection_is_pointer (param $value i64) (result i64)
    local.get $value
    i64.const 1
    i64.and
    i64.const 32
    i64.shl
    i64.const 2
    i64.or
    return
`,
        );
        self.end();

        self.start();
        self.write(
            `func $_reflection_is_bool (param $value i64) (result i64)
    local.get $value
    i64.const 2
    i64.and
    i64.const 31
    i64.shl
    i64.const 2
    i64.or
    return
`,
        );
        self.end();

        self.start();
        self.write(`func $i32_mul (param $a i64) (param $b i64) (result i64)`);

        self.new_statement();
        self.write("local.get $a");

        self.new_statement();
        self.write("local.get $b");

        self.convert_stack_to_i32_2();

        self.new_statement();
        self.write("i32.mul");

        self.convert_stack_from_i32_1();
        self.end();

        if self.main_signature_result == nil {
            panic("main_signature_result is nil");
        }

        let start_body = make[vec[IrTerm]](
            IrTerm {
                t_assign: struct {
                    lhs: "quartz_std_alloc_ptr",
                    rhs: IrTerm {
                        t_i32: data_section_offset,
                    },
                },
            },
            IrTerm {
                t_assign: struct {
                    lhs: "quartz_std_strings_count",
                    rhs: IrTerm {
                        t_i32: self.strings.length,
                    },
                },
            },
            IrTerm {
                t_assign: struct {
                    lhs: "quartz_std_type_reps_count",
                    rhs: IrTerm {
                        t_i32: self.type_reps.length,
                    },
                },
            },
        );
        start_body.extend(self.start_terms);
        start_body.extend(make[vec[IrTerm]](
            IrTerm {
                t_call: IrCall {
                    callee: IrTerm {
                        t_ident: "prepare_strings",
                    },
                    args: make[vec[IrTerm]](),
                },
            },
            IrTerm {
                t_call: IrCall {
                    callee: IrTerm {
                        t_ident: "prepare_type_reps",
                    },
                    args: make[vec[IrTerm]](),
                },
            },
            IrTerm {
                t_return: IrReturn {
                    value: IrTerm {
                        t_inst: "call $main_{}".format(entrypoint),
                    },
                },
            },
        ));

        self.function(IrFunc {
            name: "start",
            params: make[vec[struct {
                name: string,
                type_: IrType,
            }]](),
            result_type: self.main_signature_result!,
            body: start_body,
        });

        self.start();
        self.write("export \"main\" (func $start)");
        self.end();

        self.end();

        return self.generate();
    }

    fun global_let(
        self,
        global_let: struct {
            name: string,
            type_: IrType,
            value: IrTerm,
        },
    ) {
        self.start();
        self.write(format("global ${} (mut {})", global_let.name, "i64"));
        self.start();
        let value = global_let.value;
        if value.t_i32 != nil {
            self.write_value(Value {
                t_i32: value.t_i32!,
            });
        } else if value.t_nil != nil {
            self.write_value(Value::nil_());
        } else if value.t_u32 != nil {
            self.write_value(Value {
                t_u32: value.t_u32!,
            });
        } else if value.t_bool != nil {
            self.write_value(Value {
                t_bool: value.t_bool!,
            });
        } else {
            panic("global expected an immediate value, but got {}", value.to_string());
        }
        self.end();
        self.end();
    }

    fun function(self, func: IrFunc) {
        if func.name.equal("main_main") {
            self.main_signature_result = func.result_type?;
        }

        self.start();
        self.write("func");
        self.write("$".concat(func.name));

        for i in 0..func.params.length {
            let p = func.params.at(i);
            self.write("(param $".concat(p.name).concat(" ").concat("i64").concat(")"));
        }

        if !func.result_type.is_nil() {
            self.write("(result i64)");
        }

        let visited = make[map[string, bool]]();
        for statement in func.body {
            let locals = statement.find_locals();
            for local in locals {
                if visited.has(local) {
                    continue;
                }

                self.new_statement();
                self.start();
                self.write(format("local ${} {}", local, "i64"));
                self.end();

                visited.insert(local, true);
            }
        }

        self.current_function_name = func.name;

        // Avoid infinite loop
        if !func.name.starts_with("quartz_std_") {
            self.expression(IrTerm {
                t_discard: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_prologue",
                        },
                        args: make[vec[IrTerm]](),
                    },
                },
            });
        }

        for b in func.body {
            self.expression(b);
        }

        // When the last instruction is exhaustive if block, we still need to put soemthing to tell the compiler that the function forgets to return
        if func.result_type.t_address == nil {
            self.new_statement();
            self.write("unreachable");
        } else {
            self.expression(IrTerm {
                t_return: IrReturn {
                    value: IrTerm {
                        t_nil: true,
                    },
                },
            });
        }

        self.end();
    }

    fun expression(self, expr: IrTerm) {
        if expr.t_ident != nil {
            self.new_statement();
            if self.globals.has(expr.t_ident!) {
                self.write("global.get");
            } else {
                self.write("local.get");
            }
            self.write(format("${}", expr.t_ident!));
        } else if expr.t_i32 != nil {
            if MODE_READABLE_WASM {
                self.new_statement();
                self.write(format(" ;; {}", expr.t_i32!.to_string()));
            }

            self.write_value(Value {
                t_i32: expr.t_i32!,
            });
        } else if expr.t_u32 != nil {
            if MODE_READABLE_WASM {
                self.new_statement();
                self.write(format(" ;; {}", expr.t_u32!.to_string()));
            }

            // FIXME: i64::to_string is broken!
            self.new_statement();
            self.write(format("{}.const {}", Value::wasm_type(), expr.t_u32!.to_string()));
        } else if expr.t_nil != nil {
            if MODE_READABLE_WASM {
                self.new_statement();
                self.write(" ;; nil");
            }

            self.write_value(Value::nil_());
        } else if expr.t_let != nil {
            self.new_statement();
            self.expression(expr.t_let!.value);
            self.expression_left_value(IrTerm {
                t_ident: expr.t_let!.name,
            });

            // push to stack
            if expr.t_let!.type_.t_address != nil {
                self.new_statement();
                self.expression(IrTerm {
                    t_ident: expr.t_let!.name,
                });

                self.new_statement();
                self.write("call $quartz_std_push_memstack");

                self.new_statement();
                self.write("drop");
            }
        } else if expr.t_return != nil {
            // Avoid infinite loop
            if !self.current_function_name.starts_with("quartz_std_") {
                self.expression(IrTerm {
                    t_discard: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_epilogue",
                            },
                            args: make[vec[IrTerm]](),
                        },
                    },
                });
            }

            self.new_statement();
            self.expression(expr.t_return!.value);

            self.new_statement();
            self.write("return");
        } else if expr.t_call != nil {
            for i in 0..expr.t_call!.args.length {
                self.new_statement();
                self.expression(expr.t_call!.args.at(i));
            }

            self.new_statement();

            let callee = expr.t_call!.callee;
            if callee.t_ident != nil {
                let ident = callee.t_ident!;
                if ident.equal("add") {
                    self.write("i64.add");
                } else if ident.equal("sub") {
                    self.write("i64.sub");
                } else if ident.equal("mult") {
                    self.write("call $i32_mul");
                } else if ident.equal("div") {
                    self.generate_op_arithmetic("div_s");
                } else if ident.equal("div_u32") {
                    self.generate_op_arithmetic("div_u");
                } else if ident.equal("div_i64") {
                    self.generate_op_arithmetic_i64("i64.div_s");
                } else if ident.equal("mod") {
                    self.generate_op_arithmetic("rem_s");
                } else if ident.equal("mod_u32") {
                    self.generate_op_arithmetic("rem_u");
                } else if ident.equal("equal") {
                    self.write("i64.eq");
                    self.convert_stack_from_bool_1();
                } else if ident.equal("not_equal") {
                    self.generate_op_comparison("ne");
                } else if ident.equal("not") {
                    self.convert_stack_to_bool();
                    self.write("i32.eqz");
                    self.convert_stack_from_bool_1();
                } else if ident.equal("lt") {
                    self.generate_op_comparison("lt_s");
                } else if ident.equal("gt") {
                    self.generate_op_comparison("gt_s");
                } else if ident.equal("gt_u32") {
                    self.generate_op_comparison("gt_u");
                } else if ident.equal("lte") {
                    self.generate_op_comparison("le_s");
                } else if ident.equal("lte_u32") {
                    self.generate_op_comparison("le_u");
                } else if ident.equal("gte") {
                    self.generate_op_comparison("ge_s");
                } else if ident.equal("gte_u32") {
                    self.generate_op_comparison("ge_u");
                } else if ident.equal("i32_to_address") {
                    self.convert_value_i32_to_address_1();
                } else if ident.equal("address_to_i32") {
                    self.convert_value_address_to_i32_1();
                } else if ident.equal("i32_to_byte") {
                    self.convert_value_i32_to_byte_1();
                } else if ident.equal("byte_to_i32") {
                    self.convert_value_byte_to_i32_1();
                } else if ident.equal("xor") || ident.equal("xor_u32") {
                    self.generate_op_arithmetic("xor");
                } else if ident.equal("bit_and") || ident.equal("bit_and_u32") {
                    self.generate_op_arithmetic("and");
                } else if ident.equal("bit_or") || ident.equal("bit_or_u32") {
                    self.generate_op_arithmetic("or");
                } else if ident.equal("bit_or_i64") {
                    self.generate_op_arithmetic_i64("i64.or");
                } else if ident.equal("bit_shift_left") {
                    self.generate_op_arithmetic("shl");
                } else if ident.equal("bit_shift_left_u32") {
                    self.generate_op_arithmetic("shl");
                } else if ident.equal("bit_shift_left_i64") {
                    self.generate_op_arithmetic_i64("i64.shl");
                } else if ident.equal("bit_shift_right") {
                    self.generate_op_arithmetic("shr_s");
                } else if ident.equal("bit_shift_right_i64") {
                    self.generate_op_arithmetic_i64("i64.shr_s");
                } else {
                    self.write("call $".concat(ident));
                }
            } else {
                panic("not implemented: call");
            }
        } else if expr.t_assign != nil {
            self.expression(expr.t_assign!.rhs);

            self.new_statement();
            if self.globals.has(expr.t_assign!.lhs) {
                self.write("global.set");
            } else {
                self.write("local.set");
            }
            self.write(format("${}", expr.t_assign!.lhs));
        } else if expr.t_if != nil {
            self.new_statement();
            self.expression(expr.t_if!.condition);
            self.convert_stack_to_bool();

            self.start();
            self.write("if");

            self.start();
            self.write("then");
            self.expression(expr.t_if!.then_term);
            self.end();

            self.start();
            self.write("else");
            self.expression(expr.t_if!.else_term);
            self.end();

            self.end();
        } else if expr.t_seq != nil {
            for i in 0..expr.t_seq!.terms.length {
                self.expression(expr.t_seq!.terms.at(i));
            }
        } else if expr.t_while != nil {
            // [while(cond) {block, cleanup}]

            // (block $exit
            //     (loop $loop
            //         (block $continue
            //             (br_if $exit (i32.eqz (cond)))
            //             ($body)
            //         )

            //         ($cleanup)
            //         (br $loop)
            //     )
            // )

            self.new_statement();
            self.start();
            self.write("block");
            self.write("$exit");

            self.start();
            self.write("loop");
            self.write("$loop");

            self.start();
            self.write("block");
            self.write("$continue");

            self.expression(expr.t_while!.condition);
            self.convert_stack_to_bool();

            self.new_statement();
            self.write("i32.eqz");
            self.new_statement();
            self.write("br_if $exit");

            self.expression(expr.t_while!.block);
            self.end();

            if expr.t_while!.cleanup != nil {
                self.expression(expr.t_while!.cleanup!);
            }

            self.new_statement();
            self.write("br $loop");

            self.end();
            self.end();
        } else if expr.t_load != nil {
            self.new_statement();
            self.expression(expr.t_load!.address);

            self.convert_stack_to_i32_1();

            if expr.t_load!.offset.t_i32 != nil && expr.t_load!.offset.t_i32! == 0 {
                // do nothing
            } else {
                self.optimize_i32(expr.t_load!.offset);

                self.new_statement();
                self.write("i32.add");
            }

            let load_size = expr.t_load!.type_.sizeof() * 8;
            let suffix = "";
            if load_size != 64 {
                suffix = format("{}_u", load_size.to_string());
            }

            if self.mode_validate_address && !self.current_function_name.starts_with("quartz_std_") {
                self.new_statement();
                self.write("i64.extend_i32_u");

                self.new_statement();
                self.write("global.set $_value_i32_1");

                self.new_statement();
                self.write("global.get $_value_i32_1");

                self.new_statement();
                self.write("i64.const 32");

                self.new_statement();
                self.write("i64.shl");

                self.new_statement();
                self.write("call $quartz_std_validate_address");

                self.new_statement();
                self.write("drop");

                self.new_statement();
                self.write("global.get $_value_i32_1");

                self.new_statement();
                self.write("i32.wrap_i64");
            }

            self.new_statement();
            self.write(format("{}.load{}", Value::wasm_type(), suffix));
            if expr.t_load!.raw_offset != 0 {
                self.write("offset={}".format(expr.t_load!.raw_offset.to_string()));
            }

            if expr.t_load!.type_.t_byte != nil {
                self.new_statement();
                self.write("i64.const 32");

                self.new_statement();
                self.write("i64.shl");

                self.new_statement();
                self.write("i64.const 4");

                self.new_statement();
                self.write("i64.xor");
            }
        } else if expr.t_store != nil {
            self.new_statement();
            self.expression(expr.t_store!.address);

            self.convert_stack_to_i32_1();

            if expr.t_store!.offset.t_i32 != nil && expr.t_store!.offset.t_i32! == 0 {
                // do nothing
            } else {
                self.optimize_i32(expr.t_store!.offset);

                self.new_statement();
                self.write("i32.add");
            }

            self.new_statement();
            self.expression(expr.t_store!.value);

            let store_size = expr.t_store!.type_.sizeof() * 8;

            if store_size != 64 {
                self.new_statement();
                self.write(format("i64.const 32"));

                self.new_statement();
                self.write(format("i64.shr_u"));
            }

            let suffix = "";
            if store_size != 64 {
                suffix = format("{}", store_size.to_string());
            }

            self.new_statement();
            self.write(format("i64.store{}", suffix));
            if expr.t_store!.raw_offset != 0 {
                self.write("offset={}".format(expr.t_store!.raw_offset.to_string()));
            }
        } else if expr.t_sizeof != nil {
            let size = expr.t_sizeof!.type_.sizeof();

            self.new_statement();
            self.write(format(" ;; {} (sizeof)", size.to_string()));

            self.new_statement();
            self.write_value(Value {
                t_i32: size,
            });
        } else if expr.t_string != nil {
            self.new_statement();
            self.write(format(";; string: {}", escape(self.strings.at(expr.t_string!))));

            self.new_statement();
            self.write(format("i32.const {}", expr.t_string!.to_string()));

            self.convert_stack_from_i32_1();

            self.new_statement();
            self.write("call $quartz_std_load_string");
        } else if expr.t_type_rep != nil {
            self.new_statement();
            self.write(format(";; type_rep: {}", derive::to_string(expr.t_type_rep!)));

            self.new_statement();
            self.write(format("i32.const {}", expr.t_type_rep!.to_string()));

            self.convert_stack_from_i32_1();

            self.new_statement();
            self.write("call $quartz_std_get_type_rep_address");
        } else if expr.t_discard != nil {
            self.new_statement();
            self.expression(expr.t_discard!);

            self.new_statement();
            self.write("drop");
        } else if expr.t_inst != nil {
            self.new_statement();
            self.write(expr.t_inst!);
        } else if expr.t_bool != nil {
            if MODE_READABLE_WASM {
                self.new_statement();
                self.write(format(" ;; {}", expr.t_bool!.to_string()));
            }

            self.new_statement();
            self.write_value(Value {
                t_bool: expr.t_bool!,
            });
        } else if expr.t_and != nil {
            self.generate_if(
                IrType {
                    t_bool: true,
                }?,
                expr.t_and!.lhs,
                expr.t_and!.rhs,
                IrTerm {
                    t_bool: false,
                },
            );
        } else if expr.t_or != nil {
            self.generate_if(
                IrType {
                    t_bool: true,
                }?,
                expr.t_or!.lhs,
                IrTerm {
                    t_bool: true,
                },
                expr.t_or!.rhs,
            );
        } else if expr.t_sizeof != nil {
            let size = expr.t_sizeof!.type_.sizeof();

            self.new_statement();
            self.write(format(" ;; {} (sizeof)", size.to_string()));

            self.new_statement();
            self.write_value(Value {
                t_i32: size,
            });
        } else if expr.t_continue != nil {
            self.new_statement();
            self.write("br $continue");
        } else if expr.t_break != nil {
            self.new_statement();
            self.write("br $exit");
        } else if expr.t_comment != nil {
            self.new_statement();
            self.write(format(" ;; {}", escape(expr.t_comment!)));
        } else {
            panic("not implemented: expr, {}", expr.to_string());
        }
    }

    fun expression_left_value(self, expr: IrTerm) {
        if expr.t_ident != nil {
            self.new_statement();
            if self.globals.has(expr.t_ident!) {
                self.write("global.set");
            } else {
                self.write("local.set");
            }
            self.write(format("${}", expr.t_ident!));
            return;
        }

        panic("not implemented: expr_lhs");
    }

    fun write_value(self, value: Value) {
        self.new_statement();
        self.write(format("{}.const {}", Value::wasm_type(), value.as_i64().to_string()));
    }

    fun convert_stack_to_i32_2(self) {
        self.new_statement();
        self.write("global.set $_value_i32_1");

        self.convert_stack_to_i32_1();

        self.new_statement();
        self.write("global.get $_value_i32_1");

        self.convert_stack_to_i32_1();
    }

    fun convert_stack_to_i32_1(self) {
        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shr_u");

        self.new_statement();
        self.write("i32.wrap_i64");
    }

    fun convert_stack_from_i32_1(self) {
        self.new_statement();
        self.write("i64.extend_i32_s");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");
    }

    fun convert_stack_from_bool_1(self) {
        self.new_statement();
        self.write("i64.extend_i32_s");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");

        self.new_statement();
        self.write("i64.const 2");

        self.new_statement();
        self.write("i64.or");
    }

    fun convert_stack_to_bool(self) {
        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shr_u");

        self.new_statement();
        self.write("i64.const 1");

        self.new_statement();
        self.write("i64.and");

        self.new_statement();
        self.write("i32.wrap_i64");
    }

    // FIXME: need GC lock
    // For GC locks, keep value n, which is the number of values to lock (not a standard value)
    fun load_i64(self) {
        self.new_statement();
        self.write("global.set $_value_i64_1");

        self.new_statement();
        self.write("global.get $_value_i64_1");

        self.convert_stack_to_i32_1();

        // load hi address
        self.new_statement();
        self.write("i64.load offset=8");

        // load lo address
        self.new_statement();
        self.write("global.get $_value_i64_1");

        self.convert_stack_to_i32_1();

        self.new_statement();
        self.write("i64.load offset=16");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shr_u");

        self.new_statement();
        self.write("i64.add");
    }

    fun generate_op_arithmetic(self, code: string) {
        self.convert_stack_to_i32_2();
        self.write(format("i32.{}", code));
        self.convert_stack_from_i32_1();
    }

    fun generate_op_arithmetic_i64(self, op: string) {
        self.load_i64();

        self.new_statement();
        self.write("global.set $_raw_i64_1");

        self.load_i64();

        self.new_statement();
        self.write("global.get $_raw_i64_1");

        self.new_statement();
        self.write(op);

        self.new_statement();
        self.write("global.set $_raw_i64_1");

        // prepare hi
        self.new_statement();
        self.write("global.get $_raw_i64_1");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shr_u");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");

        // prepare lo
        self.new_statement();
        self.write("global.get $_raw_i64_1");

        self.new_statement();
        self.write("i64.const 32");

        self.new_statement();
        self.write("i64.shl");

        self.new_statement();
        self.write("call $quartz_std_i64_new");
    }

    fun generate_op_comparison(self, code: string) {
        self.convert_stack_to_i32_2();
        self.write(format("i32.{}", code));
        self.convert_stack_from_bool_1();
    }

    fun convert_value_i32_to_address_1(self) {
        self.new_statement();
        self.write("i64.const 1");

        self.new_statement();
        self.write("i64.xor");
    }

    fun convert_value_address_to_i32_1(self) {
        self.new_statement();
        self.write("i64.const 1");

        self.new_statement();
        self.write("i64.xor");
    }

    fun convert_value_i32_to_byte_1(self) {
        self.new_statement();
        self.write("i64.const 4");

        self.new_statement();
        self.write("i64.xor");
    }

    fun convert_value_byte_to_i32_1(self) {
        self.new_statement();
        self.write("i64.const 4");

        self.new_statement();
        self.write("i64.xor");
    }

    fun generate_if(self, type_: IrType?, cond: IrTerm, then: IrTerm, else_: IrTerm) {
        self.new_statement();
        self.expression(cond);
        self.convert_stack_to_bool();

        self.start();
        if type_ != nil {
            self.write(format("if (result {})", "i64"));
        } else {
            self.write("if");
        }

        self.start();
        self.write("then");
        self.expression(then);
        self.end();

        self.start();
        self.write("else");
        self.expression(else_);
        self.end();

        self.end();
    }

    fun fold_consts(self, term: IrTerm): IrTerm {
        if term.t_module != nil {
            let elements = make[vec[IrTerm]]();
            for i in 0..term.t_module!.elements.length {
                let element = term.t_module!.elements.at(i);
                let t = self.fold_consts(element);

                elements.push(t);
            }

            term.t_module!.elements = elements;
        } else if term.t_func != nil {
            let body = make[vec[IrTerm]]();
            for i in 0..term.t_func!.body.length {
                let b = term.t_func!.body.at(i);
                let t = self.fold_consts(b);

                body.push(t);
            }

            term.t_func!.body = body;
        } else if term.t_global_let != nil {
            let v = self.fold_consts(term.t_global_let!.value);

            term.t_global_let!.value = v;
        } else if term.t_call != nil {
            let c = self.fold_consts(term.t_call!.callee);
            term.t_call!.callee = c;

            let args = make[vec[IrTerm]]();
            for i in 0..term.t_call!.args.length {
                let arg = term.t_call!.args.at(i);
                let t = self.fold_consts(arg);

                args.push(t);
            }

            term.t_call!.args = args;

            if term.t_call!.callee.t_ident != nil {
                let op = term.t_call!.callee.t_ident!;

                if op.equal("add") {
                    if term.t_call!.args.at(0).t_i32 != nil && term.t_call!.args.at(1).t_i32 != nil {
                        return IrTerm {
                            t_i32: (term.t_call!.args.at(0).t_i32! + term.t_call!.args.at(1).t_i32!),
                        };
                    }
                } else if op.equal("sub") {
                    if term.t_call!.args.at(0).t_i32 != nil && term.t_call!.args.at(1).t_i32 != nil {
                        return IrTerm {
                            t_i32: (term.t_call!.args.at(0).t_i32! - term.t_call!.args.at(1).t_i32!),
                        };
                    }
                } else if op.equal("mult") {
                    if term.t_call!.args.at(0).t_i32 != nil && term.t_call!.args.at(1).t_i32 != nil {
                        return IrTerm {
                            t_i32: (term.t_call!.args.at(0).t_i32! * term.t_call!.args.at(1).t_i32!),
                        };
                    }
                } else if op.equal("div") {
                    if term.t_call!.args.at(0).t_i32 != nil && term.t_call!.args.at(1).t_i32 != nil {
                        return IrTerm {
                            t_i32: (term.t_call!.args.at(0).t_i32! / term.t_call!.args.at(1).t_i32!),
                        };
                    }
                }
            }
        } else if term.t_seq != nil {
            let terms = make[vec[IrTerm]]();
            for i in 0..term.t_seq!.terms.length {
                let element = term.t_seq!.terms.at(i);
                let t = self.fold_consts(element);

                terms.push(t);
            }

            term.t_seq!.terms = terms;
        } else if term.t_let != nil {
            let t = self.fold_consts(term.t_let!.value);

            term.t_let!.value = t;
        } else if term.t_return != nil {
            let t = self.fold_consts(term.t_return!.value);

            term.t_return!.value = t;
        } else if term.t_assign != nil {
            let t = self.fold_consts(term.t_assign!.rhs);

            term.t_assign!.rhs = t;
        } else if term.t_if != nil {
            let c = self.fold_consts(term.t_if!.condition);
            term.t_if!.condition = c;

            let t = self.fold_consts(term.t_if!.then_term);
            term.t_if!.then_term = t;

            let e = self.fold_consts(term.t_if!.else_term);
            term.t_if!.else_term = e;
        } else if term.t_while != nil {
            let c = self.fold_consts(term.t_while!.condition);
            term.t_while!.condition = c;

            let b = self.fold_consts(term.t_while!.block);
            term.t_while!.block = b;

            if term.t_while!.cleanup != nil {
                let t = self.fold_consts(term.t_while!.cleanup!);
                term.t_while!.cleanup! = t;
            }
        } else if term.t_sizeof != nil {
            let size = term.t_sizeof!.type_.sizeof();

            return IrTerm {
                t_i32: size,
            };
        } else if term.t_discard != nil {
            let d = self.fold_consts(term.t_discard!);

            return IrTerm {
                t_discard: d,
            };
        } else if term.t_and != nil {
            let l = self.fold_consts(term.t_and!.lhs);
            term.t_and!.lhs = l;

            let r = self.fold_consts(term.t_and!.rhs);
            term.t_and!.rhs = r;
        } else if term.t_or != nil {
            let l = self.fold_consts(term.t_or!.lhs);
            term.t_or!.lhs = l;

            let r = self.fold_consts(term.t_or!.rhs);
            term.t_or!.rhs = r;
        } else if term.t_store != nil {
            let a = self.fold_consts(term.t_store!.address);
            term.t_store!.address = a;

            let o = self.fold_consts(term.t_store!.offset);
            term.t_store!.offset = o;

            let v = self.fold_consts(term.t_store!.value);
            term.t_store!.value = v;
        } else if term.t_load != nil {
            let a = self.fold_consts(term.t_load!.address);
            term.t_load!.address = a;

            let o = self.fold_consts(term.t_load!.offset);
            term.t_load!.offset = o;
        }

        return term;
    }

    fun optimize_i32(self, term: IrTerm) {
        let optimized = false;
        if term.t_i32 != nil {
            self.new_statement();
            self.write(format("i32.const {}", term.t_i32!.to_string()));

            optimized = true;
        }
        if !optimized {
            self.new_statement();
            self.expression(term);

            self.convert_stack_to_i32_1();
        }
    }
}

