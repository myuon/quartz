import quartz::ast;

type Module = {
    decls: vec[Decl],
};

module Module {
    fun to_string(self): string {
        let result = "Module{";

        for i in 0..self.decls.length {
            result = result.concat(self.decls.at(i).to_string()).concat("\n");
        }

        return result.concat("}");
    }
}

type Decl = {
    t_func: Function?,
    t_let: Let?,
};

module Decl {
    fun to_string(self): string {
        if self.t_func != nil {
            return self.t_func!.to_string();
        }

        panic("Unknown decl type");
    }
}

type Let = {
    name: string,
    name_type: Type,
    expr: Expression,
};

module Let {
    fun to_string(self): string {
        return format(
            "let {} : {} = {};",
            self.name,
            self.name_type.to_string(),
            self.expr.to_string(),
        );
    }
}

type Function = {
    name: string,
    result_type: Type,
    body: Block,
    params: vec[struct {
        name: string,
        type_: Type,
    }],
};

module Function {
    fun to_string(self): string {
        return "fun ".concat(self.name).concat("(??) {\n").concat(self.body.to_string()).concat("}\n");
    }

    fun to_type(self): Type {
        let params_type = make[vec[Type]]();
        for i in 0..self.params.length {
            let p = self.params.at(i);
            params_type.push(p.type_);
        }

        return Type {
            t_func: struct {
                params: params_type,
                result: self.result_type,
            }?,
            ..nil,
        };
    }
}

type Block = {
    block: vec[Statement],
};

module Block {
    fun to_string(self): string {
        let result = "";

        for i in 0..self.block.length {
            result = result.concat("    ").concat(self.block.at(i).to_string());
        }

        return result;
    }
}

type Statement = {
    t_let: struct {
        name: string,
        name_type: Type,
        expr: Expression,
    }?,
    t_return: struct {
        expr: Expression,
    }?,
    t_assign: struct {
        lhs: Expression,
        rhs: Expression,
    }?,
    t_expr: struct {
        expr: Expression,
    }?,
    t_if: struct {
        condition: Expression,
        then_block: Block,
        else_block: Block?,
    }?,
    t_while: struct {
        condition: Expression,
        block: Block,
    }?,
};

module Statement {
    fun to_string(self): string {
        if self.t_let != nil {
            return "let ".concat(self.t_let!.name).concat(": ").concat(self.t_let!.name_type.to_string()).concat(" = ").concat(self.t_let!.expr.to_string()).concat(";\n");
        }
        if self.t_return != nil {
            return "return ".concat(self.t_return!.expr.to_string()).concat(";\n");
        }
        if self.t_assign != nil {
            return format(
                "{} = {};",
                self.t_assign!.lhs.to_string(),
                self.t_assign!.rhs.to_string(),
            );
        }
        if self.t_expr != nil {
            return format(
                "{};",
                self.t_expr!.expr.to_string(),
            );
        }
        if self.t_if != nil {
            let result = format(
                "if ({}) {\n{}}",
                self.t_if!.condition.to_string(),
                self.t_if!.then_block.to_string(),
            );

            if self.t_if!.else_block != nil {
                result = format(
                    "{} else {\n{}}",
                    result,
                    self.t_if!.else_block!.to_string(),
                );
            }

            return result.concat("\n");
        }
        if self.t_while != nil {
            return format(
                "while ({}) {{\n{}}}",
                self.t_while!.condition.to_string(),
                self.t_while!.block.to_string(),
            );
        }

        panic("Unknown statement type");
    }
}

type Expression = {
    t_ident: struct {
        name: string,
    }?,
    t_binop: struct {
        binop: string,
        left: Expression,
        right: Expression,
    }?,
    t_number: struct {
        value: string,
    }?,
    t_call: struct {
        callee: Expression,
        args: vec[Expression],
    }?,
};

module Expression {
    fun to_string(self): string {
        if self.t_ident != nil {
            return self.t_ident!.name;
        }
        if self.t_binop != nil {
            return self.t_binop!.left.to_string().concat(" ").concat(self.t_binop!.binop).concat(" ").concat(self.t_binop!.right.to_string());
        }
        if self.t_number != nil {
            return self.t_number!.value;
        }
        if self.t_call != nil {
            let result = self.t_call!.callee.to_string().concat("(");

            for i in 0..self.t_call!.args.length {
                result = result.concat(self.t_call!.args.at(i).to_string());

                if i != self.t_call!.args.length - 1 {
                    result = result.concat(", ");
                }
            }

            return result.concat(")");
        }

        panic("Unknown expression type");
    }
}

type Type = {
    t_omit: bool?, // for unification
    t_nil: bool?,
    t_i32: bool?,
    t_func: struct {
        params: vec[Type],
        result: Type,
    }?,
    t_ptr: Type?,
    t_bool: bool?,
};

module Type {
    fun to_string(self): string {
        if self.t_omit != nil {
            return "omit";
        }
        if self.t_nil != nil {
            return "nil";
        }
        if self.t_i32 != nil {
            return "i32";
        }
        if self.t_func != nil {
            let s = "func(";
            for i in 0..self.t_func!.params.length {
                let p = self.t_func!.params.at(i);
                s = s.concat(p.to_string());
                if i != self.t_func!.params.length - 1 {
                    s = s.concat(", ");
                }
            }
            s = s.concat(") -> ");
            s = s.concat(self.t_func!.result.to_string());
            return s;
        }
        if self.t_ptr != nil {
            return format("ptr[{}]", self.t_ptr!.to_string());
        }
        if self.t_bool != nil {
            return "bool";
        }

        panic("unimplemented: type.to_string");
    }
}
