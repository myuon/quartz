import quartz::ast;

type Function = {
    name: string,
    result_type: Type,
    body: Block,
};

module Function {
    fun to_string(self) {
        return "fun ".concat(self.name).concat("() {\n").concat(self.body.to_string()).concat("}\n");
    }
}

type Block = {
    block: vec[Statement],
};

module Block {
    fun to_string(self) {
        let result = "";

        for i in 0..self.block.length {
            result = result.concat("    ").concat(self.block.at(i).to_string());
        }

        return result;
    }
}

type Statement = {
    t_let: struct {
        name: string,
        name_type: string,
        expr: Expression,
    }?,
    t_return: struct {
        expr: Expression,
    }?,
};

module Statement {
    fun to_string(self) {
        if self.t_let != nil {
            return "let ".concat(self.t_let!.name).concat(": ").concat(self.t_let!.name_type).concat(" = ").concat(self.t_let!.expr.to_string()).concat(";\n");
        }
        if self.t_return != nil {
            return "return ".concat(self.t_return!.expr.to_string()).concat(";\n");
        }

        panic("Unknown statement type");
    }
}

type Expression = {
    t_ident: struct {
        name: string,
    }?,
    t_binop: struct {
        binop: string,
        left: Expression,
        right: Expression,
    }?,
    t_number: struct {
        value: string,
    }?,
};

module Expression {
    fun to_string(self): string {
        if self.t_ident != nil {
            return self.t_ident!.name;
        }
        if self.t_binop != nil {
            return self.t_binop!.left.to_string().concat(" ").concat(self.t_binop!.binop).concat(" ").concat(self.t_binop!.right.to_string());
        }
        if self.t_number != nil {
            return self.t_number!.value;
        }

        panic("Unknown expression type");
    }
}
