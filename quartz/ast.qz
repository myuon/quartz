import quartz::ast;
import quartz::path;

struct Module {
    decls: vec[Decl],
}

module Module {
    fun to_string(self): string {
        let result = "Module{";

        for i in 0..self.decls.length {
            result = result.concat(self.decls.at(i).to_string()).concat("\n");
        }

        return result.concat("}");
    }
}

struct Decl {
    t_func: Function?,
    t_let: Let?,
    t_type: struct {
        name: string,
        type_: Type,
    }?,
    t_module: struct {
        name: string,
        module_: Module,
    }?,
    t_import: Path?,
}

module Decl {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct Let {
    name: string,
    name_type: Type,
    expr: Expression,
}

module Let {
    fun to_string(self): string {
        return format("let {} : {} = {};", self.name, self.name_type.to_string(), self.expr.to_string());
    }
}

struct Function {
    name: string,
    result_type: Type,
    body: Block,
    params: vec[struct {
        name: string,
        type_: Type,
    }],
    variadic: struct {
        name: string,
        type_: Type,
    }?,
}

module Function {
    fun to_string(self): string {
        return "fun ".concat(self.name).concat("(??) {\n").concat(self.body.to_string()).concat("}\n");
    }

    fun to_type(self): Type {
        let params_type = make[vec[Type]]();
        for i in 0..self.params.length {
            let p = self.params.at(i);
            params_type.push(p.type_);
        }

        if self.variadic != nil {
            return Type {
                t_variadic_func: struct {
                    params: params_type,
                    variadic: self.variadic!.type_,
                    result: self.result_type,
                }?,
                ..nil,
            };
        } else {
            return Type {
                t_func: struct {
                    params: params_type,
                    result: self.result_type,
                }?,
                ..nil,
            };
        }
    }
}

struct Block {
    block: vec[Statement],
}

module Block {
    fun to_string(self): string {
        let result = "";

        for i in 0..self.block.length {
            result = result.concat("    ").concat(self.block.at(i).to_string());
        }

        return result;
    }
}

struct Statement {
    t_let: struct {
        pattern: Pattern,
        name_type: Type,
        expr: Expression,
    }?,
    t_return: struct {
        expr: Expression,
    }?,
    t_assign: struct {
        lhs: Expression,
        rhs: Expression,
    }?,
    t_expr: struct {
        expr: Expression,
    }?,
    t_if: struct {
        condition: Expression,
        then_block: Block,
        else_block: Block?,
    }?,
    t_while: struct {
        condition: Expression,
        block: Block,
    }?,
    t_for: struct {
        ident: string,
        range: Expression,
        block: Block,
    }?,
    t_continue: bool?,
    t_break: bool?,
}

module Statement {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct Expression {
    t_ident: struct {
        name: string,
        resolved_path: Path?,
    }?,
    t_binop: struct {
        binop: string,
        left: Expression,
        right: Expression,
    }?,
    t_i32: struct {
        value: i32,
    }?,
    t_u32: struct {
        value: u32,
    }?,
    t_call: struct {
        callee: Expression,
        args: vec[Expression],
        variadic: struct {
            element_type: Type,
            index: i32,
        }?,
        expansion: Expression?,
    }?,
    t_project: struct {
        expr: Expression,
        field: string,
        type_: Type?,
        resolved_path: Path?,
    }?,
    t_record: RecordExpression?,
    t_make: struct {
        type_: Type,
        args: vec[Expression],
    }?,
    t_as: struct {
        expr: Expression,
        source_type: Type,
        target_type: Type,
    }?,
    t_path: struct {
        path: Path,
    }?,
    t_self: bool?,
    t_string: string?,
    t_paren: Expression?,
    t_range: struct {
        start: Expression,
        end: Expression,
    }?,
    t_unop: struct {
        unop: string,
        expr: Expression,
    }?,
    t_unwrap: struct {
        type_: Type,
        expr: Expression,
    }?,
    t_wrap: struct {
        type_: Type,
        expr: Expression,
    }?,
    t_bool: bool?,
    t_nil: bool?,
    t_omit: bool?,
    t_enumor: struct {
        lhs: Expression?,
        rhs: Expression?,
        lhs_type: Type,
        rhs_type: Type,
    }?,
    t_sizeof: struct {
        type_: Type,
    }?,
}

module Expression {
    fun to_string(self): string {
        return derive::to_string_pretty(self);
    }
}

struct RecordExpression {
    name: string,
    fields: vec[struct {
        field: string,
        value: Expression,
    }],
}

module RecordExpression {
    fun to_string(self): string {
        let result = format("{} {{", self.name);

        for i in 0..self.fields.length {
            let f = self.fields.at(i);
            result = result.concat(f.field).concat(": ").concat(f.value.to_string());

            if i != self.fields.length - 1 {
                result = result.concat(", ");
            }
        }

        return result.concat("}");
    }

    fun at(self, field: string): Expression or error {
        for i in 0..self.fields.length {
            let f = self.fields.at(i);
            if f.field == field {
                return f.value;
            }
        }

        return _ or error::new("Field not found");
    }

    fun to_fields_map(self): map[string, Expression] {
        let result = make[map[string, Expression]]();
        for i in 0..self.fields.length {
            let f = self.fields.at(i);
            result.insert(f.field, f.value);
        }

        return result;
    }
}

struct Type {
    t_omit: bool?, // for unification
    t_nil: bool?,
    t_i32: bool?,
    t_u32: bool?,
    t_func: struct {
        params: vec[Type],
        result: Type,
    }?,
    t_ptr: Type?,
    t_bool: bool?,
    t_struct: TypeStruct?,
    t_byte: bool?,
    t_ident: string?,
    t_range: Type?,
    t_optional: Type?,
    t_vec: Type?,
    t_variadic_func: struct {
        params: vec[Type],
        variadic: Type,
        result: Type,
    }?,
    t_or: struct {
        left: Type,
        right: Type,
    }?,
    t_any: bool?,
}

module Type {
    fun to_string(self): string {
        return derive::to_string(self);
    }

    fun string(): Type {
        return Type {
            t_ident: "string"?,
            ..nil,
        };
    }

    fun is_integer_type(self): bool {
        return self.t_i32 != nil || self.t_u32 != nil || (self.t_ident != nil && self.t_ident!.equal("i64"));
    }
}

struct TypeStruct {
    fields: vec[struct {
        name: string,
        type_: Type,
    }],
}

module TypeStruct {
    fun has(self, name: string): bool {
        for i in 0..self.fields.length {
            if self.fields.at(i).name.equal(name) {
                return true;
            }
        }
        return false;
    }

    fun at(self, name: string): Type {
        for i in 0..self.fields.length {
            if self.fields.at(i).name.equal(name) {
                return self.fields.at(i).type_;
            }
        }

        return panic("unimplemented: typestruct.find");
    }

    fun index(self, name: string): i32 {
        for i in 0..self.fields.length {
            if self.fields.at(i).name.equal(name) {
                return i;
            }
        }

        return panic("unimplemented: typestruct.find");
    }
}

struct Pattern {
    t_ident: string?,
    t_or: struct {
        lhs: Pattern,
        rhs: Pattern,
    }?,
    t_omit: bool?,
}

module Pattern {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

