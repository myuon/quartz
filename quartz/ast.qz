import quartz::ast;
import quartz::path;
import quartz::location;

struct Module {
    decls: vec[LDecl],
}

module Module {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

enum Decl {
    t_func: Function,
    t_let: Let,
    t_type: struct {
        name: string,
        type_: Type,
    },
    t_enum: struct {
        name: string,
        type_: Type,
    },
    t_module: struct {
        path: Path,
        module_: Module,
    },
    t_import: Path,
}

module Decl {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct LDecl {
    data: Decl,
    location: Location,
}

struct Let {
    name: string,
    name_type: Type,
    expr: LExpression,
}

module Let {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct Function {
    name: string,
    result_type: Type,
    body: LBlock,
    params: vec[struct {
        name: string,
        type_: Type,
    }],
    variadic: struct {
        name: string,
        type_: Type,
    }?,
}

module Function {
    fun to_string(self): string {
        return derive::to_string(self);
    }

    fun to_type(self): Type {
        let params_type = make[vec[Type]]();
        for i in 0..self.params.length {
            let p = self.params.at(i);
            params_type.push(p.type_);
        }

        if self.variadic != nil {
            return Type {
                t_variadic_func: struct {
                    params: params_type,
                    result: self.result_type,
                    variadic: self.variadic!.type_,
                },
            };
        } else {
            return Type {
                t_func: struct {
                    params: params_type,
                    result: self.result_type,
                },
            };
        }
    }
}

struct Block {
    block: vec[LStatement],
}

module Block {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct LBlock {
    data: Block,
    location: Location,
}

enum Statement {
    t_let: struct {
        pattern: LPattern,
        name_type: Type,
        expr: LExpression,
    },
    t_return: struct {
        expr: LExpression,
    },
    t_assign: struct {
        lhs: LExpression,
        rhs_type: Type?,
        rhs: LExpression,
    },
    t_expr: struct {
        expr: LExpression,
    },
    t_if: struct {
        condition: LExpression,
        then_block: LBlock,
        else_block: LBlock?,
    },
    t_while: struct {
        condition: LExpression,
        block: LBlock,
    },
    t_for: struct {
        mode: string,
        type_: Type?,
        ident: string,
        range: LExpression,
        block: LBlock,
    },
    t_continue: bool,
    t_break: bool,
}

module Statement {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct LStatement {
    data: Statement,
    location: Location,
}

enum Expression {
    t_ident: struct {
        name: string,
        resolved_path: Path?,
    },
    t_binop: struct {
        binop: string,
        type_: Type?,
        left: LExpression,
        right: LExpression,
    },
    t_i32: struct {
        value: i32,
    },
    t_u32: struct {
        value: u32,
    },
    t_call: struct {
        callee: LExpression,
        args: vec[LExpression],
        variadic: struct {
            element_type: Type,
            index: i32,
        }?,
        expansion: LExpression?,
    },
    t_project: struct {
        expr: LExpression,
        field: string,
        type_: Type?,
        resolved_path: Path?,
    },
    t_record: RecordExpression,
    t_anonymous_record: struct {
        fields: vec[struct {
            data: struct {
                field: string,
                value: LExpression,
            },
            location: Location,
        }],
        type_: Type?,
    },
    t_make: struct {
        type_: Type,
        args: vec[LExpression],
    },
    t_as: struct {
        expr: LExpression,
        source_type: Type,
        target_type: Type,
    },
    t_path: struct {
        path: Path,
        resolved_path: Path?,
    },
    t_self: bool,
    t_string: struct {
        value: string,
        raw: string,
    },
    t_paren: LExpression,
    t_range: struct {
        start: LExpression,
        end: LExpression,
    },
    t_unop: struct {
        unop: string,
        expr: LExpression,
    },
    t_unwrap: struct {
        type_: Type,
        expr: LExpression,
    },
    t_wrap: struct {
        type_: Type,
        expr: LExpression,
    },
    t_bool: bool,
    t_nil: bool, // if nil is explicit
    t_omit: bool,
    t_enumor: struct {
        lhs: LExpression?,
        rhs: LExpression?,
        lhs_type: Type,
        rhs_type: Type,
    },
    t_sizeof: struct {
        type_: Type,
    },
    t_try: LExpression,
}

module Expression {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct LExpression {
    data: Expression,
    location: Location,
}

struct RecordExpression {
    name: string,
    fields: vec[struct {
        field: string,
        value: LExpression,
    }],
    expansion: LExpression?,
}

module RecordExpression {
    fun to_string(self): string {
        return derive::to_string(self);
    }

    fun at(self, field: string): Expression or error {
        for i in 0..self.fields.length {
            let f = self.fields.at(i);
            if f.field == field {
                return f.value.data;
            }
        }

        return _ or error::new("Field not found");
    }

    fun to_fields_map(self): map[string, LExpression] {
        let result = make[map[string, LExpression]]();
        for i in 0..self.fields.length {
            let f = self.fields.at(i);
            result.insert(f.field, f.value);
        }

        return result;
    }
}

enum Type {
    t_omit: bool, // for unification
    t_nil: bool,
    t_i32: bool,
    t_u32: bool,
    t_func: struct {
        params: vec[Type],
        result: Type,
    },
    t_variadic_func: struct {
        params: vec[Type],
        result: Type,
        variadic: Type,
    },
    t_ptr: Type,
    t_bool: bool,
    t_struct: TypeStruct,
    t_byte: bool,
    t_ident: string,
    t_range: Type,
    t_optional: Type,
    t_vec: Type,
    t_or: struct {
        left: Type,
        right: Type,
    },
    t_any: bool,
    t_map: struct {
        key: Type,
        value: Type,
    },
    t_enum: TypeStruct,
}

module Type {
    fun to_string(self): string {
        return derive::to_string(self);
    }

    fun string(): Type {
        return Type {
            t_ident: "string",
        };
    }

    fun is_integer_type(self): bool {
        return self.t_i32 != nil || self.t_u32 != nil || (self.t_ident != nil && self.t_ident!.equal("i64"));
    }
}

struct TypeStruct {
    fields: vec[struct {
        data: struct {
            name: string,
            type_: Type,
        },
        location: Location,
    }],
}

module TypeStruct {
    fun has(self, name: string): bool {
        for i in 0..self.fields.length {
            if self.fields.at(i).data.name.equal(name) {
                return true;
            }
        }
        return false;
    }

    fun at(self, name: string): Type {
        for i in 0..self.fields.length {
            if self.fields.at(i).data.name.equal(name) {
                return self.fields.at(i).data.type_;
            }
        }

        return panic("unimplemented: typestruct.at");
    }

    fun index(self, name: string): i32 {
        for i in 0..self.fields.length {
            if self.fields.at(i).data.name.equal(name) {
                return i;
            }
        }

        return panic("unimplemented: typestruct.index, {}, {}".format(derive::to_string(self), name));
    }
}

struct LType {
    data: Type,
    location: Location,
}

struct Pattern {
    t_ident: string?,
    t_or: struct {
        lhs: LPattern,
        rhs: LPattern,
    }?,
    t_omit: bool?,
}

module Pattern {
    fun to_string(self): string {
        return derive::to_string(self);
    }
}

struct LPattern {
    data: Pattern,
    location: Location,
}

