import quartz::ast;

type Module = {
    decls: vec[Decl],
};

module Module {
    fun to_string(self): string {
        let result = "Module{";

        for i in 0..self.decls.length {
            result = result.concat(self.decls.at(i).to_string()).concat("\n");
        }

        return result.concat("}");
    }
}

type Decl = {
    t_func: Function?,
};

module Decl {
    fun to_string(self): string {
        if self.t_func != nil {
            return self.t_func!.to_string();
        }

        panic("Unknown decl type");
    }
}

type Function = {
    name: string,
    result_type: Type,
    body: Block,
    params: vec[struct {
        name: string,
        type_: Type,
    }],
};

module Function {
    fun to_string(self): string {
        return "fun ".concat(self.name).concat("(??) {\n").concat(self.body.to_string()).concat("}\n");
    }
}

type Block = {
    block: vec[Statement],
};

module Block {
    fun to_string(self): string {
        let result = "";

        for i in 0..self.block.length {
            result = result.concat("    ").concat(self.block.at(i).to_string());
        }

        return result;
    }
}

type Statement = {
    t_let: struct {
        name: string,
        name_type: Type,
        expr: Expression,
    }?,
    t_return: struct {
        expr: Expression,
    }?,
};

module Statement {
    fun to_string(self): string {
        if self.t_let != nil {
            return "let ".concat(self.t_let!.name).concat(": ").concat(self.t_let!.name_type.to_string()).concat(" = ").concat(self.t_let!.expr.to_string()).concat(";\n");
        }
        if self.t_return != nil {
            return "return ".concat(self.t_return!.expr.to_string()).concat(";\n");
        }

        panic("Unknown statement type");
    }
}

type Expression = {
    t_ident: struct {
        name: string,
    }?,
    t_binop: struct {
        binop: string,
        left: Expression,
        right: Expression,
    }?,
    t_number: struct {
        value: string,
    }?,
    t_call: struct {
        callee: Expression,
        args: vec[Expression],
    }?,
};

module Expression {
    fun to_string(self): string {
        if self.t_ident != nil {
            return self.t_ident!.name;
        }
        if self.t_binop != nil {
            return self.t_binop!.left.to_string().concat(" ").concat(self.t_binop!.binop).concat(" ").concat(self.t_binop!.right.to_string());
        }
        if self.t_number != nil {
            return self.t_number!.value;
        }
        if self.t_call != nil {
            let result = self.t_call!.callee.to_string().concat("(");

            for i in 0..self.t_call!.args.length {
                result = result.concat(self.t_call!.args.at(i).to_string());

                if i != self.t_call!.args.length - 1 {
                    result = result.concat(", ");
                }
            }

            return result.concat(")");
        }

        panic("Unknown expression type");
    }
}
