import quartz::ast;
import quartz::ir;
import quartz::path;
import quartz::location;

let typeRepKindStruct = 1;

let typeRepKindEnum = 2;

struct InternalTypeRep {
    kind: i32,
    name: string,
    params: vec[InternalTypeRep],
    fields: vec[struct {
        name: string,
        type_: InternalTypeRep,
    }],
}

module InternalTypeRep {
    fun from_name(name: string, params: vec[InternalTypeRep]): InternalTypeRep {
        return InternalTypeRep {
            kind: typeRepKindStruct,
            name: name,
            params: params,
            fields: make[vec[struct {
                name: string,
                type_: InternalTypeRep,
            }]](),
        };
    }

    fun from_struct(
        name: string,
        params: vec[IrType],
        fields: vec[struct {
            name: string,
            type_: IrType,
        }],
    ): InternalTypeRep {
        let params_t = make[vec[InternalTypeRep]]();
        for p in params {
            params_t.push(InternalTypeRep::from_ir_type(p));
        }

        let fields_t = make[vec[struct {
            name: string,
            type_: InternalTypeRep,
        }]]();
        for f in fields {
            fields_t.push(struct {
                name: f.name,
                type_: InternalTypeRep::from_ir_type(f.type_),
            });
        }

        return InternalTypeRep {
            kind: typeRepKindStruct,
            name: name,
            params: params_t,
            fields: fields_t,
        };
    }

    fun from_ir_type(t: IrType): InternalTypeRep {
        if t.t_nil != nil {
            return InternalTypeRep::from_name("nil", make[vec[InternalTypeRep]]());
        } else if t.t_i32 != nil {
            return InternalTypeRep::from_name("i32", make[vec[InternalTypeRep]]());
        } else if t.t_address != nil {
            return InternalTypeRep::from_name("address", make[vec[InternalTypeRep]]());
        } else if t.t_byte != nil {
            return InternalTypeRep::from_name("byte", make[vec[InternalTypeRep]]());
        } else if t.t_any != nil {
            return InternalTypeRep::from_name("any", make[vec[InternalTypeRep]]());
        } else if t.t_bool != nil {
            return InternalTypeRep::from_name("bool", make[vec[InternalTypeRep]]());
        } else if t.t_i64 != nil {
            return InternalTypeRep::from_struct(
                "i64",
                make[vec[IrType]](),
                make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](
                    struct {
                        name: "hi",
                        type_: IrType {
                            t_i32: true,
                        },
                    },
                    struct {
                        name: "lo",
                        type_: IrType {
                            t_i32: true,
                        },
                    },
                ),
            );
        }

        return panic("unreachable, {}".format(t.to_string()));
    }

    fun equal(self, other: InternalTypeRep): bool {
        if self.kind != other.kind {
            return false;
        }
        if !self.name.equal(other.name) {
            return false;
        }
        if self.params.length != other.params.length {
            return false;
        }
        for i in 0..self.params.length {
            if !self.params.at(i).equal(other.params.at(i)) {
                return false;
            }
        }
        if self.fields.length != other.fields.length {
            return false;
        }
        for i in 0..self.fields.length {
            if !self.fields.at(i).name.equal(other.fields.at(i).name) {
                return false;
            }
            if !self.fields.at(i).type_.equal(other.fields.at(i).type_) {
                return false;
            }
        }

        return true;
    }
}

struct StringTable {
    strings: vec[string],
}

module StringTable {
    fun new(): StringTable {
        return StringTable {
            strings: make[vec[string]](),
        };
    }

    fun get_or_insert(self, key: string): i32 {
        for i in 0..self.strings.length {
            if self.strings.at(i).equal(key) {
                return i as i32;
            }
        }

        self.strings.push(key);

        return (self.strings.length - 1) as i32;
    }
}

struct TypeRepTable {
    type_reps: vec[InternalTypeRep],
}

module TypeRepTable {
    fun new(): TypeRepTable {
        return TypeRepTable {
            type_reps: make[vec[InternalTypeRep]](),
        };
    }

    fun get_or_insert(self, key: InternalTypeRep): i32 {
        for i in 0..self.type_reps.length {
            if self.type_reps.at(i).equal(key) {
                return i as i32;
            }
        }

        self.type_reps.push(key);

        return (self.type_reps.length - 1) as i32;
    }
}

struct IrCodeGenerator {
    globals: map[string, LType],
    locals: map[string, bool],
    current_path: Path,
    strings: StringTable,
    type_reps: TypeRepTable,
    data_section_offset: i32,
    counter: i32,
    start: vec[IrTerm],
}

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
            globals: make[map[string, LType]](),
            locals: make[map[string, bool]](),
            current_path: Path::new(),
            strings: StringTable::new(),
            type_reps: TypeRepTable::new(),
            data_section_offset: 0,
            counter: 0,
            start: make[vec[IrTerm]](),
        };
    }

    fun run(self, m: Module): IrTerm or error {
        let decls = self.module_(m).try;
        decls.push(self.generate_prepare_type_reps().try);
        decls.extend(self.generate_prepare_strings().try);
        decls.push(IrTerm {
            t_func: IrFunc {
                name: "reflection_get_type_rep_id",
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](struct {
                    name: "p",
                    type_: IrType {
                        t_address: true,
                    },
                }),
                result_type: IrType {
                    t_address: true,
                },
                body: make[vec[IrTerm]](IrTerm {
                    t_return: IrReturn {
                        value: IrTerm {
                            t_load: struct {
                                type_: IrType {
                                    t_address: true,
                                },
                                address: IrTerm {
                                    t_ident: "p",
                                },
                                offset: IrTerm {
                                    t_i32: 0,
                                },
                                raw_offset: 0,
                            },
                        },
                    },
                }),
            },
        });

        return IrTerm {
            t_module: struct {
                elements: decls,
            },
        };
    }

    fun module_(self, m: Module): vec[IrTerm] or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..m.decls.length {
            let d = m.decls.at(i).data;

            if d.t_func != nil {
                elements.push(IrTerm {
                    t_func: self.function(d.t_func!).try,
                });
            }
            if d.t_let != nil {
                elements.push(IrTerm {
                    t_global_let: struct {
                        name: self.path_to(d.t_let!.name),
                        type_: IrType {
                            t_i32: true,
                        },
                        value: self.expression(d.t_let!.expr).try,
                    },
                });
            }
            if d.t_module != nil {
                let path = self.current_path.clone();
                self.current_path.extend(d.t_module!.path);
                elements.extend(self.module_(d.t_module!.module_).try);
                self.current_path = path;
            }
        }

        return elements;
    }

    fun generate_prepare_type_reps(self): IrTerm or error {
        let var_ptr = "quartz_std_type_reps_ptr";

        let rep_ids = make[vec[struct {
            rep: InternalTypeRep,
            id: i32,
        }]]();
        let rep_id_counter = 0;
        for rep in self.type_reps.type_reps {
            rep_ids.push(struct {
                rep: rep,
                id: rep_id_counter,
            });
            rep_id_counter = rep_id_counter + 1;
        }

        let body = make[vec[IrTerm]]();

        // quartz_std_type_reps_ptr = make[ptr[any]](${type_reps.len()});
        self.start.push(IrTerm {
            t_assign: struct {
                lhs: var_ptr,
                rhs: self.expression(LExpression {
                    data: Expression {
                        t_make: struct {
                            type_: Type {
                                t_ptr: Type {
                                    t_ident: "any",
                                },
                            },
                            args: make[vec[LExpression]](LExpression {
                                data: Expression {
                                    t_i32: struct {
                                        value: self.type_reps.type_reps.length,
                                    },
                                },
                                location: Location::unknown(),
                            }),
                        },
                    },
                    location: Location::unknown(),
                }).try,
            },
        });

        for t in rep_ids {
            let type_rep = t.rep;
            let rep_id = t.id;
            let var_p = "p";

            // let p = write_type_rep(${rep});
            body.push(IrTerm {
                t_let: IrLet {
                    name: var_p,
                    type_: IrType {
                        t_i32: true,
                    },
                    value: self.write_type_rep(type_rep).try,
                },
            });

            // quartz_std_type_reps_ptr.at(${rep_id}) = p
            let lhs = IrTerm {
                t_load: struct {
                    type_: IrType {
                        t_address: true,
                    },
                    address: IrTerm {
                        t_ident: var_ptr,
                    },
                    offset: IrCodeGenerator::wrap_mult_sizeof(
                        IrType {
                            t_address: true,
                        },
                        IrTerm {
                            t_i32: rep_id,
                        },
                    ),
                    raw_offset: 0,
                },
            };
            body.push(self.assign(
                lhs,
                IrType {
                    t_address: true,
                },
                IrTerm {
                    t_ident: var_p,
                },
            ).try);
        }

        body.push(IrTerm {
            t_return: IrReturn {
                value: IrTerm {
                    t_nil: true,
                },
            },
        });

        return IrTerm {
            t_func: IrFunc {
                name: "prepare_type_reps",
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](),
                result_type: IrType {
                    t_nil: true,
                },
                body: body,
            },
        };
    }

    fun generate_prepare_strings(self): vec[IrTerm] or error {
        let terms = make[vec[IrTerm]]();

        let var_strings = "quartz_std_strings_ptr";
        let body = make[vec[IrTerm]]();
        self.start.push(IrTerm {
            t_assign: struct {
                lhs: var_strings,
                rhs: self.expression(LExpression {
                    data: Expression {
                        t_make: struct {
                            type_: Type {
                                t_ptr: Type {
                                    t_ident: "string",
                                },
                            },
                            args: make[vec[LExpression]](LExpression {
                                data: Expression {
                                    t_i32: struct {
                                        value: self.strings.strings.length,
                                    },
                                },
                                location: Location::unknown(),
                            }),
                        },
                    },
                    location: Location::unknown(),
                }).try,
            },
        });

        // avoid 0-8 for null pointer
        self.data_section_offset = 8;

        for i in 0..self.strings.strings.length {
            let str = self.strings.strings.at(i);
            let str_len = str.length;
            let str_memory_size = str_len;

            terms.push(IrTerm {
                t_data: struct {
                    data: str,
                    offset: self.data_section_offset,
                },
            });

            // strings.at(i) = new_empty_string(${offset}, ${string.len()})
            // FIXME: shoule be converted to ptr[byte]
            let lhs = IrTerm {
                t_load: struct {
                    type_: IrType {
                        t_address: true,
                    },
                    address: IrTerm {
                        t_ident: var_strings,
                    },
                    offset: IrCodeGenerator::wrap_mult_sizeof(
                        IrType {
                            t_address: true,
                        },
                        IrTerm {
                            t_i32: i,
                        },
                    ),
                    raw_offset: 0,
                },
            };

            body.push(self.assign(
                lhs,
                IrType {
                    t_address: true,
                },
                IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_new_string",
                        },
                        args: make[vec[IrTerm]](
                            IrTerm {
                                t_i32: self.data_section_offset,
                            },
                            IrTerm {
                                t_i32: str_len,
                            },
                        ),
                    },
                },
            ).try);

            self.data_section_offset = self.data_section_offset + str_memory_size;
        }

        body.push(IrTerm {
            t_return: IrReturn {
                value: IrTerm {
                    t_nil: true,
                },
            },
        });

        terms.push(IrTerm {
            t_func: IrFunc {
                name: "prepare_strings".to_string(),
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](),
                body: body,
                result_type: IrType {
                    t_nil: true,
                },
            },
        });

        return terms;
    }

    fun function(self, func: Function): IrFunc or error {
        self.locals = make[map[string, bool]]();
        // println("{}", self.path_to(func.name));
        // debug(alloc_ptr);
        let body = self.block(func.body).try;

        let params = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..func.params.length {
            let p = func.params.at(i);

            if p.name.equal("self") {
                params.push(struct {
                    name: p.name,
                    type_: IrType::new(Type {
                        t_ident: self.current_path.path.at(0),
                    }),
                });
            } else {
                params.push(struct {
                    name: p.name,
                    type_: IrType::new(p.type_),
                });
            }
        }
        if func.variadic != nil {
            params.push(struct {
                name: func.variadic!.name,
                type_: IrType::new(func.variadic!.type_),
            });
        }

        return IrFunc {
            name: self.path_to(func.name.data),
            params: params,
            result_type: IrType::new(func.result_type),
            body: body,
        };
    }

    fun path_to(self, s: string): string {
        return self.current_path.join("_").concat("_").concat(s);
    }

    fun block(self, b: LBlock): vec[IrTerm] or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..b.data.block.length {
            elements.push(self.statement(b.data.block.at(i)).try);
        }

        return elements;
    }

    fun statement(self, lstm: LStatement): IrTerm or error {
        let stm = lstm.data;
        if stm.t_let != nil {
            if stm.t_let!.pattern.data.t_ident != nil {
                let name = stm.t_let!.pattern.data.t_ident!;

                let term = IrTerm {
                    t_let: IrLet {
                        name: name,
                        type_: IrType {
                            t_i32: true,
                        },
                        value: self.expression(stm.t_let!.expr).try,
                    },
                };
                self.locals.insert(name, true);

                return term;
            } else if stm.t_let!.pattern.data.t_or != nil {
                let lhs = stm.t_let!.pattern.data.t_or!.lhs.data.t_ident!;
                let rhs = stm.t_let!.pattern.data.t_or!.rhs.data.t_ident!;

                if stm.t_let!.name_type.t_or == nil {
                    return _ or error::new("expected or type");
                }

                let var_name = format("or_{}", self.counter.to_string());
                self.counter = self.counter + 1;

                return IrTerm {
                    t_seq: struct {
                        terms: make[vec[IrTerm]](
                            IrTerm {
                                t_let: IrLet {
                                    name: var_name,
                                    type_: IrType::new(stm.t_let!.name_type),
                                    value: self.expression(stm.t_let!.expr).try,
                                },
                            },
                            IrTerm {
                                t_let: IrLet {
                                    name: lhs,
                                    type_: IrType {
                                        t_address: true,
                                    },
                                    value: self.generate_array_at(
                                        stm.t_let!.name_type.t_or!.left,
                                        IrTerm {
                                            t_ident: var_name,
                                        },
                                        IrTerm {
                                            t_i32: 0,
                                        },
                                    ).try,
                                },
                            },
                            IrTerm {
                                t_let: IrLet {
                                    name: rhs,
                                    type_: IrType {
                                        t_address: true,
                                    },
                                    value: self.generate_array_at(
                                        stm.t_let!.name_type.t_or!.right,
                                        IrTerm {
                                            t_ident: var_name,
                                        },
                                        IrTerm {
                                            t_i32: 1,
                                        },
                                    ).try,
                                },
                            },
                        ),
                    },
                };
            }
        } else if stm.t_return != nil {
            let term = IrTerm {
                t_return: IrReturn {
                    value: self.expression(stm.t_return!.expr).try,
                },
            };

            return term;
        } else if stm.t_expr != nil {
            return IrTerm {
                t_discard: self.expression(stm.t_expr!.expr).try,
            };
        } else if stm.t_assign != nil {
            let lhs = self.expression(stm.t_assign!.lhs).try;
            let rhs = self.expression(stm.t_assign!.rhs).try;
            if stm.t_assign!.rhs_type == nil {
                return _ or error::new("expected rhs type");
            }

            return self.assign(lhs, IrType::new(stm.t_assign!.rhs_type!), rhs).try;
        } else if stm.t_if != nil {
            let then_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_if!.then_block.data.block.length {
                then_elements.push(self.statement(stm.t_if!.then_block.data.block.at(i)).try);
            }

            let else_elements = make[vec[IrTerm]]();
            if stm.t_if!.else_block != nil {
                for i in 0..stm.t_if!.else_block!.data.block.length {
                    else_elements.push(self.statement(stm.t_if!.else_block!.data.block.at(i)).try);
                }
            }

            return IrTerm {
                t_if: struct {
                    condition: self.expression(stm.t_if!.condition).try,
                    then_term: IrTerm {
                        t_seq: struct {
                            terms: then_elements,
                        },
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: else_elements,
                        },
                    },
                },
            };
        } else if stm.t_while != nil {
            let body_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_while!.block.data.block.length {
                body_elements.push(self.statement(stm.t_while!.block.data.block.at(i)).try);
            }

            return IrTerm {
                t_while: struct {
                    condition: self.expression(stm.t_while!.condition).try,
                    block: IrTerm {
                        t_seq: struct {
                            terms: body_elements,
                        },
                    },
                    cleanup: nil as IrTerm?,
                },
            };
        } else if stm.t_for != nil {
            if stm.t_for!.mode.equal("range") {
                let range = stm.t_for!.range.data.t_range!;

                return IrTerm {
                    t_seq: struct {
                        terms: make[vec[IrTerm]](
                            IrTerm {
                                t_let: IrLet {
                                    name: stm.t_for!.ident,
                                    type_: IrType {
                                        t_i32: true,
                                    },
                                    value: self.expression(range.start).try,
                                },
                            },
                            IrTerm {
                                t_while: struct {
                                    condition: IrTerm {
                                        t_call: IrCall {
                                            callee: IrTerm {
                                                t_ident: "lt",
                                            },
                                            args: make[vec[IrTerm]](
                                                IrTerm {
                                                    t_ident: stm.t_for!.ident,
                                                },
                                                self.expression(range.end).try,
                                            ),
                                        },
                                    },
                                    block: IrTerm {
                                        t_seq: struct {
                                            terms: self.block(stm.t_for!.block).try,
                                        },
                                    },
                                    cleanup: IrTerm {
                                        t_assign: struct {
                                            lhs: stm.t_for!.ident,
                                            rhs: IrTerm {
                                                t_call: IrCall {
                                                    callee: IrTerm {
                                                        t_ident: "add",
                                                    },
                                                    args: make[vec[IrTerm]](
                                                        IrTerm {
                                                            t_ident: stm.t_for!.ident,
                                                        },
                                                        IrTerm {
                                                            t_i32: 1,
                                                        },
                                                    ),
                                                },
                                            },
                                        },
                                    }?,
                                },
                            },
                        ),
                    },
                };
            } else if stm.t_for!.mode.equal("vec") {
                // for v in vec { body }
                // =>
                // for i in 0..vec.length {
                //   let v = vec.at(i);
                //   body
                // }
                let var_index = format("index_{}", self.counter.to_string());
                self.counter = self.counter + 1;

                if stm.t_for!.type_ == nil || stm.t_for!.type_!.t_vec == nil {
                    panic("TODO: infer type of for loop variable");
                }
                let vec_type = stm.t_for!.type_!.t_vec!;

                let new_body = make[vec[LStatement]]();
                new_body.push(LStatement {
                    location: Location::unknown(),
                    data: Statement {
                        t_let: struct {
                            pattern: LPattern {
                                data: Pattern {
                                    t_ident: stm.t_for!.ident?,
                                    ..nil,
                                },
                                location: Location::unknown(),
                            },
                            name_type: vec_type,
                            expr: LExpression {
                                data: Expression {
                                    t_call: struct {
                                        callee: LExpression {
                                            data: Expression {
                                                t_project: struct {
                                                    expr: stm.t_for!.range,
                                                    field: Ident {
                                                        data: "at",
                                                        location: Location::unknown(),
                                                    },
                                                    type_: stm.t_for!.type_,
                                                    resolved_path: nil as Path?,
                                                },
                                            },
                                            location: Location::unknown(),
                                        },
                                        args: make[vec[LExpression]](LExpression {
                                            data: Expression {
                                                t_ident: struct {
                                                    name: var_index,
                                                    resolved_path: nil as Path?,
                                                },
                                            },
                                            location: Location::unknown(),
                                        }),
                                        variadic: nil,
                                        expansion: nil,
                                    },
                                },
                                location: Location::unknown(),
                            },
                        },
                    },
                });
                for body in stm.t_for!.block.data.block {
                    new_body.push(body);
                }

                return self.statement(LStatement {
                    location: Location::unknown(),
                    data: Statement {
                        t_for: struct {
                            mode: "range",
                            type_: nil,
                            ident: var_index,
                            range: LExpression {
                                data: Expression {
                                    t_range: struct {
                                        start: LExpression {
                                            data: Expression {
                                                t_i32: struct {
                                                    value: 0,
                                                },
                                            },
                                            location: Location::unknown(),
                                        },
                                        end: LExpression {
                                            data: Expression {
                                                t_project: struct {
                                                    expr: stm.t_for!.range,
                                                    field: Ident {
                                                        data: "length",
                                                        location: Location::unknown(),
                                                    },
                                                    type_: stm.t_for!.type_,
                                                    resolved_path: nil as Path?,
                                                },
                                            },
                                            location: Location::unknown(),
                                        },
                                    },
                                },
                                location: Location::unknown(),
                            },
                            block: LBlock {
                                data: Block {
                                    block: new_body,
                                },
                                location: Location::unknown(),
                            },
                        },
                    },
                }).try;
            } else {
                return _ or error::new(format("unsupported for loop: {}", stm.to_string()));
            }
        } else if stm.t_continue != nil {
            return IrTerm {
                t_continue: true,
            };
        } else if stm.t_break != nil {
            return IrTerm {
                t_break: true,
            };
        }

        return _ or error::new(format("statement exhausted: {}", stm.to_string()));
    }

    fun expression(self, lexpr: LExpression): IrTerm or error {
        let expr = lexpr.data;
        if expr.t_i32 != nil {
            let term = IrTerm {
                t_i32: expr.t_i32!.value,
            };

            return term;
        } else if expr.t_u32 != nil {
            let term = IrTerm {
                t_u32: expr.t_u32!.value,
            };

            return term;
        } else if expr.t_binop != nil {
            let args = make[vec[IrTerm]]();
            args.push(self.expression(expr.t_binop!.left).try);
            args.push(self.expression(expr.t_binop!.right).try);

            if expr.t_binop!.binop.equal("plus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "add",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("minus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "sub",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("mult") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "mult",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("div") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "div";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "div_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "div_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("mod") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "mod";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "mod_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "mod_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "equal",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("not_equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "not_equal",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("lt") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "lt",
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("gt") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "gt";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "gt_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "gt_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("lte") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "lte";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "lte_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "lte_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("gte") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "gte";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "gte_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "gte_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("and") {
                return IrTerm {
                    t_and: struct {
                        lhs: self.expression(expr.t_binop!.left).try,
                        rhs: self.expression(expr.t_binop!.right).try,
                    },
                };
            } else if expr.t_binop!.binop.equal("or") {
                return IrTerm {
                    t_or: struct {
                        lhs: self.expression(expr.t_binop!.left).try,
                        rhs: self.expression(expr.t_binop!.right).try,
                    },
                };
            } else if expr.t_binop!.binop.equal("bit_and") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "bit_and";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "bit_and_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "bit_and_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("bit_or") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "bit_or";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "bit_or_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "bit_or_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("bit_shift_left") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "bit_shift_left";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "bit_shift_left_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "bit_shift_left_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            } else if expr.t_binop!.binop.equal("bit_shift_right") {
                if expr.t_binop!.type_ == nil {
                    panic("TODO: infer type of binary operation");
                }

                let op = "bit_shift_right";
                if expr.t_binop!.type_!.t_u32 != nil {
                    op = "bit_shift_right_u32";
                } else if expr.t_binop!.type_!.t_ident != nil && expr.t_binop!.type_!.t_ident!.equal("i64") {
                    op = "bit_shift_right_i64";
                }

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: op,
                        },
                        args: args,
                    },
                };
            }

            panic("binop exhausted: ".concat(expr.t_binop!.binop));
        } else if expr.t_ident != nil {
            if expr.t_ident!.resolved_path != nil {
                return IrTerm {
                    t_ident: expr.t_ident!.resolved_path!.join("_"),
                };
            }

            return IrTerm {
                t_ident: expr.t_ident!.name,
            };
        } else if expr.t_call != nil {
            let callee = expr.t_call!.callee.data;
            if callee.t_project != nil {
                let project = callee.t_project!;
                if project.type_!.t_ptr != nil && project.field.data.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 2 arguments");
                    }

                    let t_ptr_elem = project.type_!.t_ptr!;

                    let term = self.expression(project.expr).try;
                    let offset = self.expression(expr.t_call!.args.at(0)).try;

                    return IrTerm {
                        t_load: struct {
                            type_: IrType::new(t_ptr_elem),
                            address: term,
                            offset: IrCodeGenerator::wrap_mult_sizeof(IrType::new(t_ptr_elem), offset),
                            raw_offset: 0,
                        },
                    };
                } else if project.type_!.t_ptr != nil && project.field.data.equal("offset") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("offset() takes 2 arguments");
                    }

                    let t_ptr_elem = project.type_!.t_ptr!;

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "add",
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                IrCodeGenerator::wrap_mult_sizeof(
                                    IrType::new(t_ptr_elem),
                                    self.expression(expr.t_call!.args.at(0)).try,
                                ),
                            ),
                        },
                    };
                } else if project.type_!.t_vec != nil && project.field.data.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 2 arguments");
                    }

                    let symbol = "";
                    if project.type_!.t_vec!.t_byte != nil {
                        symbol = "quartz_std_vec_at_byte";
                    } else {
                        symbol = "quartz_std_vec_at";
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: symbol,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_vec != nil && project.field.data.equal("push") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("push() takes 2 arguments");
                    }

                    let symbol = "";
                    if project.type_!.t_vec!.t_byte != nil {
                        symbol = "quartz_std_vec_push_byte";
                    } else {
                        symbol = "quartz_std_vec_push";
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: symbol,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_vec != nil && project.field.data.equal("extend") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("extend() takes 2 arguments");
                    }

                    let symbol = "";
                    if project.type_!.t_vec!.t_byte != nil {
                        symbol = "quartz_std_vec_extend_byte";
                    } else {
                        symbol = "quartz_std_vec_extend";
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: symbol,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_vec != nil && project.field.data.equal("slice") {
                    if expr.t_call!.args.length != 2 {
                        return _ or error::new("slice() takes 2 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_slice",
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                                self.expression(expr.t_call!.args.at(1)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_map != nil && project.field.data.equal("insert") {
                    if expr.t_call!.args.length != 2 {
                        return _ or error::new("insert() takes 2 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_insert",
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                                self.expression(expr.t_call!.args.at(1)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_map != nil && project.field.data.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 1 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_at",
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_map != nil && project.field.data.equal("has") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("has() takes 1 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_has",
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        },
                    };
                } else if project.type_!.t_map != nil && project.field.data.equal("list_keys") {
                    if expr.t_call!.args.length != 0 {
                        return _ or error::new("list_keys() takes 0 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_list_keys",
                            },
                            args: make[vec[IrTerm]](self.expression(project.expr).try),
                        },
                    };
                } else {
                    let args_with_self = make[vec[LExpression]](project.expr);
                    args_with_self.extend(expr.t_call!.args);

                    if expr.t_call!.variadic != nil {
                        expr.t_call!.variadic!.index = expr.t_call!.variadic!.index + 1;
                    }

                    if project.resolved_path == nil {
                        return _ or error::new(format(
                            "project.resolved_path is nil: {}, {}",
                            self.current_path.join("::"),
                            derive::to_string(project),
                        ));
                    }

                    return self.generate_call(
                        LExpression {
                            data: Expression {
                                t_path: struct {
                                    path: project.resolved_path!,
                                    resolved_path: project.resolved_path,
                                },
                            },
                            location: Location::unknown(),
                        },
                        args_with_self,
                        expr.t_call!.variadic,
                        expr.t_call!.expansion,
                    ).try;
                }
            } else {
                return self.generate_call(
                    expr.t_call!.callee,
                    expr.t_call!.args,
                    expr.t_call!.variadic,
                    expr.t_call!.expansion,
                ).try;
            }
        } else if expr.t_record != nil {
            if !self.globals.has(expr.t_record!.name) {
                return _ or error::new(format("record not found: {}", expr.t_record!.name));
            }
            let record_type = self.globals.at(expr.t_record!.name).data;

            if record_type.t_enum != nil {
                if expr.t_record!.fields.length != 1 {
                    return _ or error::new("enum constructor takes 1 argument");
                }
                let field = expr.t_record!.fields.at(0);
                let index = record_type.t_enum!.index(field.field);
                let value = self.expression(field.value).try;

                let fields = make[vec[struct {
                    name: string,
                    type_: InternalTypeRep,
                }]]();
                for field in record_type.t_enum!.fields {
                    fields.push(struct {
                        name: field.data.name,
                        type_: InternalTypeRep::from_ir_type(IrType::new(field.data.type_)),
                    });
                }

                let rep = InternalTypeRep {
                    kind: typeRepKindEnum,
                    name: expr.t_record!.name,
                    params: make[vec[InternalTypeRep]](),
                    fields: fields,
                };

                return self.generate_array_with_rep(
                    rep,
                    make[vec[struct {
                        type_: IrType,
                        term: IrTerm,
                    }]](
                        struct {
                            type_: IrType {
                                t_i32: true,
                            },
                            term: IrTerm {
                                t_i32: index,
                            },
                        },
                        struct {
                            type_: IrType::new(record_type.t_enum!.fields.at(index).data.type_),
                            term: value,
                        },
                    ),
                ).try;
            } else if record_type.t_struct != nil {
                let expansion_term = nil as IrTerm?;
                if expr.t_record!.expansion != nil {
                    expansion_term = self.expression(expr.t_record!.expansion!).try?;
                }

                let t = record_type.t_struct!;
                let fields_map = expr.t_record!.to_fields_map();

                let record = make[vec[struct {
                    label: string?,
                    type_: IrType,
                    term: IrTerm,
                }]]();
                for i in 0..t.fields.length {
                    let field = t.fields.at(i).data;
                    if fields_map.has(field.name) {
                        let value = fields_map.at(field.name);

                        record.push(struct {
                            label: field.name?,
                            type_: IrType::new(field.type_),
                            term: self.expression(value).try,
                        });
                    } else {
                        if expansion_term == nil {
                            return _ or error::new("record expansion not found");
                        }

                        record.push(struct {
                            label: field.name?,
                            type_: IrType::new(field.type_),
                            term: expansion_term!,
                        });
                    }
                }

                return self.generate_array(expr.t_record!.name, make[vec[IrType]](), record);
            } else {
                return _ or error::new(format("type is not a record: {}", expr.t_record!.name));
            }
        } else if expr.t_anonymous_record != nil {
            if expr.t_anonymous_record!.type_ == nil {
                return _ or error::new("anonymous record type not found");
            }
            if expr.t_anonymous_record!.type_!.t_struct == nil {
                return _ or error::new("anonymous record type is not a struct");
            }
            let struct_type = expr.t_anonymous_record!.type_!.t_struct!;

            let terms = make[vec[struct {
                label: string?,
                type_: IrType,
                term: IrTerm,
            }]]();

            for field in struct_type.fields {
                let field_expr = nil as LExpression?;
                for f in expr.t_anonymous_record!.fields {
                    if f.data.field == field.data.name {
                        field_expr = f.data.value?;
                        break;
                    }
                }
                if field_expr == nil {
                    return _ or error::new(format("field not found: {}", field.data.name));
                }

                let value = self.expression(field_expr!).try;
                terms.push(struct {
                    label: field.data.name?,
                    type_: IrType::new(field.data.type_),
                    term: value,
                });
            }

            return self.generate_array("struct", make[vec[IrType]](), terms).try;
        } else if expr.t_project != nil {
            if expr.t_project!.type_ == nil {
                return _ or error::new("project type is nil");
            }

            let expr_type = expr.t_project!.type_!;
            if expr_type.t_ident != nil && self.globals.has(expr_type.t_ident!) {
                let ident_type = self.globals.at(expr_type.t_ident!).data;
                if ident_type.t_enum != nil {
                    let enum_type = ident_type.t_enum!;
                    let name = "enum_{}".format(self.counter.to_string());
                    self.counter = self.counter + 1;

                    let result_name = "enum_result_{}".format(self.counter.to_string());
                    self.counter = self.counter + 1;

                    let value = self.expression(expr.t_project!.expr).try;
                    let label_index = enum_type.index(expr.t_project!.field.data);
                    let value_type = enum_type.fields.at(label_index).data.type_;

                    let enum_rep = Type {
                        t_struct: TypeStruct {
                            fields: make[vec[struct {
                                data: struct {
                                    name: string,
                                    type_: Type,
                                },
                                location: Location,
                            }]](
                                struct {
                                    data: struct {
                                        name: "tag",
                                        type_: Type {
                                            t_ident: "i32",
                                        },
                                    },
                                    location: Location::unknown(),
                                },
                                struct {
                                    data: struct {
                                        name: "value",
                                        type_: value_type,
                                    },
                                    location: Location::unknown(),
                                },
                            ),
                        },
                    };

                    let inside_value = self.generate_array_at(
                        enum_rep,
                        value,
                        IrTerm {
                            t_i32: 1,
                        },
                    ).try;

                    // let v = ${expr};
                    // let r = nil;
                    // if ${label_index} == v.tag {
                    //     r = v.value?;
                    // }
                    // r
                    return IrTerm {
                        t_seq: struct {
                            terms: make[vec[IrTerm]](
                                IrTerm {
                                    t_let: IrLet {
                                        name: name,
                                        type_: IrType::new(value_type),
                                        value: value,
                                    },
                                },
                                IrTerm {
                                    t_let: IrLet {
                                        name: result_name,
                                        type_: IrType::new(value_type),
                                        value: IrTerm {
                                            t_nil: true,
                                        },
                                    },
                                },
                                IrTerm {
                                    t_if: struct {
                                        condition: IrTerm {
                                            t_call: IrCall {
                                                callee: IrTerm {
                                                    t_ident: "equal",
                                                },
                                                args: make[vec[IrTerm]](
                                                    self.generate_array_at(
                                                        enum_rep,
                                                        value,
                                                        IrTerm {
                                                            t_i32: 0,
                                                        },
                                                    ).try,
                                                    IrTerm {
                                                        t_i32: label_index,
                                                    },
                                                ),
                                            },
                                        },
                                        then_term: IrTerm {
                                            t_assign: struct {
                                                lhs: result_name,
                                                rhs: self.generate_array(
                                                    "optional",
                                                    make[vec[IrType]](IrType::new(value_type)),
                                                    make[vec[struct {
                                                        label: string?,
                                                        type_: IrType,
                                                        term: IrTerm,
                                                    }]](struct {
                                                        label: nil,
                                                        type_: IrType::new(value_type),
                                                        term: inside_value,
                                                    }),
                                                ).try,
                                            },
                                        },
                                        else_term: IrTerm {
                                            t_seq: struct {
                                                terms: make[vec[IrTerm]](),
                                            },
                                        },
                                    },
                                },
                                IrTerm {
                                    t_ident: result_name,
                                },
                            ),
                        },
                    };
                }
            }

            let t = self.resolve_type_struct(expr.t_project!.type_!).try;
            let index = t.index(expr.t_project!.field.data);

            return self.generate_array_at(
                t.at(expr.t_project!.field.data),
                self.expression(expr.t_project!.expr).try,
                IrTerm {
                    t_i32: index,
                },
            ).try;
        } else if expr.t_make != nil {
            if expr.t_make!.type_.t_ptr != nil {
                if expr.t_make!.args.length != 1 {
                    panic("ptr make expects 1 argument");
                }

                let len = self.expression(expr.t_make!.args.at(0)).try;
                let ptr_type = expr.t_make!.type_.t_ptr!;

                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_alloc",
                        },
                        args: make[vec[IrTerm]](
                            IrCodeGenerator::wrap_mult_sizeof(IrType::new(ptr_type), len),
                        ),
                    },
                };
            } else if expr.t_make!.type_.t_vec != nil {
                let var_vec = format("vec_{}", self.counter.to_string());
                self.counter = self.counter + 1;

                let terms = make[vec[IrTerm]]();
                terms.push(IrTerm {
                    t_let: IrLet {
                        name: var_vec,
                        type_: IrType::new(expr.t_make!.type_),
                        value: IrTerm {
                            t_call: IrCall {
                                callee: IrTerm {
                                    t_ident: "quartz_std_vec_make",
                                },
                                args: make[vec[IrTerm]](IrTerm {
                                    t_i32: 5,
                                }),
                            },
                        },
                    },
                });
                for arg in expr.t_make!.args {
                    terms.push(IrTerm {
                        t_discard: IrTerm {
                            t_call: IrCall {
                                callee: IrTerm {
                                    t_ident: "quartz_std_vec_push",
                                },
                                args: make[vec[IrTerm]](
                                    IrTerm {
                                        t_ident: var_vec,
                                    },
                                    self.expression(arg).try,
                                ),
                            },
                        },
                    });
                }
                terms.push(IrTerm {
                    t_ident: var_vec,
                });

                return IrTerm {
                    t_seq: struct {
                        terms: terms,
                    },
                };
            } else if expr.t_make!.type_.t_map != nil {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_map_make",
                        },
                        args: make[vec[IrTerm]](),
                    },
                };
            } else {
                return _ or error::new(
                    "make() expects a pointer or vector type, {}".format(expr.t_make!.type_.to_string()),
                );
            }
        } else if expr.t_path != nil {
            if expr.t_path!.resolved_path == nil {
                return _ or error::new("unresolved path, {}".format(expr.t_path!.path.join("_")));
            }

            return IrTerm {
                t_ident: expr.t_path!.resolved_path!.join("_"),
            };
        } else if expr.t_self != nil {
            return IrTerm {
                t_ident: "self",
            };
        } else if expr.t_as != nil {
            let term = self.expression(expr.t_as!.expr).try;
            let source = IrType::new(expr.t_as!.source_type);
            let target = IrType::new(expr.t_as!.target_type);

            if (source.t_i32 != nil) && (target.t_i32 != nil) {
                return term;
            } else if (source.t_address != nil) && (target.t_address != nil) {
                return term;
            } else if (source.t_byte != nil) && (target.t_byte != nil) {
                return term;
            } else if (source.t_i32 != nil) && (target.t_address != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "i32_to_address",
                        },
                        args: make[vec[IrTerm]](term),
                    },
                };
            } else if (source.t_i32 != nil) && (target.t_byte != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "i32_to_byte",
                        },
                        args: make[vec[IrTerm]](term),
                    },
                };
            } else if (source.t_byte != nil) && (target.t_i32 != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "byte_to_i32",
                        },
                        args: make[vec[IrTerm]](term),
                    },
                };
            } else if (source.t_address != nil) && (target.t_i32 != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "address_to_i32",
                        },
                        args: make[vec[IrTerm]](term),
                    },
                };
            } else if target.t_any != nil {
                return term;
            } else if source.t_any != nil {
                return term;
            } else if source.t_i32 != nil && target.t_i64 != nil {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_i32_to_i64",
                        },
                        args: make[vec[IrTerm]](term),
                    },
                };
            }

            return _ or error::new(format("cannot cast {} to {}", source.to_string(), target.to_string()));
        } else if expr.t_string != nil {
            return self.register_string(expr.t_string!.value);
        } else if expr.t_paren != nil {
            return self.expression(expr.t_paren!).try;
        } else if expr.t_wrap != nil {
            let term = self.expression(expr.t_wrap!.expr).try;

            return self.generate_array(
                "optional",
                make[vec[IrType]](IrType::new(expr.t_wrap!.type_)),
                make[vec[struct {
                    label: string?,
                    type_: IrType,
                    term: IrTerm,
                }]](struct {
                    label: nil,
                    type_: IrType::new(expr.t_wrap!.type_),
                    term: term,
                }),
            );
        } else if expr.t_unwrap != nil {
            let term = self.expression(expr.t_unwrap!.expr).try;

            return self.generate_array_at(
                expr.t_unwrap!.type_,
                term,
                IrTerm {
                    t_i32: 0,
                },
            ).try;
        } else if expr.t_bool != nil {
            return IrTerm {
                t_bool: expr.t_bool!,
            };
        } else if expr.t_nil != nil {
            return IrTerm {
                t_nil: true,
            };
        } else if expr.t_enumor != nil {
            let lhs_term = IrTerm {
                t_nil: true,
            };
            if expr.t_enumor!.lhs != nil {
                lhs_term = self.generate_array(
                    "optional",
                    make[vec[IrType]](IrType::new(expr.t_enumor!.lhs_type)),
                    make[vec[struct {
                        label: string?,
                        type_: IrType,
                        term: IrTerm,
                    }]](struct {
                        label: nil,
                        type_: IrType::new(expr.t_enumor!.lhs_type),
                        term: self.expression(expr.t_enumor!.lhs!).try,
                    }),
                ).try;
            }

            let rhs_term = IrTerm {
                t_nil: true,
            };
            if expr.t_enumor!.rhs != nil {
                rhs_term = self.generate_array(
                    "optional",
                    make[vec[IrType]](IrType::new(expr.t_enumor!.rhs_type)),
                    make[vec[struct {
                        label: string?,
                        type_: IrType,
                        term: IrTerm,
                    }]](struct {
                        label: nil,
                        type_: IrType::new(expr.t_enumor!.rhs_type),
                        term: self.expression(expr.t_enumor!.rhs!).try,
                    }),
                ).try;
            }

            return self.generate_array(
                "or",
                make[vec[IrType]](IrType::new(expr.t_enumor!.lhs_type), IrType::new(expr.t_enumor!.rhs_type)),
                make[vec[struct {
                    label: string?,
                    type_: IrType,
                    term: IrTerm,
                }]](
                    struct {
                        label: "left"?,
                        type_: IrType {
                            t_address: true,
                        },
                        term: lhs_term,
                    },
                    struct {
                        label: "right"?,
                        type_: IrType {
                            t_address: true,
                        },
                        term: rhs_term,
                    },
                ),
            ).try;
        } else if expr.t_sizeof != nil {
            return IrTerm {
                t_sizeof: struct {
                    type_: IrType::new(expr.t_sizeof!.type_),
                },
            };
        } else if expr.t_unop != nil {
            if expr.t_unop!.unop != "not" {
                return panic("unop not implemented: {}", expr.to_string());
            }

            let term = self.expression(expr.t_unop!.expr).try;

            return IrTerm {
                t_call: IrCall {
                    callee: IrTerm {
                        t_ident: "not",
                    },
                    args: make[vec[IrTerm]](term),
                },
            };
        } else if expr.t_try != nil {
            // expr.try
            // --> let try = expr;
            //     if try.right != nil { return _ or right }
            //     try.left!
            let var_name = format("try_{}", self.counter.to_string());
            self.counter = self.counter + 1;

            let left = self.generate_array_at(
                Type {
                    t_optional: Type {
                        t_any: true,
                    },
                },
                IrTerm {
                    t_ident: var_name,
                },
                IrTerm {
                    t_i32: 0,
                },
            ).try;
            let right = self.generate_array_at(
                Type {
                    t_optional: Type {
                        t_any: true,
                    },
                },
                IrTerm {
                    t_ident: var_name,
                },
                IrTerm {
                    t_i32: 1,
                },
            ).try;

            let right_name = format("try_{}_right", self.counter.to_string());

            let elements = make[vec[IrTerm]]();
            elements.push(IrTerm {
                t_let: IrLet {
                    name: var_name,
                    type_: IrType {
                        t_address: true,
                    },
                    value: self.expression(expr.t_try!).try,
                },
            });
            elements.push(IrTerm {
                t_let: IrLet {
                    name: right_name,
                    type_: IrType {
                        t_address: true,
                    },
                    value: right,
                },
            });
            elements.push(IrTerm {
                t_if: struct {
                    condition: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "not_equal",
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: right_name,
                                },
                                IrTerm {
                                    t_nil: true,
                                },
                            ),
                        },
                    },
                    then_term: IrTerm {
                        t_return: IrReturn {
                            value: self.generate_array(
                                "or",
                                make[vec[IrType]](
                                    IrType {
                                        t_address: true,
                                    },
                                    IrType {
                                        t_address: true,
                                    },
                                ),
                                make[vec[struct {
                                    label: string?,
                                    type_: IrType,
                                    term: IrTerm,
                                }]](
                                    struct {
                                        label: "left"?,
                                        type_: IrType {
                                            t_address: true,
                                        },
                                        term: IrTerm {
                                            t_nil: true,
                                        },
                                    },
                                    struct {
                                        label: "right"?,
                                        type_: IrType {
                                            t_address: true,
                                        },
                                        term: IrTerm {
                                            t_ident: right_name,
                                        },
                                    },
                                ),
                            ).try,
                        },
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: make[vec[IrTerm]](),
                        },
                    },
                },
            });
            elements.push(self.generate_array_at(
                Type {
                    t_ptr: Type {
                        t_omit: true,
                    },
                },
                left,
                IrTerm {
                    t_i32: 0,
                },
            ).try);

            return IrTerm {
                t_seq: struct {
                    terms: elements,
                },
            };
        }

        return panic("expression exhausted: {}", expr.to_string());
    }

    fun register_string(self, str: string): IrTerm {
        let index = self.strings.get_or_insert(str);

        return IrTerm {
            t_string: index,
        };
    }

    fun generate_array(
        self,
        rep_name: string,
        params: vec[IrType],
        terms: vec[struct {
            label: string?,
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm or error {
        let rep_fields = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..terms.length {
            let term = terms.at(i);

            if term.label != nil {
                rep_fields.push(struct {
                    name: term.label!,
                    type_: term.type_,
                });
            } else {
                rep_fields.push(struct {
                    name: format("{}", i.to_string()),
                    type_: term.type_,
                });
            }
        }
        let rep = InternalTypeRep::from_struct(rep_name, params, rep_fields);

        let terms_new = make[vec[struct {
            type_: IrType,
            term: IrTerm,
        }]]();
        for term in terms {
            terms_new.push(struct {
                type_: term.type_,
                term: term.term,
            });
        }

        return self.generate_array_with_rep(rep, terms_new).try;
    }

    fun generate_array_with_rep(
        self,
        rep: InternalTypeRep,
        terms: vec[struct {
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm or error {
        // generates:
        //
        // let array_x = alloc(10);
        // for i in elements {
        //     array_x.at(i) = elements.at(i);
        // }
        // array_x
        let var_name = format("arr_{}_{}", rep.name, self.counter.to_string());
        self.counter = self.counter + 1;

        let arr = make[vec[IrTerm]]();
        arr.push(IrTerm {
            t_let: IrLet {
                name: var_name,
                type_: IrType {
                    t_address: true,
                },
                value: self.allocate_heap_object(
                    rep,
                    IrType {
                        t_address: true,
                    },
                    IrTerm {
                        t_i32: terms.length,
                    },
                ).try,
            },
        });

        for i in 0..terms.length {
            let term = terms.at(i);
            let element = IrTerm {
                t_store: struct {
                    type_: term.type_,
                    address: IrTerm::ident(var_name),
                    offset: IrCodeGenerator::wrap_mult_sizeof(
                        IrType {
                            t_i32: true,
                        },
                        IrTerm {
                            t_i32: i,
                        },
                    ),
                    value: term.term,
                    raw_offset: 8,
                },
            };

            arr.push(element);
        }

        arr.push(IrTerm {
            t_ident: var_name,
        });

        return IrTerm {
            t_seq: struct {
                terms: arr,
            },
        };
    }

    fun allocate_heap_object(self, rep: InternalTypeRep, type_: IrType, size: IrTerm): IrTerm or error {
        let rep_id = self.type_reps.get_or_insert(rep);
        let var = "object_{}".format(self.counter.to_string());
        self.counter = self.counter + 1;

        let object = make[vec[IrTerm]]();

        object.push(IrTerm {
            t_let: IrLet {
                name: var,
                type_: IrType {
                    t_address: true,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_alloc",
                        },
                        args: make[vec[IrTerm]](IrTerm {
                            t_call: IrCall {
                                callee: IrTerm {
                                    t_ident: "add",
                                },
                                args: make[vec[IrTerm]](
                                    IrCodeGenerator::wrap_mult_sizeof(type_, size),
                                    IrTerm {
                                        t_i32: 8,
                                    },
                                ),
                            },
                        }),
                    },
                },
            },
        });
        // object header
        object.push(IrTerm {
            t_store: struct {
                type_: IrType {
                    t_i32: true,
                },
                address: IrTerm::ident(var),
                offset: IrTerm::i32(0),
                value: IrTerm {
                    t_type_rep: rep_id,
                },
                raw_offset: 0,
            },
        });
        object.push(IrTerm {
            t_ident: var,
        });

        return IrTerm {
            t_seq: struct {
                terms: object,
            },
        };
    }

    fun write_type_rep(self, rep: InternalTypeRep): IrTerm or error {
        // [nil, kind, rep_name, size of params, *params, size of fields, *fields]
        let elements = make[vec[IrTerm]]();
        elements.push(IrTerm {
            t_nil: true,
        });
        elements.push(IrTerm::i32(rep.kind));
        elements.push(self.register_string(rep.name));
        elements.push(IrTerm::i32(rep.params.length));

        let type_rep_terms = make[vec[struct {
            label: string?,
            type_: IrType,
            term: IrTerm,
        }]]();
        for p in rep.params {
            type_rep_terms.push(struct {
                label: nil,
                type_: IrType {
                    t_address: true,
                },
                term: self.write_type_rep(p).try,
            });
        }
        elements.push(self.generate_array("slice", make[vec[IrType]](), type_rep_terms).try);
        elements.push(IrTerm::i32(rep.fields.length));

        let field_terms = make[vec[struct {
            label: string?,
            type_: IrType,
            term: IrTerm,
        }]]();
        for t in rep.fields {
            field_terms.push(struct {
                label: t.name?,
                type_: IrType {
                    t_address: true,
                },
                term: self.register_string(t.name),
            });
        }
        elements.push(self.generate_array("slice", make[vec[IrType]](), field_terms).try);

        let var_name = format("type_rep_{}", self.counter.to_string());
        self.counter = self.counter + 1;

        let arr = make[vec[IrTerm]]();
        arr.push(IrTerm {
            t_let: IrLet {
                name: var_name,
                type_: IrType {
                    t_address: true,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_alloc",
                        },
                        args: make[vec[IrTerm]](IrCodeGenerator::wrap_mult_sizeof(
                            IrType {
                                t_any: true,
                            },
                            IrTerm::i32(elements.length),
                        )),
                    },
                },
            },
        });
        for index in 0..elements.length {
            arr.push(IrTerm {
                t_store: struct {
                    type_: IrType {
                        t_any: true,
                    },
                    address: IrTerm {
                        t_ident: var_name,
                    },
                    offset: IrCodeGenerator::wrap_mult_sizeof(
                        IrType {
                            t_i32: true,
                        },
                        IrTerm {
                            t_i32: index,
                        },
                    ),
                    value: elements.at(index),
                    raw_offset: 0,
                },
            });
        }

        arr.push(IrTerm {
            t_ident: var_name,
        });

        return IrTerm {
            t_seq: struct {
                terms: arr,
            },
        };
    }

    fun wrap_mult_sizeof(ir_type: IrType, term: IrTerm): IrTerm {
        let args = make[vec[IrTerm]]();
        args.push(term);
        args.push(IrTerm {
            t_sizeof: struct {
                type_: ir_type,
            },
        });

        return IrTerm {
            t_call: IrCall {
                callee: IrTerm {
                    t_ident: "mult",
                },
                args: args,
            },
        };
    }

    fun generate_array_at(self, elem_type: Type, arr: IrTerm, index: IrTerm): IrTerm or error {
        return IrTerm {
            t_load: struct {
                type_: IrType::new(elem_type),
                address: arr,
                offset: IrCodeGenerator::wrap_mult_sizeof(IrType::new(elem_type), index),
                raw_offset: 8,
            },
        };
    }

    fun resolve_type_struct(self, t: Type): TypeStruct or error {
        if t.t_ident != nil {
            let ident = t.t_ident!;

            if self.globals.has(ident) {
                return self.resolve_type_struct(self.globals.at(ident).data);
            } else {
                return _ or error::new(format("unknown symbol: {}", ident));
            }
        } else if t.t_struct != nil {
            return t.t_struct!;
        } else if t.t_vec != nil {
            return self.resolve_type_struct(Type {
                t_ident: "vec",
            });
        } else if t.t_map != nil {
            return self.resolve_type_struct(Type {
                t_ident: "quartz_std_Map",
            });
        } else {
            return _ or error::new(format("type is not a struct: {}", t.to_string()));
        }
    }

    fun assign(self, lhs: IrTerm, rhs_type: IrType, rhs: IrTerm): IrTerm or error {
        if lhs.t_ident != nil {
            let term = IrTerm {
                t_assign: struct {
                    lhs: lhs.t_ident!,
                    rhs: rhs,
                },
            };

            return term;
        } else if lhs.t_load != nil {
            let term = IrTerm {
                t_store: struct {
                    type_: lhs.t_load!.type_,
                    address: lhs.t_load!.address,
                    offset: lhs.t_load!.offset,
                    value: rhs,
                    raw_offset: lhs.t_load!.raw_offset,
                },
            };

            return term;
        } else if lhs.t_call != nil {
            return IrTerm {
                t_store: struct {
                    type_: rhs_type,
                    address: lhs,
                    offset: IrTerm::i32(0),
                    value: rhs,
                    raw_offset: 8,
                },
            };
        }

        return panic("lhs: {}, rhs: {}", lhs.to_string(), rhs.to_string());
    }

    fun generate_call(
        self,
        callee: LExpression,
        args: vec[LExpression],
        variadic: struct {
            element_type: Type,
            index: i32,
        }?,
        expansion: LExpression?,
    ): IrTerm or error {
        if variadic != nil {
            let terms = make[vec[IrTerm]]();
            for arg in args.slice(0, variadic!.index) {
                terms.push(self.expression(arg).try);
            }

            // for uniqueness
            let vec_name = format("vec_generate_call_{}", self.counter.to_string());
            self.counter = self.counter + 1;

            let variadic_terms = make[vec[IrTerm]](IrTerm {
                t_let: IrLet {
                    name: vec_name,
                    type_: IrType::new(Type {
                        t_vec: variadic!.element_type,
                    }),
                    value: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_make",
                            },
                            args: make[vec[IrTerm]](IrTerm {
                                t_i32: 1,
                            }),
                        },
                    },
                },
            });
            for arg in args.slice(variadic!.index, args.length) {
                variadic_terms.push(IrTerm {
                    t_discard: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_push",
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: vec_name,
                                },
                                self.expression(arg).try,
                            ),
                        },
                    },
                });
            }
            if expansion != nil {
                variadic_terms.push(IrTerm {
                    t_discard: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_extend",
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: vec_name,
                                },
                                self.expression(expansion!).try,
                            ),
                        },
                    },
                });
            }

            variadic_terms.push(IrTerm {
                t_ident: vec_name,
            });

            terms.push(IrTerm {
                t_seq: struct {
                    terms: variadic_terms,
                },
            });

            return IrTerm {
                t_call: IrCall {
                    callee: self.expression(callee).try,
                    args: terms,
                },
            };
        } else {
            let terms = make[vec[IrTerm]]();
            for arg in args {
                terms.push(self.expression(arg).try);
            }

            return IrTerm {
                t_call: IrCall {
                    callee: self.expression(callee).try,
                    args: terms,
                },
            };
        }
    }
}

