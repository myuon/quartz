import quartz::ast;
import quartz::ir;
import quartz::path;

struct InternalTypeRep {
    name: string,
    params: vec[InternalTypeRep],
    fields: vec[struct {
        name: string,
        type_: InternalTypeRep,
    }],
}

module InternalTypeRep {
    fun from_name(name: string, params: vec[InternalTypeRep]): InternalTypeRep {
        return InternalTypeRep {
            name: name,
            params: params,
            fields: make[vec[struct {
                name: string,
                type_: InternalTypeRep,
            }]](),
        };
    }

    fun from_struct(
        name: string,
        params: vec[IrType],
        fields: vec[struct {
            name: string,
            type_: IrType,
        }],
    ): InternalTypeRep {
        let params_t = make[vec[InternalTypeRep]]();
        for p in params {
            params_t.push(InternalTypeRep::from_ir_type(p));
        }

        let fields_t = make[vec[struct {
            name: string,
            type_: InternalTypeRep,
        }]]();
        for f in fields {
            fields_t.push(struct {
                name: f.name,
                type_: InternalTypeRep::from_ir_type(f.type_),
            });
        }

        return InternalTypeRep {
            name: name,
            params: params_t,
            fields: fields_t,
        };
    }

    fun from_ir_type(t: IrType): InternalTypeRep {
        if t.t_nil != nil {
            return InternalTypeRep::from_name("nil", make[vec[InternalTypeRep]]());
        } else if t.t_i32 != nil {
            return InternalTypeRep::from_name("i32", make[vec[InternalTypeRep]]());
        } else if t.t_address != nil {
            return InternalTypeRep::from_name("address", make[vec[InternalTypeRep]]());
        } else if t.t_byte != nil {
            return InternalTypeRep::from_name("byte", make[vec[InternalTypeRep]]());
        } else if t.t_any != nil {
            return InternalTypeRep::from_name("any", make[vec[InternalTypeRep]]());
        }

        return panic("unreachable, {}".format(t.to_string()));
    }
}

struct StringTable {
    strings: vec[string],
}

module StringTable {
    fun new(): StringTable {
        return StringTable {
            strings: make[vec[string]](),
        };
    }

    fun get_or_insert(self, key: string): i32 {
        for i in 0..self.strings.length {
            if self.strings.at(i).equal(key) {
                return i as i32;
            }
        }

        self.strings.push(key);

        return (self.strings.length - 1) as i32;
    }
}

struct TypeRepTable {
    type_reps: vec[InternalTypeRep],
}

module TypeRepTable {
    fun new(): TypeRepTable {
        return TypeRepTable {
            type_reps: make[vec[InternalTypeRep]](),
        };
    }

    fun get_or_insert(self, key: InternalTypeRep): i32 {
        for i in 0..self.type_reps.length {
            if self.type_reps.at(i).name.equal(key.name) {
                return i as i32;
            }
        }

        self.type_reps.push(key);

        return (self.type_reps.length - 1) as i32;
    }
}

struct IrCodeGenerator {
    globals: map[string, Type],
    locals: map[string, bool],
    current_path: Path,
    strings: StringTable,
    type_reps: TypeRepTable,
    data_section_offset: i32,
    counter: i32,
}

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
            globals: make[map[string, Type]](),
            locals: make[map[string, bool]](),
            current_path: Path::new(),
            strings: StringTable::new(),
            type_reps: TypeRepTable::new(),
            data_section_offset: 0,
            counter: 0,
        };
    }

    fun run(self, m: Module): IrTerm or error {
        let decls = self.module_(m).try;
        decls.push(self.generate_prepare_type_reps().try);
        decls.extend(self.generate_prepare_strings().try);
        decls.push(IrTerm {
            t_func: IrFunc {
                name: "reflection_get_type_rep_id",
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](struct {
                    name: "p",
                    type_: IrType {
                        t_address: true?,
                        ..nil,
                    },
                }),
                result_type: IrType {
                    t_address: true?,
                    ..nil,
                },
                body: make[vec[IrTerm]](IrTerm {
                    t_return: IrReturn {
                        value: IrTerm {
                            t_i32: 0?,
                            ..nil,
                        },
                    }?,
                    ..nil,
                }),
            }?,
            ..nil,
        });

        return IrTerm {
            t_module: struct {
                elements: decls,
            }?,
            ..nil,
        };
    }

    fun module_(self, m: Module): vec[IrTerm] or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..m.decls.length {
            let d = m.decls.at(i);

            if d.t_func != nil {
                elements.push(IrTerm {
                    t_func: self.function(d.t_func!).try?,
                    ..nil,
                });
            }
            if d.t_let != nil {
                elements.push(IrTerm {
                    t_global_let: struct {
                        name: self.path_to(d.t_let!.name),
                        type_: IrType {
                            t_i32: true?,
                            ..nil,
                        },
                        value: self.expression(d.t_let!.expr).try,
                    }?,
                    ..nil,
                });
            }
            if d.t_type != nil {
            }
            if d.t_module != nil {
                let path = self.current_path.clone();
                self.current_path.extend(d.t_module!.path);
                elements.extend(self.module_(d.t_module!.module_).try);
                self.current_path = path;
            }
        }

        return elements;
    }

    fun generate_prepare_type_reps(self): IrTerm or error {
        let var_ptr = "quartz_std_type_reps_ptr";

        let rep_ids = make[vec[struct {
            rep: InternalTypeRep,
            id: i32,
        }]]();
        let rep_id_counter = 0;
        for rep in self.type_reps.type_reps {
            rep_ids.push(struct {
                rep: rep,
                id: rep_id_counter,
            });
            rep_id_counter = rep_id_counter + 1;
        }

        let body = make[vec[IrTerm]]();
        // quartz_std_type_reps_ptr = make[ptr[any]](${type_reps.len()});
        body.push(IrTerm {
            t_assign: struct {
                lhs: var_ptr,
                rhs: self.expression(Expression {
                    t_make: struct {
                        type_: Type {
                            t_ptr: Type {
                                t_ident: "any"?,
                                ..nil,
                            }?,
                            ..nil,
                        },
                        args: make[vec[Expression]](Expression {
                            t_i32: struct {
                                value: self.type_reps.type_reps.length,
                            }?,
                            ..nil,
                        }),
                    }?,
                    ..nil,
                }).try,
            }?,
            ..nil,
        });

        for t in rep_ids {
            let type_rep = t.rep;
            let rep_id = t.id;
            let var_p = "p";

            // let p = write_type_rep(${rep});
            body.push(IrTerm {
                t_let: IrLet {
                    name: var_p,
                    type_: IrType {
                        t_i32: true?,
                        ..nil,
                    },
                    value: self.write_type_rep(type_rep).try,
                }?,
                ..nil,
            });

            // quartz_std_type_reps_ptr.at(${rep_id}) = p
            let lhs = self.generate_array_at(
                Type {
                    t_ptr: Type {
                        t_ident: "any"?,
                        ..nil,
                    }?,
                    ..nil,
                },
                IrTerm {
                    t_ident: var_ptr?,
                    ..nil,
                },
                IrTerm {
                    t_i32: rep_id?,
                    ..nil,
                },
            ).try;
            body.push(self.assign(
                lhs,
                IrTerm {
                    t_ident: var_p?,
                    ..nil,
                },
            ).try);
        }

        body.push(IrTerm {
            t_return: IrReturn {
                value: IrTerm {
                    t_nil: true?,
                    ..nil,
                },
            }?,
            ..nil,
        });

        return IrTerm {
            t_func: IrFunc {
                name: "prepare_type_reps",
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](),
                result_type: IrType {
                    t_nil: true?,
                    ..nil,
                },
                body: body,
            }?,
            ..nil,
        };
    }

    fun generate_prepare_strings(self): vec[IrTerm] or error {
        let terms = make[vec[IrTerm]]();

        let var_strings = "quartz_std_strings_ptr";
        let body = make[vec[IrTerm]]();
        body.push(IrTerm {
            t_assign: struct {
                lhs: var_strings,
                rhs: self.expression(Expression {
                    t_make: struct {
                        type_: Type {
                            t_ptr: Type {
                                t_ident: "string"?,
                                ..nil,
                            }?,
                            ..nil,
                        },
                        args: make[vec[Expression]](Expression {
                            t_i32: struct {
                                value: self.strings.strings.length,
                            }?,
                            ..nil,
                        }),
                    }?,
                    ..nil,
                }).try,
            }?,
            ..nil,
        });

        // avoid 0-8 for null pointer
        self.data_section_offset = 8;

        for i in 0..self.strings.strings.length {
            let str = self.strings.strings.at(i);
            let str_len = str.length;
            let str_memory_size = str_len + 8;

            let new_str = "\00\00\00\00\00\00\00\00".concat(str);
            terms.push(IrTerm {
                t_data: struct {
                    data: new_str,
                    offset: self.data_section_offset,
                }?,
                ..nil,
            });

            let lhs = self.generate_array_at(
                Type::string(),
                IrTerm {
                    t_ident: var_strings?,
                    ..nil,
                },
                IrTerm {
                    t_i32: i?,
                    ..nil,
                },
            ).try;
            body.push(self.assign(
                lhs,
                IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_new_string"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](
                            IrTerm {
                                t_i32: self.data_section_offset?,
                                ..nil,
                            },
                            IrTerm {
                                t_i32: str_len?,
                                ..nil,
                            },
                        ),
                    }?,
                    ..nil,
                },
            ).try);

            self.data_section_offset = self.data_section_offset + str_memory_size;
        }

        body.push(IrTerm {
            t_return: IrReturn {
                value: IrTerm {
                    t_nil: true?,
                    ..nil,
                },
            }?,
            ..nil,
        });

        terms.push(IrTerm {
            t_func: IrFunc {
                name: "prepare_strings".to_string(),
                params: make[vec[struct {
                    name: string,
                    type_: IrType,
                }]](),
                body: body,
                result_type: IrType {
                    t_nil: true?,
                    ..nil,
                },
            }?,
            ..nil,
        });

        return terms;
    }

    fun function(self, func: Function): IrFunc or error {
        self.locals = make[map[string, bool]]();
        let body = self.block(func.body).try;

        let params = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..func.params.length {
            let p = func.params.at(i);

            if p.name.equal("self") {
                params.push(struct {
                    name: p.name,
                    type_: IrType::new(Type {
                        t_ident: self.current_path.path.at(0)?,
                        ..nil,
                    }),
                });
            } else {
                params.push(struct {
                    name: p.name,
                    type_: IrType::new(p.type_),
                });
            }
        }
        if func.variadic != nil {
            params.push(struct {
                name: func.variadic!.name,
                type_: IrType::new(func.variadic!.type_),
            });
        }

        return IrFunc {
            name: self.path_to(func.name),
            params: params,
            body: body,
            result_type: IrType::new(func.result_type),
        };
    }

    fun path_to(self, s: string): string {
        return self.current_path.join("_").concat("_").concat(s);
    }

    fun block(self, b: Block): vec[IrTerm] or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..b.block.length {
            elements.push(self.statement(b.block.at(i)).try);
        }

        return elements;
    }

    fun statement(self, stm: Statement): IrTerm or error {
        if stm.t_let != nil {
            if stm.t_let!.pattern.t_ident != nil {
                let name = stm.t_let!.pattern.t_ident!;

                let term = IrTerm {
                    t_let: IrLet {
                        name: name,
                        type_: IrType {
                            t_i32: true?,
                            ..nil,
                        },
                        value: self.expression(stm.t_let!.expr).try,
                    }?,
                    ..nil,
                };
                self.locals.insert(name, true);

                return term;
            } else if stm.t_let!.pattern.t_or != nil {
                let lhs = stm.t_let!.pattern.t_or!.lhs.t_ident!;
                let rhs = stm.t_let!.pattern.t_or!.rhs.t_ident!;

                let var_name = format("or_{}", self.counter.to_string());
                self.counter = self.counter + 1;

                return IrTerm {
                    t_seq: struct {
                        terms: make[vec[IrTerm]](
                            IrTerm {
                                t_let: IrLet {
                                    name: var_name,
                                    type_: IrType::new(stm.t_let!.name_type),
                                    value: self.expression(stm.t_let!.expr).try,
                                }?,
                                ..nil,
                            },
                            IrTerm {
                                t_let: IrLet {
                                    name: lhs,
                                    type_: IrType {
                                        t_address: true?,
                                        ..nil,
                                    },
                                    value: self.generate_array_at(
                                        stm.t_let!.name_type,
                                        IrTerm {
                                            t_ident: var_name?,
                                            ..nil,
                                        },
                                        IrTerm {
                                            t_i32: 0?,
                                            ..nil,
                                        },
                                    ).try,
                                }?,
                                ..nil,
                            },
                            IrTerm {
                                t_let: IrLet {
                                    name: rhs,
                                    type_: IrType {
                                        t_address: true?,
                                        ..nil,
                                    },
                                    value: self.generate_array_at(
                                        stm.t_let!.name_type,
                                        IrTerm {
                                            t_ident: var_name?,
                                            ..nil,
                                        },
                                        IrTerm {
                                            t_i32: 1?,
                                            ..nil,
                                        },
                                    ).try,
                                }?,
                                ..nil,
                            },
                        ),
                    }?,
                    ..nil,
                };
            }
        } else if stm.t_return != nil {
            let term = IrTerm {
                t_return: IrReturn {
                    value: self.expression(stm.t_return!.expr).try,
                }?,
                ..nil,
            };

            return term;
        } else if stm.t_expr != nil {
            return IrTerm {
                t_discard: self.expression(stm.t_expr!.expr).try?,
                ..nil,
            };
        } else if stm.t_assign != nil {
            let lhs = self.expression(stm.t_assign!.lhs).try;
            let rhs = self.expression(stm.t_assign!.rhs).try;

            return self.assign(lhs, rhs).try;
        } else if stm.t_if != nil {
            let then_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_if!.then_block.block.length {
                then_elements.push(self.statement(stm.t_if!.then_block.block.at(i)).try);
            }

            let else_elements = make[vec[IrTerm]]();
            if stm.t_if!.else_block != nil {
                for i in 0..stm.t_if!.else_block!.block.length {
                    else_elements.push(self.statement(stm.t_if!.else_block!.block.at(i)).try);
                }
            }

            return IrTerm {
                t_if: struct {
                    condition: self.expression(stm.t_if!.condition).try,
                    then_term: IrTerm {
                        t_seq: struct {
                            terms: then_elements,
                        }?,
                        ..nil,
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: else_elements,
                        }?,
                        ..nil,
                    },
                }?,
                ..nil,
            };
        } else if stm.t_while != nil {
            let body_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_while!.block.block.length {
                body_elements.push(self.statement(stm.t_while!.block.block.at(i)).try);
            }

            return IrTerm {
                t_while: struct {
                    condition: self.expression(stm.t_while!.condition).try,
                    block: IrTerm {
                        t_seq: struct {
                            terms: body_elements,
                        }?,
                        ..nil,
                    },
                    cleanup: nil as IrTerm?,
                }?,
                ..nil,
            };
        } else if stm.t_for != nil {
            if stm.t_for!.range.t_range != nil {
                let range = stm.t_for!.range.t_range!;

                return IrTerm {
                    t_seq: struct {
                        terms: make[vec[IrTerm]](
                            IrTerm {
                                t_let: IrLet {
                                    name: stm.t_for!.ident,
                                    type_: IrType {
                                        t_i32: true?,
                                        ..nil,
                                    },
                                    value: self.expression(range.start).try,
                                }?,
                                ..nil,
                            },
                            IrTerm {
                                t_while: struct {
                                    condition: IrTerm {
                                        t_call: IrCall {
                                            callee: IrTerm {
                                                t_ident: "lt"?,
                                                ..nil,
                                            },
                                            args: make[vec[IrTerm]](
                                                IrTerm {
                                                    t_ident: stm.t_for!.ident?,
                                                    ..nil,
                                                },
                                                self.expression(range.end).try,
                                            ),
                                        }?,
                                        ..nil,
                                    },
                                    block: IrTerm {
                                        t_seq: struct {
                                            terms: self.block(stm.t_for!.block).try,
                                        }?,
                                        ..nil,
                                    },
                                    cleanup: IrTerm {
                                        t_assign: struct {
                                            lhs: stm.t_for!.ident,
                                            rhs: IrTerm {
                                                t_call: IrCall {
                                                    callee: IrTerm {
                                                        t_ident: "add"?,
                                                        ..nil,
                                                    },
                                                    args: make[vec[IrTerm]](
                                                        IrTerm {
                                                            t_ident: stm.t_for!.ident?,
                                                            ..nil,
                                                        },
                                                        IrTerm {
                                                            t_i32: 1?,
                                                            ..nil,
                                                        },
                                                    ),
                                                }?,
                                                ..nil,
                                            },
                                        }?,
                                        ..nil,
                                    }?,
                                }?,
                                ..nil,
                            },
                        ),
                    }?,
                    ..nil,
                };
            } else {
                return _ or error::new(format("unsupported for loop: {}", stm.to_string()));
            }
        } else if stm.t_continue != nil {
            return IrTerm {
                t_continue: true?,
                ..nil,
            };
        } else if stm.t_break != nil {
            return IrTerm {
                t_break: true?,
                ..nil,
            };
        }

        return _ or error::new(format("statement exhausted: {}", stm.to_string()));
    }

    fun expression(self, expr: Expression): IrTerm or error {
        if expr.t_i32 != nil {
            let term = IrTerm {
                t_i32: expr.t_i32!.value?,
                ..nil,
            };

            return term;
        } else if expr.t_u32 != nil {
            let term = IrTerm {
                t_u32: expr.t_u32!.value?,
                ..nil,
            };

            return term;
        } else if expr.t_binop != nil {
            let args = make[vec[IrTerm]]();
            args.push(self.expression(expr.t_binop!.left).try);
            args.push(self.expression(expr.t_binop!.right).try);

            if expr.t_binop!.binop.equal("plus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "add"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("minus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "sub"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("mult") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "mult"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("div") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "div"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("mod") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "mod"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "equal"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("not_equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "not_equal"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("lt") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "lt"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("gt") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "gt"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("lte") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "lte"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("gte") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "gte"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("and") {
                return IrTerm {
                    t_and: struct {
                        lhs: self.expression(expr.t_binop!.left).try,
                        rhs: self.expression(expr.t_binop!.right).try,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("or") {
                return IrTerm {
                    t_or: struct {
                        lhs: self.expression(expr.t_binop!.left).try,
                        rhs: self.expression(expr.t_binop!.right).try,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("bit_and") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "bit_and"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("bit_or") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "bit_or"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("bit_shift_left") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "bit_shift_left"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            } else if expr.t_binop!.binop.equal("bit_shift_right") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "bit_shift_right"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }

            panic("binop exhausted: ".concat(expr.t_binop!.binop));
        } else if expr.t_ident != nil {
            if expr.t_ident!.resolved_path != nil {
                return IrTerm {
                    t_ident: expr.t_ident!.resolved_path!.join("_")?,
                    ..nil,
                };
            }

            return IrTerm {
                t_ident: expr.t_ident!.name?,
                ..nil,
            };
        } else if expr.t_call != nil {
            let callee = expr.t_call!.callee;
            if callee.t_project != nil {
                let project = callee.t_project!;
                if project.type_!.t_ptr != nil && project.field.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 2 arguments");
                    }

                    let t_ptr_elem = project.type_!.t_ptr!;

                    let term = self.expression(project.expr).try;
                    let offset = self.expression(expr.t_call!.args.at(0)).try;

                    return self.generate_array_at(t_ptr_elem, term, offset).try;
                } else if project.type_!.t_ptr != nil && project.field.equal("offset") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("offset() takes 2 arguments");
                    }

                    let t_ptr_elem = project.type_!.t_ptr!;

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "add"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                IrCodeGenerator::wrap_mult_sizeof(
                                    IrType::new(t_ptr_elem),
                                    self.expression(expr.t_call!.args.at(0)).try,
                                ),
                            ),
                        }?,
                        ..nil,
                    };
                } else if project.type_!.t_vec != nil && project.field.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 2 arguments");
                    }

                    let symbol = "";
                    if project.type_!.t_vec!.t_byte != nil {
                        symbol = "quartz_std_vec_at_byte";
                    } else {
                        symbol = "quartz_std_vec_at";
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: symbol?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        }?,
                        ..nil,
                    };
                } else if project.type_!.t_vec != nil && project.field.equal("push") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("push() takes 2 arguments");
                    }

                    let symbol = "";
                    if project.type_!.t_vec!.t_byte != nil {
                        symbol = "quartz_std_vec_push_byte";
                    } else {
                        symbol = "quartz_std_vec_push";
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: symbol?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        }?,
                        ..nil,
                    };
                } else if project.type_!.t_map != nil && project.field.equal("insert") {
                    if expr.t_call!.args.length != 2 {
                        return _ or error::new("insert() takes 2 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_insert"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                                self.expression(expr.t_call!.args.at(1)).try,
                            ),
                        }?,
                        ..nil,
                    };
                } else if project.type_!.t_map != nil && project.field.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 1 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_at"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        }?,
                        ..nil,
                    };
                } else if project.type_!.t_map != nil && project.field.equal("has") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("has() takes 1 arguments");
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_map_has"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                self.expression(project.expr).try,
                                self.expression(expr.t_call!.args.at(0)).try,
                            ),
                        }?,
                        ..nil,
                    };
                } else {
                    let symbol = "";
                    if project.resolved_path != nil {
                        symbol = project.resolved_path!.join("_");
                    } else if project.type_ != nil && project.type_!.t_ident != nil {
                        symbol = project.type_!.t_ident!;
                    }

                    if symbol == "" {
                        return _ or error::new("unknown symbol, {}".format(derive::to_string(project)));
                    }

                    let callee = IrTerm {
                        t_ident: symbol?,
                        ..nil,
                    };
                    let args = make[vec[IrTerm]]();

                    args.push(self.expression(project.expr).try);

                    for i in 0..expr.t_call!.args.length {
                        args.push(self.expression(expr.t_call!.args.at(i)).try);
                    }

                    return IrTerm {
                        t_call: IrCall {
                            callee: callee,
                            args: args,
                        }?,
                        ..nil,
                    };
                }
            } else {
                return self.generate_call(
                    expr.t_call!.callee,
                    expr.t_call!.args,
                    expr.t_call!.variadic,
                    expr.t_call!.expansion,
                ).try;
            }
        } else if expr.t_record != nil {
            if !self.globals.has(expr.t_record!.name) {
                return _ or error::new(format("record not found: {}", expr.t_record!.name));
            }
            let record_type = self.globals.at(expr.t_record!.name);
            if record_type.t_struct == nil {
                return _ or error::new(format("type is not a record: {}", expr.t_record!.name));
            }

            let expansion_term = nil as IrTerm?;
            if expr.t_record!.expansion != nil {
                expansion_term = self.expression(expr.t_record!.expansion!).try?;
            }

            let t = self.globals.at(expr.t_record!.name).t_struct!;

            let record = make[vec[struct {
                type_: IrType,
                term: IrTerm,
            }]]();
            for i in 0..t.fields.length {
                let field = t.fields.at(i);
                if i < expr.t_record!.fields.length {
                    let value = expr.t_record!.fields.at(i).value;

                    record.push(struct {
                        type_: IrType::new(field.type_),
                        term: self.expression(value).try,
                    });
                } else {
                    if expansion_term == nil {
                        return _ or error::new("record expansion not found");
                    }

                    record.push(struct {
                        type_: IrType::new(field.type_),
                        term: expansion_term!,
                    });
                }
            }

            return self.generate_array_enumerated(expr.t_record!.name, make[vec[IrType]](), record);
        } else if expr.t_anonymous_record != nil {
            let terms = make[vec[struct {
                type_: IrType,
                term: IrTerm,
            }]]();
            for field in expr.t_anonymous_record!.fields {
                let type_ = expr.t_anonymous_record!.type_!.t_struct!.at(field.field);

                terms.push(struct {
                    type_: IrType::new(type_),
                    term: self.expression(field.value).try,
                });
            }

            return self.generate_array_enumerated("struct", make[vec[IrType]](), terms).try;
        } else if expr.t_project != nil {
            let t = self.resolve_type_struct(expr.t_project!.type_!).try;
            let index = t.index(expr.t_project!.field);

            let offset = 0;
            for i in 0..index {
                offset = offset + IrType::new(t.fields.at(i).type_).sizeof();
            }

            return IrTerm {
                t_load: struct {
                    type_: IrType::new(t.fields.at(index).type_),
                    address: self.expression(expr.t_project!.expr).try,
                    offset: IrTerm::i32(offset),
                }?,
                ..nil,
            };
        } else if expr.t_make != nil {
            if expr.t_make!.type_.t_ptr != nil {
                if expr.t_make!.args.length != 1 {
                    panic("ptr make expects 1 argument");
                }

                let len = self.expression(expr.t_make!.args.at(0)).try;

                let rep_args = make[vec[InternalTypeRep]]();
                rep_args.push(InternalTypeRep::from_ir_type(IrType::new(expr.t_make!.type_.t_ptr!)));

                return self.allocate_heap_object(
                    InternalTypeRep::from_name(
                        "ptr",
                        make[vec[InternalTypeRep]](InternalTypeRep::from_ir_type(IrType::new(
                            expr.t_make!.type_.t_ptr!.t_ptr!,
                        ))),
                    ),
                    IrType::new(expr.t_make!.type_.t_ptr!),
                    len,
                );
            } else if expr.t_make!.type_.t_vec != nil {
                let var_vec = format("vec_{}", self.counter.to_string());
                self.counter = self.counter + 1;

                let terms = make[vec[IrTerm]]();
                terms.push(IrTerm {
                    t_let: IrLet {
                        name: var_vec,
                        type_: IrType::new(expr.t_make!.type_),
                        value: IrTerm {
                            t_call: IrCall {
                                callee: IrTerm {
                                    t_ident: "quartz_std_vec_make"?,
                                    ..nil,
                                },
                                args: make[vec[IrTerm]](IrTerm {
                                    t_i32: 5?,
                                    ..nil,
                                }),
                            }?,
                            ..nil,
                        },
                    }?,
                    ..nil,
                });
                for arg in expr.t_make!.args {
                    terms.push(IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_push"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: var_vec?,
                                    ..nil,
                                },
                                self.expression(arg).try,
                            ),
                        }?,
                        ..nil,
                    });
                }
                terms.push(IrTerm {
                    t_ident: var_vec?,
                    ..nil,
                });

                return IrTerm {
                    t_seq: struct {
                        terms: terms,
                    }?,
                    ..nil,
                };
            } else if expr.t_make!.type_.t_map != nil {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_map_make"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](),
                    }?,
                    ..nil,
                };
            } else {
                return _ or error::new("make() expects a pointer or vector type, {}".format(expr.t_make!.type_.to_string(
                )));
            }
        } else if expr.t_path != nil {
            if expr.t_path!.resolved_path == nil {
                return _ or error::new("unresolved path, {}".format(expr.t_path!.path.join("_")));
            }

            return IrTerm {
                t_ident: expr.t_path!.resolved_path!.join("_")?,
                ..nil,
            };
        } else if expr.t_self != nil {
            return IrTerm {
                t_ident: "self"?,
                ..nil,
            };
        } else if expr.t_as != nil {
            let term = self.expression(expr.t_as!.expr).try;
            let source = IrType::new(expr.t_as!.source_type);
            let target = IrType::new(expr.t_as!.target_type);

            if (source.t_i32 != nil) && (target.t_i32 != nil) {
                return term;
            } else if (source.t_address != nil) && (target.t_address != nil) {
                return term;
            } else if (source.t_byte != nil) && (target.t_byte != nil) {
                return term;
            } else if (source.t_i32 != nil) && (target.t_address != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "i32_to_address"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](term),
                    }?,
                    ..nil,
                };
            } else if (source.t_i32 != nil) && (target.t_byte != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "i32_to_byte"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](term),
                    }?,
                    ..nil,
                };
            } else if (source.t_byte != nil) && (target.t_i32 != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "byte_to_i32"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](term),
                    }?,
                    ..nil,
                };
            } else if (source.t_address != nil) && (target.t_i32 != nil) {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "address_to_i32"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](term),
                    }?,
                    ..nil,
                };
            } else if target.t_any != nil {
                return term;
            } else if source.t_any != nil {
                return term;
            }

            return _ or error::new(format("cannot cast {} to {}", source.to_string(), target.to_string()));
        } else if expr.t_string != nil {
            return self.register_string(expr.t_string!);
        } else if expr.t_paren != nil {
            return self.expression(expr.t_paren!).try;
        } else if expr.t_wrap != nil {
            let term = self.expression(expr.t_wrap!.expr).try;

            return self.generate_array_enumerated(
                "optional",
                make[vec[IrType]](IrType::new(expr.t_wrap!.type_)),
                make[vec[struct {
                    type_: IrType,
                    term: IrTerm,
                }]](struct {
                    type_: IrType::new(expr.t_wrap!.type_),
                    term: term,
                }),
            );
        } else if expr.t_unwrap != nil {
            let term = self.expression(expr.t_unwrap!.expr).try;

            return self.generate_array_at(
                expr.t_unwrap!.type_,
                term,
                IrTerm {
                    t_i32: 0?,
                    ..nil,
                },
            ).try;
        } else if expr.t_bool != nil {
            return IrTerm {
                t_bool: expr.t_bool!?,
                ..nil,
            };
        } else if expr.t_nil != nil {
            return IrTerm {
                t_nil: true?,
                ..nil,
            };
        } else if expr.t_enumor != nil {
            let lhs_term = IrTerm {
                t_nil: true?,
                ..nil,
            };
            if expr.t_enumor!.lhs != nil {
                lhs_term = self.expression(expr.t_enumor!.lhs!).try;
                lhs_term = self.generate_array_enumerated(
                    "optional",
                    make[vec[IrType]](IrType::new(expr.t_enumor!.lhs_type)),
                    make[vec[struct {
                        type_: IrType,
                        term: IrTerm,
                    }]](struct {
                        type_: IrType::new(expr.t_enumor!.lhs_type),
                        term: lhs_term,
                    }),
                ).try;
            }

            let rhs_term = IrTerm {
                t_nil: true?,
                ..nil,
            };
            if expr.t_enumor!.rhs != nil {
                rhs_term = self.expression(expr.t_enumor!.rhs!).try;
                rhs_term = self.generate_array_enumerated(
                    "optional",
                    make[vec[IrType]](IrType::new(expr.t_enumor!.rhs_type)),
                    make[vec[struct {
                        type_: IrType,
                        term: IrTerm,
                    }]](struct {
                        type_: IrType::new(expr.t_enumor!.rhs_type),
                        term: rhs_term,
                    }),
                ).try;
            }

            return self.generate_array_enumerated(
                "or",
                make[vec[IrType]](IrType::new(expr.t_enumor!.lhs_type), IrType::new(expr.t_enumor!.rhs_type)),
                make[vec[struct {
                    type_: IrType,
                    term: IrTerm,
                }]](
                    struct {
                        type_: IrType {
                            t_address: true?,
                            ..nil,
                        },
                        term: lhs_term,
                    },
                    struct {
                        type_: IrType {
                            t_address: true?,
                            ..nil,
                        },
                        term: rhs_term,
                    },
                ),
            ).try;
        } else if expr.t_sizeof != nil {
            return IrTerm {
                t_sizeof: struct {
                    type_: IrType::new(expr.t_sizeof!.type_),
                }?,
                ..nil,
            };
        } else if expr.t_unop != nil {
            if expr.t_unop!.unop != "not" {
                return panic("unop not implemented: {}", expr.to_string());
            }

            let term = self.expression(expr.t_unop!.expr).try;

            return IrTerm {
                t_call: IrCall {
                    callee: IrTerm {
                        t_ident: "not"?,
                        ..nil,
                    },
                    args: make[vec[IrTerm]](term),
                }?,
                ..nil,
            };
        } else if expr.t_try != nil {
            // expr.try
            // --> let try = expr;
            //     if try.right != nil { return _ or right }
            //     try.left!
            let var_name = format("try_{}", self.counter.to_string());
            self.counter = self.counter + 1;

            let left = self.generate_array_at(
                Type {
                    t_optional: Type {
                        t_any: true?,
                        ..nil,
                    }?,
                    ..nil,
                },
                IrTerm {
                    t_ident: var_name?,
                    ..nil,
                },
                IrTerm {
                    t_i32: 0?,
                    ..nil,
                },
            ).try;
            let right = self.generate_array_at(
                Type {
                    t_optional: Type {
                        t_any: true?,
                        ..nil,
                    }?,
                    ..nil,
                },
                IrTerm {
                    t_ident: var_name?,
                    ..nil,
                },
                IrTerm {
                    t_i32: 1?,
                    ..nil,
                },
            ).try;

            let right_name = format("try_{}_right", self.counter.to_string());

            let elements = make[vec[IrTerm]]();
            elements.push(IrTerm {
                t_let: IrLet {
                    name: var_name,
                    type_: IrType {
                        t_address: true?,
                        ..nil,
                    },
                    value: self.expression(expr.t_try!).try,
                }?,
                ..nil,
            });
            elements.push(IrTerm {
                t_let: IrLet {
                    name: right_name,
                    type_: IrType {
                        t_address: true?,
                        ..nil,
                    },
                    value: right,
                }?,
                ..nil,
            });
            elements.push(IrTerm {
                t_if: struct {
                    condition: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "not_equal"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: right_name?,
                                    ..nil,
                                },
                                IrTerm {
                                    t_nil: true?,
                                    ..nil,
                                },
                            ),
                        }?,
                        ..nil,
                    },
                    then_term: IrTerm {
                        t_return: IrReturn {
                            value: self.generate_array_enumerated(
                                "or",
                                make[vec[IrType]](
                                    IrType {
                                        t_address: true?,
                                        ..nil,
                                    },
                                    IrType {
                                        t_address: true?,
                                        ..nil,
                                    },
                                ),
                                make[vec[struct {
                                    type_: IrType,
                                    term: IrTerm,
                                }]](
                                    struct {
                                        type_: IrType {
                                            t_address: true?,
                                            ..nil,
                                        },
                                        term: IrTerm {
                                            t_nil: true?,
                                            ..nil,
                                        },
                                    },
                                    struct {
                                        type_: IrType {
                                            t_address: true?,
                                            ..nil,
                                        },
                                        term: IrTerm {
                                            t_ident: right_name?,
                                            ..nil,
                                        },
                                    },
                                ),
                            ).try,
                        }?,
                        ..nil,
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: make[vec[IrTerm]](),
                        }?,
                        ..nil,
                    },
                }?,
                ..nil,
            });
            elements.push(self.generate_array_at(
                Type {
                    t_ptr: Type {
                        t_omit: true?,
                        ..nil,
                    }?,
                    ..nil,
                },
                left,
                IrTerm {
                    t_i32: 0?,
                    ..nil,
                },
            ).try);

            return IrTerm {
                t_seq: struct {
                    terms: elements,
                }?,
                ..nil,
            };
        }

        return panic("expression exhausted: {}", expr.to_string());
    }

    fun register_string(self, str: string): IrTerm {
        let index = self.strings.get_or_insert(str);

        return IrTerm {
            t_string: index?,
            ..nil,
        };
    }

    fun generate_array_enumerated(
        self,
        rep_name: string,
        params: vec[IrType],
        record: vec[struct {
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm or error {
        let terms = make[vec[struct {
            offset: i32,
            type_: IrType,
            term: IrTerm,
        }]]();
        let offset = 0;
        for i in 0..record.length {
            let field = record.at(i);

            terms.push(struct {
                offset: offset,
                type_: field.type_,
                term: field.term,
            });
            offset = offset + field.type_.sizeof();
        }

        return self.generate_array(rep_name, params, terms).try;
    }

    fun generate_array(
        self,
        rep_name: string,
        params: vec[IrType],
        terms: vec[struct {
            offset: i32,
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm or error {
        let rep_fields = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..terms.length {
            let term = terms.at(i);

            rep_fields.push(struct {
                name: format("{}", i.to_string()),
                type_: term.type_,
            });
        }
        let rep = InternalTypeRep::from_struct(rep_name, params, rep_fields);

        let var_name = format("arr_{}", self.counter.to_string());
        self.counter = self.counter + 1;

        let arr = make[vec[IrTerm]]();
        arr.push(IrTerm {
            t_let: IrLet {
                name: var_name,
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                value: self.allocate_heap_object(
                    rep,
                    IrType {
                        t_address: true?,
                        ..nil,
                    },
                    IrTerm {
                        t_i32: terms.length?,
                        ..nil,
                    },
                ).try,
            }?,
            ..nil,
        });

        for i in 0..terms.length {
            let term = terms.at(i);
            let element = IrTerm {
                t_store: struct {
                    type_: term.type_,
                    address: IrTerm::ident(var_name),
                    offset: IrTerm::i32(term.offset),
                    value: term.term,
                }?,
                ..nil,
            };

            arr.push(element);
        }

        arr.push(IrTerm {
            t_ident: var_name?,
            ..nil,
        });

        return IrTerm {
            t_seq: struct {
                terms: arr,
            }?,
            ..nil,
        };
    }

    fun allocate_heap_object(self, rep: InternalTypeRep, type_: IrType, size: IrTerm): IrTerm or error {
        let rep_id = self.type_reps.get_or_insert(rep);
        let var = "object";

        let object = make[vec[IrTerm]]();

        object.push(IrTerm {
            t_let: IrLet {
                name: var,
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "alloc"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](IrCodeGenerator::wrap_mult_sizeof(
                            IrType {
                                t_address: true?,
                                ..nil,
                            },
                            IrTerm {
                                t_call: IrCall {
                                    callee: IrTerm {
                                        t_ident: "add"?,
                                        ..nil,
                                    },
                                    args: make[vec[IrTerm]](
                                        size,
                                        IrTerm {
                                            t_i32: 1?,
                                            ..nil,
                                        },
                                    ),
                                }?,
                                ..nil,
                            },
                        )),
                    }?,
                    ..nil,
                },
            }?,
            ..nil,
        });
        // object header
        object.push(IrTerm {
            t_store: struct {
                type_: IrType {
                    t_i32: true?,
                    ..nil,
                },
                address: IrTerm::ident(var),
                offset: IrTerm::i32(0),
                value: IrTerm {
                    t_i32: rep_id?,
                    ..nil,
                },
            }?,
            ..nil,
        });
        object.push(IrTerm {
            t_ident: var?,
            ..nil,
        });

        return IrTerm {
            t_seq: struct {
                terms: object,
            }?,
            ..nil,
        };
    }

    fun write_type_rep(self, rep: InternalTypeRep): IrTerm or error {
        // [nil, rep_name, size of params, *params, size of fields, *fields]
        let elements = make[vec[IrTerm]]();
        elements.push(IrTerm {
            t_nil: true?,
            ..nil,
        });
        elements.push(self.register_string(rep.name));
        elements.push(IrTerm::i32(rep.params.length));

        let type_rep_terms = make[vec[struct {
            type_: IrType,
            term: IrTerm,
        }]]();
        for p in rep.params {
            type_rep_terms.push(struct {
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                term: self.write_type_rep(p).try,
            });
        }
        elements.push(self.generate_array_enumerated("slice", make[vec[IrType]](), type_rep_terms).try);
        elements.push(IrTerm::i32(rep.fields.length));

        let field_terms = make[vec[struct {
            type_: IrType,
            term: IrTerm,
        }]]();
        for t in rep.fields {
            field_terms.push(struct {
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                term: self.register_string(t.name),
            });
        }
        elements.push(self.generate_array_enumerated("slice", make[vec[IrType]](), field_terms).try);

        let var_name = format("type_rep_{}", self.counter.to_string());
        self.counter = self.counter + 1;

        let arr = make[vec[IrTerm]]();
        arr.push(IrTerm {
            t_let: IrLet {
                name: var_name,
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "quartz_std_alloc"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](IrCodeGenerator::wrap_mult_sizeof(
                            IrType {
                                t_any: true?,
                                ..nil,
                            },
                            IrTerm::i32(elements.length),
                        )),
                    }?,
                    ..nil,
                },
                ..nil,
            }?,
            ..nil,
        });
        for index in 0..elements.length {
            arr.push(IrTerm {
                t_store: struct {
                    type_: IrType {
                        t_any: true?,
                        ..nil,
                    },
                    address: IrTerm {
                        t_ident: var_name?,
                        ..nil,
                    },
                    offset: IrCodeGenerator::wrap_mult_sizeof(
                        IrType {
                            t_i32: true?,
                            ..nil,
                        },
                        IrTerm {
                            t_i32: index?,
                            ..nil,
                        },
                    ),
                    value: elements.at(index),
                }?,
                ..nil,
            });
        }

        arr.push(IrTerm {
            t_ident: var_name?,
            ..nil,
        });

        return IrTerm {
            t_seq: struct {
                terms: arr,
            }?,
            ..nil,
        };
    }

    fun wrap_mult_sizeof(ir_type: IrType, term: IrTerm): IrTerm {
        let args = make[vec[IrTerm]]();
        args.push(term);
        args.push(IrTerm {
            t_sizeof: struct {
                type_: ir_type,
            }?,
            ..nil,
        });

        return IrTerm {
            t_call: IrCall {
                callee: IrTerm {
                    t_ident: "mult"?,
                    ..nil,
                },
                args: args,
            }?,
            ..nil,
        };
    }

    fun generate_array_at(self, elem_type: Type, arr: IrTerm, index: IrTerm): IrTerm or error {
        return IrTerm {
            t_load: struct {
                type_: IrType::new(elem_type),
                address: arr,
                offset: IrCodeGenerator::wrap_mult_sizeof(IrType::new(elem_type), index),
            }?,
            ..nil,
        };
    }

    fun resolve_type_struct(self, t: Type): TypeStruct or error {
        if t.t_ident != nil {
            let ident = t.t_ident!;

            if self.globals.has(ident) {
                return self.resolve_type_struct(self.globals.at(ident));
            } else {
                return _ or error::new(format("unknown type: {}", ident));
            }
        } else if t.t_struct != nil {
            return t.t_struct!;
        } else if t.t_vec != nil {
            return self.resolve_type_struct(Type {
                t_ident: "vec"?,
                ..nil,
            });
        } else if t.t_map != nil {
            return self.resolve_type_struct(Type {
                t_ident: "quartz_std_Map"?,
                ..nil,
            });
        } else {
            return _ or error::new(format("type is not a struct: {}", t.to_string()));
        }
    }

    fun assign(self, lhs: IrTerm, rhs: IrTerm): IrTerm or error {
        if lhs.t_ident != nil {
            let term = IrTerm {
                t_assign: struct {
                    lhs: lhs.t_ident!,
                    rhs: rhs,
                }?,
                ..nil,
            };

            return term;
        }
        if lhs.t_load != nil {
            let term = IrTerm {
                t_store: struct {
                    type_: lhs.t_load!.type_,
                    address: lhs.t_load!.address,
                    offset: lhs.t_load!.offset,
                    value: rhs,
                }?,
                ..nil,
            };

            return term;
        }

        return panic("lhs: {}, rhs: {}", lhs.to_string(), rhs.to_string());
    }

    fun generate_call(
        self,
        callee: Expression,
        args: vec[Expression],
        variadic: struct {
            element_type: Type,
            index: i32,
        }?,
        expansion: Expression?,
    ): IrTerm or error {
        if variadic != nil {
            let terms = make[vec[IrTerm]]();
            for arg in args.slice(0, variadic!.index) {
                terms.push(self.expression(arg).try);
            }

            // for uniqueness
            let vec_name = format("vec_generate_call_{}", self.counter.to_string());
            self.counter = self.counter + 1;

            let variadic_terms = make[vec[IrTerm]](IrTerm {
                t_let: IrLet {
                    name: vec_name,
                    type_: IrType::new(Type {
                        t_vec: variadic!.element_type?,
                        ..nil,
                    }),
                    value: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_make"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](IrTerm {
                                t_i32: 1?,
                                ..nil,
                            }),
                        }?,
                        ..nil,
                    },
                }?,
                ..nil,
            });
            for arg in args.slice(variadic!.index, args.length) {
                variadic_terms.push(IrTerm {
                    t_discard: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_push"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: vec_name?,
                                    ..nil,
                                },
                                self.expression(arg).try,
                            ),
                        }?,
                        ..nil,
                    }?,
                    ..nil,
                });
            }
            if expansion != nil {
                variadic_terms.push(IrTerm {
                    t_discard: IrTerm {
                        t_call: IrCall {
                            callee: IrTerm {
                                t_ident: "quartz_std_vec_extend"?,
                                ..nil,
                            },
                            args: make[vec[IrTerm]](
                                IrTerm {
                                    t_ident: vec_name?,
                                    ..nil,
                                },
                                self.expression(expansion!).try,
                            ),
                        }?,
                        ..nil,
                    }?,
                    ..nil,
                });
            }

            variadic_terms.push(IrTerm {
                t_ident: vec_name?,
                ..nil,
            });

            terms.push(IrTerm {
                t_seq: struct {
                    terms: variadic_terms,
                }?,
                ..nil,
            });

            return IrTerm {
                t_call: IrCall {
                    callee: self.expression(callee).try,
                    args: terms,
                }?,
                ..nil,
            };
        } else {
            let terms = make[vec[IrTerm]]();
            for arg in args {
                terms.push(self.expression(arg).try);
            }

            return IrTerm {
                t_call: IrCall {
                    callee: self.expression(callee).try,
                    args: terms,
                }?,
                ..nil,
            };
        }
    }
}

