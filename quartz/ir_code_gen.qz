import quartz::ast;
import quartz::ir;

type IrCodeGenerator = {
    locals: vec[string],
};

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
            locals: make[vec[string]](),
        };
    }

    fun module_(self, m: Module): IrTerm {
        let elements = make[vec[IrTerm]]();

        for i in 0..m.decls.length {
            let f = m.decls.at(i);
            elements.push(self.decl(f));
        }

        return IrTerm {
            t_module: struct {
                elements: elements,
            }?,
            ..nil
        };
    }

    fun decl(self, d: Decl): IrTerm {
        if d.t_func != nil {
            return IrTerm {
                t_func: self.function(d.t_func!)?,
                ..nil,
            };
        }
        if d.t_let != nil {
            return IrTerm {
                t_global_let: struct {
                    name: d.t_let!.name,
                    type_: IrType {
                        t_i32: true?,
                        ..nil,
                    },
                    value: self.expression(d.t_let!.expr),
                }?,
                ..nil,
            };
        }

        println(d.to_string());
        panic("decl exhausted");
    }

    fun function(self, func: Function): IrFunc {
        self.locals = make[vec[string]]();
        let body = self.block(func.body);

        let params = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..func.params.length {
            let p = func.params.at(i);

            params.push(struct {
                name: p.name,
                type_: IrType::new(p.type_),
            });
        }

        return IrFunc {
            name: func.name,
            params: params,
            body: body,
            result_type: IrType::new(func.result_type),
            locals: self.locals,
        };
    }
    
    fun block(self, b: Block): vec[IrTerm] {
        let elements = make[vec[IrTerm]]();

        for i in 0..b.block.length {
            elements.push(self.statement(b.block.at(i)));
        }

        return elements;
    }

    fun statement(self, stm: Statement): IrTerm {
        if stm.t_let != nil {
            let term = IrTerm {
                t_let: IrLet {
                    name: stm.t_let!.name,
                    type_: IrType {
                        t_i32: true?,
                        ..nil,
                    },
                    value: self.expression(stm.t_let!.expr),
                }?,
                ..nil,
            };
            self.locals.push(stm.t_let!.name);

            return term;
        }
        if stm.t_return != nil {
            let term = IrTerm {
                t_return: IrReturn {
                    value: self.expression(stm.t_return!.expr),
                }?,
                ..nil,
            };

            return term;
        }
        if stm.t_expr != nil {
            return self.expression(stm.t_expr!.expr);
        }
        if stm.t_assign != nil {
            let lhs = self.expression(stm.t_assign!.lhs);
            let rhs = self.expression(stm.t_assign!.rhs);

            if lhs.t_ident != nil {
                let term = IrTerm {
                    t_assign: struct {
                        lhs: lhs.t_ident!,
                        rhs: rhs,
                    }?,
                    ..nil,
                };

                return term;
            }

            println(stm.t_assign!.lhs.to_string());
            panic("lhs");
        }
        if stm.t_if != nil {
            let then_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_if!.then_block.block.length {
                then_elements.push(self.statement(stm.t_if!.then_block.block.at(i)));
            }

            let else_elements = make[vec[IrTerm]]();
            if stm.t_if!.else_block != nil {
                for i in 0..stm.t_if!.else_block!.block.length {
                    else_elements.push(self.statement(stm.t_if!.else_block!.block.at(i)));
                }
            }

            return IrTerm {
                t_if: struct {
                    condition: self.expression(stm.t_if!.condition),
                    then_term: IrTerm {
                        t_seq: struct {
                            terms: then_elements,
                        }?,
                        ..nil,
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: else_elements,
                        }?,
                        ..nil,
                    },
                }?,
                ..nil,
            };
        }

        println(stm.to_string());
        panic("statement exhausted");
    }

    fun expression(self, expr: Expression): IrTerm {
        if expr.t_number != nil {
            let term = IrTerm {
                t_i32: expr.t_number!.value?,
                ..nil,
            };

            return term;
        }
        if expr.t_binop != nil {
            let args = make[vec[IrTerm]]();
            args.push(self.expression(expr.t_binop!.left));
            args.push(self.expression(expr.t_binop!.right));

            if expr.t_binop!.binop.equal("plus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "add"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("minus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "sub"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("mult") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "mult"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "equal"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }

            panic("binop exhausted: ".concat(expr.t_binop!.binop));
        }
        if expr.t_ident != nil {
            let term = IrTerm {
                t_ident: expr.t_ident!.name?,
                ..nil,
            };

            return term;
        }
        if expr.t_call != nil {
            let term = IrTerm {
                t_call: IrCall {
                    callee: self.expression(expr.t_call!.callee),
                    args: make[vec[IrTerm]](),
                }?,
                ..nil,
            };

            for i in 0..expr.t_call!.args.length {
                term.t_call!.args.push(self.expression(expr.t_call!.args.at(i)));
            }

            return term;
        }

        panic("expression exhausted: ");
    }
}
