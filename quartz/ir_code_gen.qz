import quartz::ast;
import quartz::ir;

type IrCodeGenerator = {
    locals: vec[string],
};

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
            locals: make[vec[string]](),
        };
    }

    fun function(self, func: Function): IrFunc {
        let body = self.block(func.body);

        return IrFunc {
            name: func.name,
            params: make[vec[ParamPair]](),
            body: body,
            result_type: IrType::new(func.result_type),
            locals: self.locals,
        };
    }
    
    fun block(self, b: Block): vec[IrTerm] {
        let elements = make[vec[IrTerm]]();

        for i in 0..b.block.length {
            elements.push(self.statement(b.block.at(i)));
        }

        return elements;
    }

    fun statement(self, stm: Statement): IrTerm {
        if stm.t.equal("let") {
            let term = IrTerm {
                ir_let: IrLet {
                    name: stm.name!,
                    type_: IrType {
                        ir_i32: true?,
                    },
                    value: self.expression(stm.expr),
                }?,
                ..nil,
            };
            self.locals.push(stm.name!);

            return term;
        }
        if stm.t.equal("return") {
            let term = IrTerm {
                ir_return: IrReturn {
                    value: self.expression(stm.expr),
                }?,
                ..nil,
            };

            return term;
        }

        panic("statement exhausted: ".concat(stm.t));
    }

    fun expression(self, expr: Expression): IrTerm {
        if expr.t_number != nil {
            let term = IrTerm {
                ir_i32: expr.t_number!.value?,
                ..nil,
            };

            return term;
        }
        if expr.t_binop != nil {
            if expr.t_binop!.binop.equal("plus") {
                let term = IrTerm {
                    ir_call: IrCall {
                        callee: IrTerm {
                            ir_ident: "add"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](),
                    }?,
                    ..nil,
                };

                term.ir_call!.args.push(self.expression(expr.t_binop!.left));
                term.ir_call!.args.push(self.expression(expr.t_binop!.right));

                return term;
            }

            panic("binop exhausted: ".concat(expr.t_binop!.binop));
        }
        if expr.t_ident != nil {
            let term = IrTerm {
                ir_ident: expr.t_ident!.name?,
                ..nil,
            };

            return term;
        }

        panic("expression exhausted: ");
    }
}
