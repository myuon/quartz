import quartz::ast;
import quartz::ir;

type IrCodeGenerator = {
};

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
        };
    }

    fun function(self, func: Function): IrTerm {
        self.block(func.body);
    }
    
    fun block(self, b: Block): IrTerm {
        for i in 0..b.block.length {
            self.statement(b.block.at(i));
        }
    }

    fun statement(self, stm: Statement): IrTerm {
        if stm.t.equal("let") {
            let term = IrTerm {
                t: "let",
                name: stm.name,
                value: self.expression(stm.expr)?,
                i32_value: nil,
            };

            return term;
        }
        if stm.t.equal("return") {
            let term = IrTerm {
                t: "return",
                name: nil,
                value: self.expression(stm.expr)?,
                i32_value: nil,
            };

            return term;
        }

        panic("statement exhausted: ".concat(stm.t));
    }

    fun expression(self, expr: Expression): IrTerm {
        if expr.t.equal("number") {
            let term = IrTerm {
                t: "i32",
                name: nil,
                value: nil,
                i32_value: expr.value,
            };

            return term;
        }
        if expr.t.equal("plus") {
            let term = IrTerm {
                t: "call",
                name: nil,
                value: nil,
                i32_value: nil,
                args: make[vec[IrTerm]]()?,
            };

            term.args.push(self.expression(expr.left)?);
            term.args.push(self.expression(expr.right)?);

            return term;
        }

        panic("expression exhausted: ".concat(expr.t));
    }
}
