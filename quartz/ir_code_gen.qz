import quartz::ast;
import quartz::ir;

struct InternalTypeRep {
    name: string,
    params: vec[InternalTypeRep],
    fields: vec[struct {
        name: string,
        type_: InternalTypeRep,
    }],
}

module InternalTypeRep {
    fun from_name(name: string, params: vec[InternalTypeRep]): InternalTypeRep {
        return InternalTypeRep {
            name: name,
            params: params,
            fields: make[vec[struct {
                name: string,
                type_: InternalTypeRep,
            }]](),
        };
    }

    fun from_struct(
        name: string,
        params: vec[IrType],
        fields: vec[struct {
            name: string,
            type_: IrType,
        }],
    ): InternalTypeRep {
        let params_t = make[vec[InternalTypeRep]]();
        for p in params {
            params_t.push(InternalTypeRep::from_ir_type(p));
        }

        let fields_t = make[vec[struct {
            name: string,
            type_: InternalTypeRep,
        }]]();
        for f in fields {
            fields_t.push(struct {
                name: f.name,
                type_: InternalTypeRep::from_ir_type(f.type_),
            });
        }

        return InternalTypeRep {
            name: name,
            params: params_t,
            fields: fields_t,
        };
    }

    fun from_ir_type(t: IrType): InternalTypeRep {
        if t.t_nil != nil {
            return InternalTypeRep::from_name("nil", make[vec[InternalTypeRep]]());
        } else if t.t_i32 != nil {
            return InternalTypeRep::from_name("i32", make[vec[InternalTypeRep]]());
        } else if t.t_address != nil {
            return InternalTypeRep::from_name("address", make[vec[InternalTypeRep]]());
        }

        return panic("unreachable");
    }
}

struct IrCodeGenerator {
    globals: map[string, Type],
    locals: vec[string],
}

module IrCodeGenerator {
    fun new(): IrCodeGenerator {
        return IrCodeGenerator {
            globals: make[map[string, Type]](),
            locals: make[vec[string]](),
        };
    }

    fun module_(self, m: Module): IrTerm or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..m.decls.length {
            let d = m.decls.at(i);

            if d.t_func != nil {
                elements.push(IrTerm {
                    t_func: self.function(d.t_func!).try?,
                    ..nil,
                });
            }
            if d.t_let != nil {
                elements.push(IrTerm {
                    t_global_let: struct {
                        name: d.t_let!.name,
                        type_: IrType {
                            t_i32: true?,
                            ..nil,
                        },
                        value: self.expression(d.t_let!.expr).try,
                    }?,
                    ..nil,
                });
            }
            if d.t_type != nil {
            }
        }

        return IrTerm {
            t_module: struct {
                elements: elements,
            }?,
            ..nil,
        };
    }

    fun function(self, func: Function): IrFunc or error {
        self.locals = make[vec[string]]();
        let body = self.block(func.body).try;

        let params = make[vec[struct {
            name: string,
            type_: IrType,
        }]]();
        for i in 0..func.params.length {
            let p = func.params.at(i);

            params.push(struct {
                name: p.name,
                type_: IrType::new(p.type_),
            });
        }

        return IrFunc {
            name: func.name,
            params: params,
            body: body,
            result_type: IrType::new(func.result_type),
            locals: self.locals,
        };
    }

    fun block(self, b: Block): vec[IrTerm] or error {
        let elements = make[vec[IrTerm]]();

        for i in 0..b.block.length {
            elements.push(self.statement(b.block.at(i)).try);
        }

        return elements;
    }

    fun statement(self, stm: Statement): IrTerm or error {
        if stm.t_let != nil {
            let term = IrTerm {
                t_let: IrLet {
                    name: stm.t_let!.name,
                    type_: IrType {
                        t_i32: true?,
                        ..nil,
                    },
                    value: self.expression(stm.t_let!.expr).try,
                }?,
                ..nil,
            };
            self.locals.push(stm.t_let!.name);

            return term;
        }
        if stm.t_return != nil {
            let term = IrTerm {
                t_return: IrReturn {
                    value: self.expression(stm.t_return!.expr).try,
                }?,
                ..nil,
            };

            return term;
        }
        if stm.t_expr != nil {
            return self.expression(stm.t_expr!.expr);
        }
        if stm.t_assign != nil {
            let lhs = self.expression(stm.t_assign!.lhs).try;
            let rhs = self.expression(stm.t_assign!.rhs).try;

            if lhs.t_ident != nil {
                let term = IrTerm {
                    t_assign: struct {
                        lhs: lhs.t_ident!,
                        rhs: rhs,
                    }?,
                    ..nil,
                };

                return term;
            }
            if lhs.t_load != nil {
                let term = IrTerm {
                    t_store: struct {
                        type_: lhs.t_load!.type_,
                        address: lhs.t_load!.address,
                        offset: lhs.t_load!.offset,
                        value: rhs,
                    }?,
                    ..nil,
                };

                return term;
            }

            panic("lhs: {}", stm.t_assign!.lhs.to_string());
        }
        if stm.t_if != nil {
            let then_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_if!.then_block.block.length {
                then_elements.push(self.statement(stm.t_if!.then_block.block.at(i)).try);
            }

            let else_elements = make[vec[IrTerm]]();
            if stm.t_if!.else_block != nil {
                for i in 0..stm.t_if!.else_block!.block.length {
                    else_elements.push(self.statement(stm.t_if!.else_block!.block.at(i)).try);
                }
            }

            return IrTerm {
                t_if: struct {
                    condition: self.expression(stm.t_if!.condition).try,
                    then_term: IrTerm {
                        t_seq: struct {
                            terms: then_elements,
                        }?,
                        ..nil,
                    },
                    else_term: IrTerm {
                        t_seq: struct {
                            terms: else_elements,
                        }?,
                        ..nil,
                    },
                }?,
                ..nil,
            };
        }
        if stm.t_while != nil {
            let body_elements = make[vec[IrTerm]]();
            for i in 0..stm.t_while!.block.block.length {
                body_elements.push(self.statement(stm.t_while!.block.block.at(i)).try);
            }

            return IrTerm {
                t_while: struct {
                    condition: self.expression(stm.t_while!.condition).try,
                    block: IrTerm {
                        t_seq: struct {
                            terms: body_elements,
                        }?,
                        ..nil,
                    },
                    cleanup: nil as IrTerm?,
                }?,
                ..nil,
            };
        }

        return panic("statement exhausted: {}", stm.to_string());
    }

    fun expression(self, expr: Expression): IrTerm or error {
        if expr.t_number != nil {
            let term = IrTerm {
                t_i32: expr.t_number!.value?,
                ..nil,
            };

            return term;
        }
        if expr.t_binop != nil {
            let args = make[vec[IrTerm]]();
            args.push(self.expression(expr.t_binop!.left).try);
            args.push(self.expression(expr.t_binop!.right).try);

            if expr.t_binop!.binop.equal("plus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "add"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("minus") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "sub"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("mult") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "mult"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("equal") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "equal"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }
            if expr.t_binop!.binop.equal("lt") {
                return IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "lt"?,
                            ..nil,
                        },
                        args: args,
                    }?,
                    ..nil,
                };
            }

            panic("binop exhausted: ".concat(expr.t_binop!.binop));
        }
        if expr.t_ident != nil {
            let term = IrTerm {
                t_ident: expr.t_ident!.name?,
                ..nil,
            };

            return term;
        }
        if expr.t_call != nil {
            if expr.t_call!.callee.t_project != nil {
                let project = expr.t_call!.callee.t_project!;
                if project.type_!.t_ptr != nil && project.field.equal("at") {
                    if expr.t_call!.args.length != 1 {
                        return _ or error::new("at() takes 2 arguments");
                    }

                    let t_ptr_elem = project.type_!.t_ptr!;

                    let term = self.expression(project.expr).try;
                    let offset = self.expression(expr.t_call!.args.at(0)).try;

                    return self.generate_array_at(t_ptr_elem, term, offset).try;
                }
            }

            let term = IrTerm {
                t_call: IrCall {
                    callee: self.expression(expr.t_call!.callee).try,
                    args: make[vec[IrTerm]](),
                }?,
                ..nil,
            };

            for i in 0..expr.t_call!.args.length {
                term.t_call!.args.push(self.expression(expr.t_call!.args.at(i)).try);
            }

            return term;
        }
        if expr.t_record != nil {
            let t = self.globals.at(expr.t_record!.name).t_struct!;

            let record = make[vec[struct {
                type_: IrType,
                term: IrTerm,
            }]]();
            for i in 0..t.fields.length {
                let field = t.fields.at(i);
                let value = expr.t_record!.fields.at(i).value;

                record.push(struct {
                    type_: IrType::new(field.type_),
                    term: self.expression(value).try,
                });
            }

            return self.generate_array_enumerated(record);
        }
        if expr.t_project != nil {
            let t = expr.t_project!.type_!.t_struct!;
            let index = t.index(expr.t_project!.field);

            let offset = 0;
            for i in 0..index {
                offset = offset + IrType::new(t.fields.at(i).type_).sizeof();
            }

            return IrTerm {
                t_load: struct {
                    type_: IrType::new(t.fields.at(index).type_),
                    address: self.expression(expr.t_project!.expr).try,
                    offset: IrTerm::i32(offset),
                }?,
                ..nil,
            };
        }
        if expr.t_make != nil {
            if expr.t_make!.type_.t_ptr != nil {
                if expr.t_make!.args.length != 1 {
                    panic("ptr make expects 1 argument");
                }

                let len = self.expression(expr.t_make!.args.at(0)).try;

                let rep_args = make[vec[InternalTypeRep]]();
                rep_args.push(InternalTypeRep::from_ir_type(IrType::new(expr.t_make!.type_.t_ptr!)));

                return self.allocate_heap_object(len);
            }
        }

        return panic("expression exhausted: {}", expr.to_string());
    }

    fun generate_array_enumerated(
        self,
        record: vec[struct {
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm {
        let terms = make[vec[struct {
            offset: i32,
            type_: IrType,
            term: IrTerm,
        }]]();
        let offset = 0;
        for i in 0..record.length {
            let field = record.at(i);

            terms.push(struct {
                offset: offset,
                type_: field.type_,
                term: field.term,
            });
            offset = offset + field.type_.sizeof();
        }

        return self.generate_array(terms);
    }

    fun generate_array(
        self,
        terms: vec[struct {
            offset: i32,
            type_: IrType,
            term: IrTerm,
        }],
    ): IrTerm {
        let arr = make[vec[IrTerm]]();
        arr.push(IrTerm {
            t_let: IrLet {
                name: "arr",
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "alloc"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](IrTerm {
                            t_i32: (terms.length * 4).to_string()?,
                            ..nil,
                        }),
                    }?,
                    ..nil,
                },
            }?,
            ..nil,
        });

        for i in 0..terms.length {
            let term = terms.at(i);
            let element = IrTerm {
                t_store: struct {
                    type_: term.type_,
                    address: IrTerm::ident("arr"),
                    offset: IrTerm::i32(term.offset),
                    value: term.term,
                }?,
                ..nil,
            };

            arr.push(element);
        }

        arr.push(IrTerm {
            t_ident: "arr"?,
            ..nil,
        });

        return IrTerm {
            t_seq: struct {
                terms: arr,
            }?,
            ..nil,
        };
    }

    fun allocate_heap_object(self, size: IrTerm): IrTerm or error {
        let var = "object";

        let object = make[vec[IrTerm]]();

        object.push(IrTerm {
            t_let: IrLet {
                name: var,
                type_: IrType {
                    t_address: true?,
                    ..nil,
                },
                value: IrTerm {
                    t_call: IrCall {
                        callee: IrTerm {
                            t_ident: "alloc"?,
                            ..nil,
                        },
                        args: make[vec[IrTerm]](IrCodeGenerator::wrap_mult_sizeof(
                            IrType {
                                t_address: true?,
                                ..nil,
                            },
                            IrTerm {
                                t_call: IrCall {
                                    callee: IrTerm {
                                        t_ident: "add"?,
                                        ..nil,
                                    },
                                    args: make[vec[IrTerm]](
                                        size,
                                        IrTerm {
                                            t_i32: "1"?,
                                            ..nil,
                                        },
                                    ),
                                }?,
                                ..nil,
                            },
                        )),
                    }?,
                    ..nil,
                },
            }?,
            ..nil,
        });
        object.push(IrTerm {
            t_store: struct {
                type_: IrType {
                    t_i32: true?,
                    ..nil,
                },
                address: IrTerm::ident(var),
                offset: IrTerm::i32(0),
                value: IrTerm {
                    t_i32: "0"?,
                    ..nil,
                },
            }?,
            ..nil,
        });
        object.push(IrTerm {
            t_ident: var?,
            ..nil,
        });

        return IrTerm {
            t_seq: struct {
                terms: object,
            }?,
            ..nil,
        };
    }

    fun wrap_mult_sizeof(ir_type: IrType, term: IrTerm): IrTerm {
        let args = make[vec[IrTerm]]();
        args.push(term);
        args.push(IrTerm {
            t_sizeof: struct {
                type_: ir_type,
            }?,
            ..nil,
        });

        return IrTerm {
            t_call: IrCall {
                callee: IrTerm {
                    t_ident: "mult"?,
                    ..nil,
                },
                args: args,
            }?,
            ..nil,
        };
    }

    fun generate_array_at(self, elem_type: Type, arr: IrTerm, index: IrTerm): IrTerm or error {
        return IrTerm {
            t_load: struct {
                type_: IrType::new(elem_type),
                address: arr,
                offset: IrCodeGenerator::wrap_mult_sizeof(IrType::new(elem_type), index),
            }?,
            ..nil,
        };
    }
}

