import quartz::lexer;
import quartz::parser;
import quartz::typecheck;
import quartz::ir_code_gen;
import quartz::generator;
import quartz::path;
import quartz::ast;
import quartz::ir;
import quartz::value;
import quartz::location;

struct LoadedModule {
    path: Path,
    source: string,
    module_: Module,
}

struct Compiler {
    loaded: vec[LoadedModule],
}

module Compiler {
    fun new(): Compiler {
        return Compiler {
            loaded: make[vec[LoadedModule]](),
        };
    }

    fun load_module(self, path: Path): vec[Path] or error {
        let input = file_read(format("{}.qz", path.join("/")));

        return self.register_module(path, input).try;
    }

    fun register_module(self, path: Path, input: string): vec[Path] or error {
        let lexer = Lexer::new();
        lexer.run(input).try;

        let parser = Parser::new();
        let module_ = parser.run(lexer.tokens).try;

        self.loaded.push(LoadedModule {
            path: path,
            source: input,
            module_: module_,
        });

        return parser.imports;
    }

    fun parse(self, input: string): Module or error {
        let main_path = Path::new("main");
        let imports = self.register_module(main_path, input).try;

        let visited = make[map[string, bool]]();
        visited.insert(main_path.join("_"), true);
        imports.push(Path::new("quartz", "std"));

        while imports.length != 0 {
            let path = vec_pop(imports) as Path;
            if visited.has(path.join("_")) {
                continue;
            }

            imports.extend(self.load_module(path).try);
            visited.insert(path.join("_"), true);
        }
        // println("loaded modules");
        // debug(alloc_ptr);

        let decls = make[vec[LDecl]]();
        for loaded in self.loaded {
            decls.push(LDecl {
                data: Decl {
                    t_module: struct {
                        path: loaded.path,
                        module_: loaded.module_,
                    },
                },
                location: Location::unknown(),
            });
        }

        let module_ = Module {
            decls: decls,
        };

        return module_;
    }

    fun compile(self, input: string): string or error {
        let module_ = self.parse(input).try;

        let typechecker = Typechecker::new();
        typechecker.module_(module_).try;

        let irgen = IrCodeGenerator::new();
        irgen.globals = typechecker.globals;
        let term = irgen.run(module_).try;

        let gen = Generator::new();
        gen.set_globals(typechecker.globals);
        gen.set_strings(irgen.strings.strings);
        gen.set_type_reps(irgen.type_reps.type_reps);
        gen.set_start_terms(irgen.start);

        term = gen.fold_consts(term);

        let code = gen.run(term, irgen.data_section_offset);

        return code;
    }

    fun check(self, input: string): nil or error {
        let module_ = self.parse(input).try;

        let typechecker = Typechecker::new();
        typechecker.module_(module_).try;

        return nil;
    }

    fun check_type(self, input: string, line: i32, column: i32): nil or error {
        let main_path = Path::new("main");
        let module_ = self.parse(input).try;

        let position = find_line_column_from_position(input, line, column);

        let typechecker = Typechecker::new();
        typechecker.find_at_cursor(module_, main_path, position).try;

        return nil;
    }
}

fun find_position(
    input: string,
    position: i32,
): struct {
    line: i32,
    column: i32,
} {
    let line_number = 0;
    let count = 0;
    for line in input.lines() {
        if count + line.length > position {
            break;
        }

        line_number = line_number + 1;
        count = count + line.length + 1;
    }

    return struct {
        line: line_number,
        column: position - count,
    };
}

fun find_line_column_from_position(input: string, line: i32, column: i32): i32 {
    let start = 0;
    let end = input.length;

    while start < end {
        let mid = (start + end) / 2;
        let pos = find_position(input, mid);

        if pos.line == line && pos.column == column {
            return mid;
        }

        if pos.line < line || (pos.line == line && pos.column < column) {
            start = mid + 1;
        } else {
            end = mid;
        }
    }

    return start;
}

