import quartz::ast;
import quartz::path;

struct Typechecker {
    locals: map[string, Type],
    globals: map[string, Type],
    current_path: Path,
}

module Typechecker {
    fun new(): Typechecker {
        let globals = make[map[string, Type]]();
        globals.insert(
            "string",
            Type {
                t_struct: TypeStruct {
                    fields: make[vec[struct {
                        name: string,
                        type_: Type,
                    }]](
                        struct {
                            name: "data",
                            type_: Type {
                                t_ptr: Type {
                                    t_byte: true?,
                                    ..nil,
                                }?,
                                ..nil,
                            },
                        },
                        struct {
                            name: "length",
                            type_: Type {
                                t_i32: true?,
                                ..nil,
                            },
                        },
                    ),
                }?,
                ..nil,
            },
        );
        globals.insert(
            "println",
            Type {
                t_func: struct {
                    params: make[vec[Type]](Type {
                        t_ident: "string"?,
                        ..nil,
                    }),
                    result: Type {
                        t_nil: true?,
                        ..nil,
                    },
                }?,
                ..nil,
            },
        );
        globals.insert(
            "vec",
            Type {
                t_struct: TypeStruct {
                    fields: make[vec[struct {
                        name: string,
                        type_: Type,
                    }]](
                        struct {
                            name: "data",
                            type_: Type {
                                t_ptr: Type {
                                    t_omit: true?,
                                    ..nil,
                                }?,
                                ..nil,
                            },
                        },
                        struct {
                            name: "length",
                            type_: Type {
                                t_i32: true?,
                                ..nil,
                            },
                        },
                        struct {
                            name: "capacity",
                            type_: Type {
                                t_i32: true?,
                                ..nil,
                            },
                        },
                    ),
                }?,
                ..nil,
            },
        );

        return Typechecker {
            locals: make[map[string, Type]](),
            globals: globals,
            current_path: Path::new(),
        };
    }

    fun module_(self, m: Module): nil or error {
        for i in 0..m.decls.length {
            let d = m.decls.at(i);
            self.decl(d).try;
        }

        return nil;
    }

    fun path_to(self, ident: string): string {
        if self.current_path.path.length == 0 {
            return ident;
        }

        return self.current_path.join("_").concat("_").concat(ident);
    }

    fun decl(self, d: Decl): nil or error {
        if d.t_func != nil {
            // For recursive functions
            self.globals.insert(self.path_to(d.t_func!.name), d.t_func!.to_type());

            self.function(d.t_func!).try;

            self.globals.insert(self.path_to(d.t_func!.name), d.t_func!.to_type());
            return;
        }
        if d.t_let != nil {
            let t = self.expression(d.t_let!.expr).try;
            unify(t, d.t_let!.name_type).try;
            d.t_let!.name_type = t;

            self.globals.insert(d.t_let!.name, t);
            return;
        }
        if d.t_type != nil {
            self.globals.insert(d.t_type!.name, d.t_type!.type_);
            return;
        }
        if d.t_module != nil {
            let path = self.current_path.clone();
            self.current_path.push(d.t_module!.name);
            self.module_(d.t_module!.module_).try;
            self.current_path = path;
            return;
        }

        return _ or error::new(format("unimplemented: decl, {}", d.to_string()));
    }

    fun function(self, f: Function): nil or error {
        let locals = self.locals;
        self.locals = make[map[string, Type]]();

        for i in 0..f.params.length {
            let p = f.params.at(i);
            self.locals.insert(p.name, p.type_);
        }
        if f.variadic != nil {
            self.locals.insert(f.variadic!.name, f.variadic!.type_);
        }

        self.block(f.body, f.result_type).try;

        self.locals = locals;

        return nil;
    }

    fun block(self, b: Block, expected: Type): nil or error {
        for i in 0..b.block.length {
            let result = Type {
                t_omit: true?,
                ..nil,
            };
            self.statement(b.block.at(i), result).try;
        }

        return nil;
    }

    fun statement(self, s: Statement, result_type: Type): nil or error {
        if s.t_let != nil {
            let t = self.expression(s.t_let!.expr).try;
            unify(t, s.t_let!.name_type).try;
            s.t_let!.name_type = t;

            self.locals.insert(s.t_let!.name, t);
            return nil;
        } else if s.t_return != nil {
            let t = self.expression(s.t_return!.expr).try;
            unify(t, result_type).try;
            return nil;
        } else if s.t_expr != nil {
            let _t = self.expression(s.t_expr!.expr).try;
            return nil;
        } else if s.t_assign != nil {
            let lhs_type = self.expression_left_value(s.t_assign!.lhs).try;
            let rhs_type = Type {
                t_ptr: self.expression(s.t_assign!.rhs).try?,
                ..nil,
            };

            unify(lhs_type, rhs_type).try;
            return nil;
        } else if s.t_if != nil {
            let condition_type = self.expression(s.t_if!.condition).try;
            unify(
                condition_type,
                Type {
                    t_bool: true?,
                    ..nil,
                },
            ).try;

            let type_ = Type {
                t_omit: true?,
                ..nil,
            };
            self.block(s.t_if!.then_block, type_).try;
            if s.t_if!.else_block != nil {
                self.block(s.t_if!.else_block!, type_).try;
            }
            return nil;
        } else if s.t_while != nil {
            let condition_type = self.expression(s.t_while!.condition).try;
            unify(
                condition_type,
                Type {
                    t_bool: true?,
                    ..nil,
                },
            ).try;

            let type_ = Type {
                t_omit: true?,
                ..nil,
            };
            self.block(s.t_while!.block, type_).try;
            return nil;
        } else if s.t_for != nil {
            let t = self.expression(s.t_for!.range).try;
            if t.t_range != nil {
                // FIXME: clone
                let locals = self.locals;
                self.locals.insert(s.t_for!.ident, t.t_range!);

                self.block(
                    s.t_for!.block,
                    Type {
                        t_nil: true?,
                        ..nil,
                    },
                ).try;

                self.locals = locals;
                return nil;
            } else {
                return _ or error::new("for range must be range");
            }
        }

        return _ or error::new("unimplemented: statement, {}".format(s.to_string()));
    }

    fun expression_left_value(self, expr: Expression): Type or error {
        let t = self.expression(expr).try;

        return Type {
            t_ptr: t?,
            ..nil,
        };
    }

    fun expression(self, expr: Expression): Type or error {
        if expr.t_i32 != nil {
            return Type {
                t_i32: true?,
                ..nil,
            };
        } else if expr.t_binop != nil {
            if (expr.t_binop!.binop.equal("plus") || expr.t_binop!.binop.equal("minus") || expr.t_binop!.binop.equal(
                "mult",
            ) || expr.t_binop!.binop.equal("div") || expr.t_binop!.binop.equal("mod")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                unify(
                    t1,
                    Type {
                        t_i32: true?,
                        ..nil,
                    },
                ).try;

                let t2 = self.expression(expr.t_binop!.right).try;
                unify(
                    t2,
                    Type {
                        t_i32: true?,
                        ..nil,
                    },
                ).try;

                return t1;
            } else if (expr.t_binop!.binop.equal("equal") || expr.t_binop!.binop.equal("not_equal")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                let t2 = self.expression(expr.t_binop!.right).try;
                unify(t1, t2).try;

                return Type {
                    t_bool: true?,
                    ..nil,
                };
            } else if (expr.t_binop!.binop.equal("lt") || expr.t_binop!.binop.equal("gt")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                let t2 = self.expression(expr.t_binop!.right).try;
                unify(t1, t2).try;
                unify(
                    t1,
                    Type {
                        t_i32: true?,
                        ..nil,
                    },
                ).try;

                return Type {
                    t_bool: true?,
                    ..nil,
                };
            }

            return _ or error::new("unimplemented: binop, {}".format(expr.to_string()));
        } else if expr.t_ident != nil {
            if self.globals.has(expr.t_ident!.name) {
                let t = self.globals.at(expr.t_ident!.name);

                return t;
            } else if self.locals.has(expr.t_ident!.name) {
                let t = self.locals.at(expr.t_ident!.name);

                return t;
            }

            return _ or error::new("unbound identifier: ".concat(expr.t_ident!.name));
        } else if expr.t_call != nil {
            let callee_type = self.expression(expr.t_call!.callee).try;
            if callee_type.t_func != nil {
                let func_type = callee_type.t_func!;
                if func_type.params.length != expr.t_call!.args.length {
                    return _ or error::new("wrong number of arguments, {} != {}".format(
                        derive::to_string(func_type.params),
                        derive::to_string(expr.t_call!.args),
                    ));
                }

                for i in 0..expr.t_call!.args.length {
                    let arg = expr.t_call!.args.at(i);
                    let arg_type = self.expression(arg).try;
                    let param_type = func_type.params.at(i);

                    unify(arg_type, param_type).try;
                }

                return func_type.result;
            } else if callee_type.t_variadic_func != nil {
                let func_type = callee_type.t_variadic_func!;
                if func_type.params.length > expr.t_call!.args.length {
                    return _ or error::new("wrong number of arguments, {} != {}".format(
                        derive::to_string(func_type.params),
                        derive::to_string(expr.t_call!.args),
                    ));
                }

                let variadic_type = callee_type.t_variadic_func!.variadic.t_vec!;

                for i in 0..expr.t_call!.args.length {
                    let arg = expr.t_call!.args.at(i);
                    let arg_type = self.expression(arg).try;

                    if i < func_type.params.length {
                        let param_type = func_type.params.at(i);
                        unify(arg_type, param_type).try;
                    } else {
                        unify(arg_type, variadic_type).try;
                    }
                }

                expr.t_call!.variadic = struct {
                    element_type: variadic_type,
                    index: func_type.params.length,
                }?;

                return func_type.result;
            } else {
                return _ or error::new("not a function, {}".format(callee_type.to_string()));
            }
        } else if expr.t_project != nil {
            let t = self.expression(expr.t_project!.expr).try;
            expr.t_project!.type_ = t?;

            if t.t_ptr != nil {
                if expr.t_project!.field.equal("at") {
                    let ps = make[vec[Type]]();
                    ps.push(Type {
                        t_i32: true?,
                        ..nil,
                    });

                    return Type {
                        t_func: struct {
                            params: ps,
                            result: t.t_ptr!,
                        }?,
                        ..nil,
                    };
                }
            } else if t.t_vec != nil {
                if expr.t_project!.field.equal("length") {
                    return Type {
                        t_i32: true?,
                        ..nil,
                    };
                }
            }

            let label = expr.t_project!.field;

            let fields = self.resolve_record_type(t, make[vec[Type]]()).try;
            if fields.has(label) {
                // field access
                let t = fields.at(label);

                return t;
            } else if t.t_ident != nil {
                // method access

                let func_ident_name = t.t_ident!.concat("_").concat(label);
                if self.globals.has(func_ident_name) {
                    let t = self.globals.at(func_ident_name);
                    if t.t_func != nil {
                        let arg_types = t.t_func!.params;
                        let result_type = t.t_func!.result;

                        if arg_types.length == 0 {
                            return _ or error::new("method {} has no arguements".format(func_ident_name));
                        }

                        unify(arg_types.at(0), t).try;

                        return Type {
                            t_func: struct {
                                params: vec_slice(arg_types, 1, arg_types.length),
                                result: result_type,
                            }?,
                            ..nil,
                        };
                    }

                    return t;
                }
            }

            return _ or error::new("unimplemented: project, {}".format(expr.to_string()));
        } else if expr.t_record != nil {
            let t = self.globals.at(expr.t_record!.name);
            if t.t_struct == nil {
                return _ or error::new("unimplemented: record, {}".format(expr.to_string()));
            }

            for i in 0..t.t_struct!.fields.length {
                let field = t.t_struct!.fields.at(i);
                let expr_field = expr.t_record!.fields.at(i);
                let expr_type = self.expression(expr_field.value).try;

                unify(expr_type, field.type_).try;
            }

            for i in 0..expr.t_record!.fields.length {
                let field = expr.t_record!.fields.at(i);
                if !t.t_struct!.has(field.field) {
                    return _ or error::new("unknown field: {}".format(expr.to_string()));
                }
            }

            return t;
        } else if expr.t_make != nil {
            if expr.t_make!.args.length >= 2 {
                return _ or error::new("too many args for make, {}".format(expr.to_string()));
            }
            if expr.t_make!.args.length == 1 {
                let t = self.expression(expr.t_make!.args.at(0)).try;
                unify(
                    t,
                    Type {
                        t_i32: true?,
                        ..nil,
                    },
                ).try;
            }

            return expr.t_make!.type_;
        } else if expr.t_as != nil {
            let t = self.expression(expr.t_as!.expr).try;
            expr.t_as!.source_type = t;

            return expr.t_as!.target_type;
        } else if expr.t_self != nil {
            if self.current_path.path.length == 0 {
                return _ or error::new("self outside of function, {}".format(expr.to_string()));
            }

            let ident = self.current_path.path.at(self.current_path.path.length - 1);

            if ident.equal("i32") {
                return Type {
                    t_i32: true?,
                    ..nil,
                };
            } else {
                return Type {
                    t_ident: ident?,
                    ..nil,
                };
            }
        } else if expr.t_path != nil {
            let symbol = expr.t_path!.path.join("_");
            if self.globals.has(symbol) {
                return self.globals.at(symbol);
            }

            return _ or error::new("unknown symbol: {}".format(expr.to_string()));
        } else if expr.t_string != nil {
            return Type {
                t_ident: "string"?,
                ..nil,
            };
        } else if expr.t_paren != nil {
            return self.expression(expr.t_paren!).try;
        } else if expr.t_range != nil {
            let start = self.expression(expr.t_range!.start).try;
            let end = self.expression(expr.t_range!.end).try;

            unify(start, end).try;

            return Type {
                t_range: start?,
                ..nil,
            };
        } else if expr.t_bool != nil {
            return Type {
                t_bool: true?,
                ..nil,
            };
        } else if expr.t_wrap != nil {
            let t = self.expression(expr.t_wrap!.expr).try;
            expr.t_wrap!.type_ = t;

            return Type {
                t_optional: t?,
                ..nil,
            };
        } else if expr.t_unwrap != nil {
            let t = self.expression(expr.t_unwrap!.expr).try;

            if t.t_optional != nil {
                let wrapped = Type {
                    t_optional: expr.t_unwrap!.type_?,
                    ..nil,
                };
                let unified = unify(wrapped, t).try;
                let element_type = unified.t_optional!;
                expr.t_unwrap!.type_ = element_type;

                return element_type;
            } else {
                return _ or error::new("unimplemented: unwrap, {}".format(expr.to_string()));
            }
        } else if expr.t_nil != nil {
            return Type {
                t_nil: true?,
                ..nil,
            };
        } else {
            return _ or error::new("unimplemented: expression, {}".format(expr.to_string()));
        }
    }

    fun resolve_record_type(self, type_: Type, args: vec[Type]): map[string, Type] or error {
        if type_.t_ident != nil {
            let ident_type = self.globals.at(type_.t_ident!).t_struct!;

            let result = make[map[string, Type]]();
            for i in 0..ident_type.fields.length {
                let field = ident_type.fields.at(i);

                result.insert(field.name, field.type_);
            }

            return result;
        } else if type_.t_struct != nil {
            let result = make[map[string, Type]]();
            let fields = type_.t_struct!.fields;

            for i in 0..fields.length {
                let field = fields.at(i);

                result.insert(field.name, field.type_);
            }

            return result;
        } else if type_.t_vec != nil {
            return self.resolve_record_type(
                Type {
                    t_ident: "vec"?,
                    ..nil,
                },
                args,
            );
        }

        return _ or error::new("unimplemented: resolve_record_type, {}".format(type_.to_string()));
    }
}

fun unify(type1: Type, type2: Type): Type or error {
    if type1.t_i32 != nil && type2.t_i32 != nil {
        return type1;
    }
    if type1.t_nil != nil && type2.t_nil != nil {
        return type1;
    }
    if type1.t_bool != nil && type2.t_bool != nil {
        return type1;
    }
    if type1.t_byte != nil && type2.t_byte != nil {
        return type1;
    }
    if type1.t_ident != nil && type2.t_ident != nil {
        if !type1.t_ident!.equal(type2.t_ident!) {
            return _ or error::new("unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string(
            )));
        }

        return type1;
    }
    if type1.t_ptr != nil && type2.t_ptr != nil {
        let result = unify(type1.t_ptr!, type2.t_ptr!).try;

        return Type {
            t_ptr: result?,
            ..nil,
        };
    }
    if type1.t_optional != nil && type2.t_optional != nil {
        let result = unify(type1.t_optional!, type2.t_optional!).try;

        return Type {
            t_optional: result?,
            ..nil,
        };
    }
    if type1.t_omit != nil {
        return type2;
    }
    if type2.t_omit != nil {
        return type1;
    }
    if type1.t_nil != nil && type2.t_optional != nil {
        return type2;
    }
    if type2.t_nil != nil && type1.t_optional != nil {
        return type1;
    }

    return _ or error::new("unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string(
    )));
}

