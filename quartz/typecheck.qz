import quartz::ast;
import quartz::path;
import quartz::location;

struct Typechecker {
    locals: map[string, LType],
    globals: map[string, LType],
    current_path: Path,
    imported: vec[Path],
    result_type: Type?,
    search_node: struct {
        path: Path,
        cursor: i32,
    }?,
    search_node_type: Type?,
    search_node_definition: struct {
        path: Path,
        start: i32,
        end: i32,
    }?,
    completed: vec[struct {
        kind: string,
        label: string,
        text: string,
    }]?,
    types_def: map[string, struct {
        path: Path,
        fields: vec[struct {
            data: struct {
                name: string,
                type_: Type,
            },
            location: Location,
        }],
    }],
}

module Typechecker {
    fun new(): Typechecker {
        let globals = make[map[string, LType]]();
        globals.insert(
            "string",
            LType {
                data: Type {
                    t_struct: TypeStruct {
                        fields: make[vec[struct {
                            data: struct {
                                name: string,
                                type_: Type,
                            },
                            location: Location,
                        }]](
                            struct {
                                data: struct {
                                    name: "data",
                                    type_: Type {
                                        t_ptr: Type {
                                            t_byte: true,
                                        },
                                    },
                                },
                                location: Location::unknown(),
                            },
                            struct {
                                data: struct {
                                    name: "length",
                                    type_: Type {
                                        t_i32: true,
                                    },
                                },
                                location: Location::unknown(),
                            },
                        ),
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "println",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_ident: "string",
                        }),
                        result: Type {
                            t_nil: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "vec",
            LType {
                data: Type {
                    t_struct: TypeStruct {
                        fields: make[vec[struct {
                            data: struct {
                                name: string,
                                type_: Type,
                            },
                            location: Location,
                        }]](
                            struct {
                                data: struct {
                                    name: "data",
                                    type_: Type {
                                        t_ptr: Type {
                                            t_any: true,
                                        },
                                    },
                                },
                                location: Location::unknown(),
                            },
                            struct {
                                data: struct {
                                    name: "length",
                                    type_: Type {
                                        t_i32: true,
                                    },
                                },
                                location: Location::unknown(),
                            },
                            struct {
                                data: struct {
                                    name: "capacity",
                                    type_: Type {
                                        t_i32: true,
                                    },
                                },
                                location: Location::unknown(),
                            },
                        ),
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "debug",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_any: true,
                        }),
                        result: Type {
                            t_nil: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "debug_i32",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_i32: true,
                        }),
                        result: Type {
                            t_nil: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "abort",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](),
                        result: Type {
                            t_nil: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "xor_u32",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_u32: true,
                            },
                            Type {
                                t_u32: true,
                            },
                        ),
                        result: Type {
                            t_u32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "reflection_get_type_rep_id",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_any: true,
                        }),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_reflection_is_pointer",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_any: true,
                        }),
                        result: Type {
                            t_bool: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_reflection_is_bool",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_any: true,
                        }),
                        result: Type {
                            t_bool: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "i64_to_string_at",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                        ),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "get_args_len",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "get_args_at",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_i32: true,
                        }),
                        result: Type {
                            t_byte: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_fd_read",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_byte: true,
                                },
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_byte: true,
                                },
                            },
                        ),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_fd_filestat_get",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_byte: true,
                                },
                            },
                        ),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_fd_write",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_any: true,
                                },
                            },
                            Type {
                                t_ptr: Type {
                                    t_i32: true,
                                },
                            },
                        ),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "set_ciovec",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_ptr: Type {
                                    t_byte: true,
                                },
                            },
                            Type {
                                t_ptr: Type {
                                    t_any: true,
                                },
                            },
                            Type {
                                t_i32: true,
                            },
                        ),
                        result: Type {
                            t_nil: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        globals.insert(
            "_path_open",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_byte: true,
                                },
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_i32: true,
                            },
                            Type {
                                t_ptr: Type {
                                    t_i32: true,
                                },
                            },
                        ),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );
        // dirfd

        // dirflags

        // path

        // path_len

        // o_flags

        // fs_rights_base

        // fs_rights_inheriting

        // fs_flags

        // *fd

        globals.insert(
            "_fd_close",
            LType {
                data: Type {
                    t_func: struct {
                        params: make[vec[Type]](Type {
                            t_i32: true,
                        }),
                        result: Type {
                            t_i32: true,
                        },
                    },
                },
                location: Location::unknown(),
            },
        );

        return Typechecker {
            locals: make[map[string, LType]](),
            globals: globals,
            current_path: Path::new(),
            imported: make[vec[Path]](Path::new("quartz", "std")),
            result_type: nil,
            search_node: nil,
            search_node_type: nil,
            search_node_definition: nil,
            completed: nil,
            types_def: make[map[string, struct {
                path: Path,
                fields: vec[struct {
                    data: struct {
                        name: string,
                        type_: Type,
                    },
                    location: Location,
                }],
            }]](),
        };
    }

    fun module_(self, m: Module): nil or error {
        self.module_register_for_back_reference(m).try;

        for i in 0..m.decls.length {
            let d = m.decls.at(i);
            let result or err = self.decl(d);
            if result != nil || self.search_node == nil {
                if err != nil {
                    return _ or err!;
                }
            }
        }

        return nil;
    }

    fun module_register_for_back_reference(self, m: Module): nil or error {
        for i in 0..m.decls.length {
            let decl = m.decls.at(i);
            let d = decl.data;
            if d.t_func != nil {
                self.globals.insert(
                    self.path_to(d.t_func!.name),
                    LType {
                        data: d.t_func!.to_type(),
                        location: decl.location,
                    },
                );

                continue;
            } else if d.t_let != nil {
                self.globals.insert(
                    self.path_to(d.t_let!.name),
                    LType {
                        data: d.t_let!.name_type,
                        location: decl.location,
                    },
                );

                continue;
            } else if d.t_type != nil {
                self.globals.insert(
                    d.t_type!.name,
                    LType {
                        data: d.t_type!.type_,
                        location: decl.location,
                    },
                );
                self.types_def.insert(
                    d.t_type!.name,
                    struct {
                        path: self.current_path.clone(),
                        fields: d.t_type!.type_.t_struct!.fields,
                    },
                );

                continue;
            } else if d.t_enum != nil {
                self.globals.insert(
                    d.t_enum!.name,
                    LType {
                        data: d.t_enum!.type_,
                        location: decl.location,
                    },
                );
                self.types_def.insert(
                    d.t_enum!.name,
                    struct {
                        path: self.current_path.clone(),
                        fields: d.t_enum!.type_.t_enum!.fields,
                    },
                );

                continue;
            } else if d.t_module != nil {
                let path = self.current_path.clone();
                self.current_path.extend(d.t_module!.path);
                self.module_register_for_back_reference(d.t_module!.module_).try;
                self.current_path = path;

                continue;
            } else if d.t_import != nil {
                self.imported.push(d.t_import!);

                continue;
            } else {
                return _ or error::new("Unknown decl type, {}".format(d.to_string()));
            }
        }

        return nil;
    }

    fun path_to(self, ident: string): string {
        if self.current_path.path.length == 0 {
            return ident;
        }

        return self.current_path.join("_").concat("_").concat(ident);
    }

    fun decl(self, ld: LDecl): nil or error {
        let d = ld.data;
        if d.t_func != nil {
            // For recursive functions
            self.globals.insert(
                self.path_to(d.t_func!.name),
                LType {
                    data: d.t_func!.to_type(),
                    location: ld.location,
                },
            );

            self.function(d.t_func!).try;

            self.globals.insert(
                self.path_to(d.t_func!.name),
                LType {
                    data: d.t_func!.to_type(),
                    location: ld.location,
                },
            );
            return;
        }
        if d.t_let != nil {
            let t = self.expression(d.t_let!.expr).try;
            let type_ = unify(t, d.t_let!.name_type).try;
            d.t_let!.name_type = type_;

            self.globals.insert(
                self.path_to(d.t_let!.name),
                LType {
                    data: type_,
                    location: ld.location,
                },
            );
            return;
        }
        if d.t_type != nil {
            self.globals.insert(
                d.t_type!.name,
                LType {
                    data: d.t_type!.type_,
                    location: ld.location,
                },
            );
            return;
        }
        if d.t_enum != nil {
            self.globals.insert(
                d.t_enum!.name,
                LType {
                    data: d.t_enum!.type_,
                    location: ld.location,
                },
            );
            return;
        }
        if d.t_module != nil {
            let path = self.current_path.clone();
            self.current_path.extend(d.t_module!.path);
            self.module_(d.t_module!.module_).try;
            self.current_path = path;
            return;
        }
        if d.t_import != nil {
            self.imported.push(d.t_import!);
            return;
        }

        return _ or error::new(format("unimplemented: decl, {}", d.to_string()));
    }

    fun function(self, f: Function): nil or error {
        let locals = self.locals;
        self.locals = make[map[string, LType]]();

        for i in 0..f.params.length {
            let p = f.params.at(i);

            // FIXME: set argument location
            self.locals.insert(
                p.name,
                LType {
                    data: p.type_,
                    location: f.body.location,
                },
            );
        }
        if f.variadic != nil {
            self.locals.insert(
                f.variadic!.name,
                LType {
                    data: f.variadic!.type_,
                    location: f.body.location,
                },
            );
        }

        self.result_type = f.result_type?;
        self.block(f.body).try;

        self.locals = locals;

        return nil;
    }

    fun block(self, b: LBlock): nil or error {
        for i in 0..b.data.block.length {
            let result = Type {
                t_omit: true,
            };

            self.statement(b.data.block.at(i)).try;
        }

        return nil;
    }

    fun statement(self, ls: LStatement): nil or error {
        if self.search_node != nil {
            if self.is_search_finished(ls.location, self.search_node!) {
                return nil;
            }
        }

        let s = ls.data;

        if s.t_let != nil {
            let t = self.expression(s.t_let!.expr).try;
            let type_ = unify(t, s.t_let!.name_type).try;
            s.t_let!.name_type = type_;

            self.register_locals_with_pattern(s.t_let!.pattern, type_).try;
            return nil;
        } else if s.t_return != nil {
            let t = self.expression(s.t_return!.expr).try;
            let result or err = unify(t, self.result_type!);
            if result != nil {
                self.result_type = result!?;
            } else if err != nil {
                if self.result_type!.t_or != nil {
                    unify(self.result_type!.t_or!.left, t).try;

                    s.t_return!.expr = LExpression {
                        data: Expression {
                            t_enumor: struct {
                                lhs: s.t_return!.expr?,
                                rhs: nil as LExpression?,
                                lhs_type: self.result_type!.t_or!.left,
                                rhs_type: self.result_type!.t_or!.right,
                            },
                        },
                        location: s.t_return!.expr.location,
                    };
                } else {
                    return _ or err!;
                }
            }

            return nil;
        } else if s.t_expr != nil {
            let _t = self.expression(s.t_expr!.expr).try;
            return nil;
        } else if s.t_assign != nil {
            let lhs_type = self.expression_left_value(s.t_assign!.lhs).try;
            let rhs_type = Type {
                t_ptr: self.expression(s.t_assign!.rhs).try,
            };

            let r = unify(lhs_type, rhs_type).try;
            s.t_assign!.rhs_type = r?;

            return nil;
        } else if s.t_if != nil {
            let condition_type = self.expression(s.t_if!.condition).try;
            unify(
                condition_type,
                Type {
                    t_bool: true,
                },
            ).try;

            let type_ = Type {
                t_omit: true,
            };
            self.block(s.t_if!.then_block).try;
            if s.t_if!.else_block != nil {
                self.block(s.t_if!.else_block!).try;
            }
            return nil;
        } else if s.t_while != nil {
            let condition_type = self.expression(s.t_while!.condition).try;
            unify(
                condition_type,
                Type {
                    t_bool: true,
                },
            ).try;

            let type_ = Type {
                t_omit: true,
            };
            self.block(s.t_while!.block).try;

            return nil;
        } else if s.t_for != nil {
            let t = self.expression(s.t_for!.range).try;
            if t.t_range != nil {
                s.t_for!.mode = "range";

                // FIXME: clone
                let locals = self.locals;
                self.locals.insert(
                    s.t_for!.ident,
                    LType {
                        data: t.t_range!,
                        location: s.t_for!.range.location,
                    },
                );

                self.block(s.t_for!.block).try;

                self.locals = locals;
                return nil;
            } else if t.t_vec != nil {
                s.t_for!.mode = "vec";
                s.t_for!.type_ = t?;

                // FIXME: clone
                let locals = self.locals;
                self.locals.insert(
                    s.t_for!.ident,
                    LType {
                        data: t.t_vec!,
                        location: s.t_for!.range.location,
                    },
                );

                self.block(s.t_for!.block).try;

                self.locals = locals;
                return nil;
            } else {
                return _ or error::new("for range must be range, {}".format(t.to_string()));
            }
        } else if s.t_continue != nil {
            return nil;
        } else if s.t_break != nil {
            return nil;
        }

        return _ or error::new("unimplemented: statement, {}".format(s.to_string()));
    }

    fun register_locals_with_pattern(self, lpattern: LPattern, type_: Type): nil or error {
        let pattern = lpattern.data;
        if pattern.t_ident != nil {
            self.locals.insert(
                pattern.t_ident!,
                LType {
                    data: type_,
                    location: lpattern.location,
                },
            );
            self.set_search_node_type(type_, lpattern.location);
        } else if pattern.t_or != nil {
            if type_.t_or != nil {
                self.register_locals_with_pattern(
                    pattern.t_or!.lhs,
                    Type {
                        t_optional: type_.t_or!.left,
                    },
                ).try;
                self.register_locals_with_pattern(
                    pattern.t_or!.rhs,
                    Type {
                        t_optional: type_.t_or!.right,
                    },
                ).try;
            } else {
                return _ or error::new("unimplemented: pattern, {}".format(pattern.to_string()));
            }
        } else {
            return _ or error::new("unimplemented: pattern, {}".format(pattern.to_string()));
        }

        return nil;
    }

    fun expression_left_value(self, expr: LExpression): Type or error {
        let t = self.expression(expr).try;

        return Type {
            t_ptr: t,
        };
    }

    fun expression(self, lexpr: LExpression): Type or error {
        let expr = lexpr.data;

        if expr.t_i32 != nil {
            let result = Type {
                t_i32: true,
            };
            self.set_search_node_type(result, lexpr.location);

            return result;
        } else if expr.t_u32 != nil {
            let result = Type {
                t_u32: true,
            };
            self.set_search_node_type(result, lexpr.location);

            return result;
        } else if expr.t_unop != nil {
            let t = self.expression(expr.t_unop!.expr).try;
            unify(
                t,
                Type {
                    t_bool: true,
                },
            ).try;

            return Type {
                t_bool: true,
            };
        } else if expr.t_binop != nil {
            if (expr.t_binop!.binop.equal("plus") || expr.t_binop!.binop.equal("minus") || expr.t_binop!.binop.equal(
                "mult",
            ) || expr.t_binop!.binop.equal("div") || expr.t_binop!.binop.equal("mod") || expr.t_binop!.binop.equal(
                "bit_and",
            ) || expr.t_binop!.binop.equal("bit_or") || expr.t_binop!.binop.equal("bit_shift_left") || expr.t_binop!.binop.equal(
                "bit_shift_right",
            )) {
                let t1 = self.expression(expr.t_binop!.left).try;
                if !t1.is_integer_type() {
                    return _ or error::new(
                        "left operand must be integer type, but got {}".format(t1.to_string()),
                    );
                }

                let t2 = self.expression(expr.t_binop!.right).try;
                let r = unify(t1, t2).try;
                expr.t_binop!.type_ = r?;

                return r;
            } else if (expr.t_binop!.binop.equal("equal") || expr.t_binop!.binop.equal("not_equal")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                let t2 = self.expression(expr.t_binop!.right).try;
                let r = unify(t1, t2).try;
                expr.t_binop!.type_ = r?;

                return Type {
                    t_bool: true,
                };
            } else if (expr.t_binop!.binop.equal("lt") || expr.t_binop!.binop.equal("gt") || expr.t_binop!.binop.equal(
                "lte",
            ) || expr.t_binop!.binop.equal("gte")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                let t2 = self.expression(expr.t_binop!.right).try;
                if !t1.is_integer_type() {
                    return _ or error::new(
                        "left operand must be integer type, but got {}".format(t1.to_string()),
                    );
                }

                let r = unify(t1, t2).try;
                expr.t_binop!.type_ = r?;

                return Type {
                    t_bool: true,
                };
            } else if (expr.t_binop!.binop.equal("and") || expr.t_binop!.binop.equal("or")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                unify(
                    t1,
                    Type {
                        t_bool: true,
                    },
                ).try;

                let t2 = self.expression(expr.t_binop!.right).try;
                let r = unify(
                    t2,
                    Type {
                        t_bool: true,
                    },
                ).try;

                expr.t_binop!.type_ = r?;

                return Type {
                    t_bool: true,
                };
            }

            return _ or error::new("unimplemented: binop, {}".format(expr.to_string()));
        } else if expr.t_ident != nil {
            if self.locals.has(expr.t_ident!.name) {
                let t = self.locals.at(expr.t_ident!.name);
                self.set_search_node_type(t.data, lexpr.location);
                self.set_search_node_definition(self.current_path, t.location, lexpr.location);
                self.set_completion(t.data, lexpr.location).try;

                return t.data;
            }

            let candidates = vec_clone(self.imported) as vec[Path];
            candidates.push(self.current_path);
            candidates.push(Path::ident("main"));

            for path_prefix in candidates {
                let path = path_prefix.clone();
                path.push(expr.t_ident!.name);

                if self.globals.has(path.join("_")) {
                    expr.t_ident!.resolved_path = path?;

                    let t = self.globals.at(path.join("_"));
                    self.set_search_node_type(t.data, lexpr.location);
                    self.set_search_node_definition(self.current_path, t.location, lexpr.location);

                    return t.data;
                }
            }

            if self.globals.has(expr.t_ident!.name) {
                let t = self.globals.at(expr.t_ident!.name);
                self.set_search_node_type(t.data, lexpr.location);
                self.set_search_node_definition(self.current_path, t.location, lexpr.location);

                return t.data;
            }

            return _ or error::new("unbound identifier: {}".format(expr.t_ident!.name));
        } else if expr.t_call != nil {
            let callee_type = self.expression(expr.t_call!.callee).try;
            if callee_type.t_func != nil {
                let func_type = callee_type.t_func!;
                if func_type.params.length != expr.t_call!.args.length {
                    return _ or error::new("wrong number of arguments, {} != {}".format(
                        derive::to_string(func_type.params),
                        derive::to_string(expr.t_call!.args),
                    ));
                }

                for i in 0..expr.t_call!.args.length {
                    let arg = expr.t_call!.args.at(i);
                    let arg_type = self.expression(arg).try;
                    let param_type = func_type.params.at(i);

                    unify(arg_type, param_type).try;
                }

                return func_type.result;
            } else if callee_type.t_variadic_func != nil {
                let func_type = callee_type.t_variadic_func!;
                if func_type.params.length > expr.t_call!.args.length {
                    return _ or error::new("wrong number of arguments, {} != {}".format(
                        derive::to_string(func_type.params),
                        derive::to_string(expr.t_call!.args),
                    ));
                }

                let variadic_type = callee_type.t_variadic_func!.variadic.t_vec!;

                for i in 0..expr.t_call!.args.length {
                    let arg = expr.t_call!.args.at(i);
                    let arg_type = self.expression(arg).try;

                    if i < func_type.params.length {
                        let param_type = func_type.params.at(i);
                        unify(arg_type, param_type).try;
                    } else {
                        unify(arg_type, variadic_type).try;
                    }
                }

                expr.t_call!.variadic = struct {
                    element_type: variadic_type,
                    index: func_type.params.length,
                }?;

                return func_type.result;
            } else {
                return _ or error::new("not a function, {}".format(callee_type.to_string()));
            }
        } else if expr.t_project != nil {
            let t = self.expression(expr.t_project!.expr).try;
            expr.t_project!.type_ = t?;

            if t.t_ptr != nil {
                if expr.t_project!.field.data.equal("at") {
                    let ps = make[vec[Type]]();
                    ps.push(Type {
                        t_i32: true,
                    });

                    return Type {
                        t_func: struct {
                            params: ps,
                            result: t.t_ptr!,
                        },
                    };
                } else if expr.t_project!.field.data.equal("offset") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](Type {
                                t_i32: true,
                            }),
                            result: t,
                        },
                    };
                }
            } else if t.t_vec != nil {
                if expr.t_project!.field.data.equal("push") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](t.t_vec!),
                            result: Type {
                                t_nil: true,
                            },
                        },
                    };
                } else if expr.t_project!.field.data.equal("at") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](Type {
                                t_i32: true,
                            }),
                            result: t.t_vec!,
                        },
                    };
                } else if expr.t_project!.field.data.equal("extend") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](t),
                            result: Type {
                                t_nil: true,
                            },
                        },
                    };
                } else if expr.t_project!.field.data.equal("slice") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](
                                Type {
                                    t_i32: true,
                                },
                                Type {
                                    t_i32: true,
                                },
                            ),
                            result: t,
                        },
                    };
                }
            } else if t.t_map != nil {
                if expr.t_project!.field.data.equal("insert") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](t.t_map!.key, t.t_map!.value),
                            result: Type {
                                t_nil: true,
                            },
                        },
                    };
                } else if expr.t_project!.field.data.equal("at") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](t.t_map!.key),
                            result: t.t_map!.value,
                        },
                    };
                } else if expr.t_project!.field.data.equal("has") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](t.t_map!.key),
                            result: Type {
                                t_bool: true,
                            },
                        },
                    };
                } else if expr.t_project!.field.data.equal("list_keys") {
                    return Type {
                        t_func: struct {
                            params: make[vec[Type]](),
                            result: Type {
                                t_vec: t.t_map!.key,
                            },
                        },
                    };
                }
            }

            let label = expr.t_project!.field;

            let fields = self.resolve_record_type(t, make[vec[Type]]()).try;

            if fields.has(label.data) {
                // field access
                let t = fields.at(label.data);

                // FIXME: use label_path
                let label_path = label.location;
                self.set_search_node_type(t, label.location);
                self.set_completion(t, label.location).try;
                if expr.t_project!.type_!.t_ident != nil {
                    let type_ident = expr.t_project!.type_!.t_ident!;
                    if self.types_def.has(type_ident) {
                        let def = self.types_def.at(type_ident);
                        self.set_search_node_definition(def.path, lexpr.location, label_path);
                    }
                }

                return t;
            } else {
                let type_name = "";
                if t.t_ident != nil {
                    type_name = t.t_ident!;
                } else if t.t_i32 != nil {
                    type_name = "i32";
                } else if t.t_u32 != nil {
                    type_name = "u32";
                } else if t.t_bool != nil {
                    type_name = "bool";
                } else {
                    return _ or error::new("unknown type: {}.{}".format(t.to_string(), label.data));
                }

                // method access

                let func_ident_name = type_name.concat("_").concat(label.data);
                let resolved = self.resolve_path(Path::ident(func_ident_name)).try;
                let path = resolved.path;
                expr.t_project!.resolved_path = path?;

                self.set_search_node_type(resolved.type_.data, label.location);
                // FIXME: need to strip current package path
                self.set_search_node_definition(
                    Path::new(path.path.at(0), path.path.at(1)),
                    resolved.type_.location,
                    label.location,
                );

                if self.globals.has(path.join("_")) {
                    let t = self.globals.at(path.join("_")).data;
                    if t.t_func != nil {
                        let arg_types = t.t_func!.params;
                        let result_type = t.t_func!.result;

                        if arg_types.length == 0 {
                            return _ or error::new("method {} has no arguements".format(path.join("_")));
                        }

                        unify(arg_types.at(0), t).try;

                        return Type {
                            t_func: struct {
                                params: vec_slice(arg_types, 1, arg_types.length),
                                result: result_type,
                            },
                        };
                    } else if t.t_variadic_func != nil {
                        let arg_types = t.t_variadic_func!.params;
                        let result_type = t.t_variadic_func!.result;

                        if arg_types.length == 0 {
                            return _ or error::new("method {} has no arguements".format(path.join("_")));
                        }

                        unify(arg_types.at(0), t).try;

                        return Type {
                            t_variadic_func: struct {
                                params: vec_slice(arg_types, 1, arg_types.length),
                                result: result_type,
                                variadic: t.t_variadic_func!.variadic,
                            },
                        };
                    }

                    return t;
                } else {
                    return _ or error::new("method not found: {}".format(func_ident_name));
                }
            }

            return _ or error::new("unimplemented: project, {}".format(expr.to_string()));
        } else if expr.t_record != nil {
            let field_map = self.resolve_record_type(
                Type {
                    t_ident: expr.t_record!.name,
                },
                make[vec[Type]](),
            ).try;

            if self.globals.has(expr.t_record!.name) {
                let t = self.globals.at(expr.t_record!.name).data;
                if t.t_enum != nil {
                    if expr.t_record!.fields.length != 1 {
                        return _ or error::new("enum {} has {} fields, expected 1".format(
                            expr.t_record!.name,
                            expr.t_record!.fields.length.to_string(),
                        ));
                    }

                    let value_type = field_map.at(expr.t_record!.fields.at(0).field);

                    if value_type.t_optional != nil {
                        let t = self.expression(expr.t_record!.fields.at(0).value).try;
                        unify(t, value_type.t_optional!).try;
                    } else {
                        return _ or error::new("expected optional, {}".format(expr.to_string()));
                    }

                    return Type {
                        t_ident: expr.t_record!.name,
                    };
                }
            }

            let fields = field_map.list_keys();
            let expr_fields_map = expr.t_record!.to_fields_map();
            for field in fields {
                if expr_fields_map.has(field) {
                    let expr_field = expr_fields_map.at(field);
                    let expr_type = self.expression(expr_field).try;

                    unify(expr_type, field_map.at(field)).try;
                } else if expr.t_record!.expansion != nil {
                    let expr_type = self.expression(expr.t_record!.expansion!).try;
                    unify(expr_type, field_map.at(field)).try;
                } else {
                    return _ or error::new("missing field: {}".format(field));
                }
            }

            return Type {
                t_ident: expr.t_record!.name,
            };
        } else if expr.t_anonymous_record != nil {
            let record_type = make[vec[struct {
                data: struct {
                    name: string,
                    type_: Type,
                },
                location: Location,
            }]]();

            for field in expr.t_anonymous_record!.fields {
                let t = self.expression(field.data.value).try;
                record_type.push(struct {
                    data: struct {
                        name: field.data.field,
                        type_: t,
                    },
                    location: field.location,
                });
            }

            let t = Type {
                t_struct: TypeStruct {
                    fields: record_type,
                },
            };
            expr.t_anonymous_record!.type_ = t?;

            return t;
        } else if expr.t_make != nil {
            if expr.t_make!.type_.t_ptr != nil {
                if expr.t_make!.args.length >= 2 {
                    return _ or error::new("too many args for make, {}".format(expr.to_string()));
                }

                unify(
                    self.expression(expr.t_make!.args.at(0)).try,
                    Type {
                        t_i32: true,
                    },
                ).try;
            } else if expr.t_make!.type_.t_vec != nil {
                for arg in expr.t_make!.args {
                    let t = self.expression(arg).try;

                    unify(t, expr.t_make!.type_.t_vec!).try;
                }
            }

            return expr.t_make!.type_;
        } else if expr.t_as != nil {
            let t = self.expression(expr.t_as!.expr).try;
            expr.t_as!.source_type = t;

            return expr.t_as!.target_type;
        } else if expr.t_sizeof != nil {
            return Type {
                t_i32: true,
            };
        } else if expr.t_self != nil {
            if self.current_path.path.length == 0 {
                return _ or error::new("self outside of function, {}".format(expr.to_string()));
            }

            let ident = self.current_path.path.at(self.current_path.path.length - 1);

            if ident.equal("i32") {
                return Type {
                    t_i32: true,
                };
            } else if ident.equal("u32") {
                return Type {
                    t_u32: true,
                };
            } else {
                return Type {
                    t_ident: ident,
                };
            }
        } else if expr.t_path != nil {
            let path = expr.t_path!.path;
            let resolved_path = self.resolve_path(path).try.path;
            expr.t_path!.resolved_path = resolved_path?;

            let result = self.globals.at(resolved_path.join("_"));
            self.set_search_node_type(result.data, lexpr.location);
            // FIXME: need to strip current package path
            self.set_search_node_definition(
                Path::new(resolved_path.path.at(0), resolved_path.path.at(1)),
                result.location,
                lexpr.location,
            );

            return result.data;
        } else if expr.t_string != nil {
            let r = Type {
                t_ident: "string",
            };
            self.set_search_node_type(r, lexpr.location);

            return r;
        } else if expr.t_paren != nil {
            return self.expression(expr.t_paren!).try;
        } else if expr.t_range != nil {
            let start = self.expression(expr.t_range!.start).try;
            let end = self.expression(expr.t_range!.end).try;

            unify(start, end).try;

            return Type {
                t_range: start,
            };
        } else if expr.t_bool != nil {
            let r = Type {
                t_bool: true,
            };
            self.set_search_node_type(r, lexpr.location);

            return r;
        } else if expr.t_wrap != nil {
            let t = self.expression(expr.t_wrap!.expr).try;
            expr.t_wrap!.type_ = t;

            return Type {
                t_optional: t,
            };
        } else if expr.t_unwrap != nil {
            let t = self.expression(expr.t_unwrap!.expr).try;

            if t.t_optional != nil {
                let wrapped = Type {
                    t_optional: expr.t_unwrap!.type_,
                };
                let unified = unify(wrapped, t).try;
                let element_type = unified.t_optional!;
                expr.t_unwrap!.type_ = element_type;

                return element_type;
            } else {
                return _ or error::new("unimplemented: unwrap, {}".format(expr.to_string()));
            }
        } else if expr.t_nil != nil {
            return Type {
                t_nil: true,
            };
        } else if expr.t_enumor != nil {
            let lhs_type = Type {
                t_any: true,
            };
            if expr.t_enumor!.lhs != nil {
                lhs_type = self.expression(expr.t_enumor!.lhs!).try;
            }
            expr.t_enumor!.lhs_type = lhs_type;

            let rhs_type = Type {
                t_any: true,
            };
            if expr.t_enumor!.rhs != nil {
                rhs_type = self.expression(expr.t_enumor!.rhs!).try;
            }
            expr.t_enumor!.rhs_type = rhs_type;

            return Type {
                t_or: struct {
                    left: lhs_type,
                    right: rhs_type,
                },
            };
        } else if expr.t_try != nil {
            let t = self.expression(expr.t_try!).try;

            if t.t_or != nil {
                let lhs = t.t_or!.left;
                let rhs = t.t_or!.right;

                if self.result_type == nil {
                    return _ or error::new("try outside of function, {}".format(expr.to_string()));
                }

                let t = unify(
                    self.result_type!,
                    Type {
                        t_or: struct {
                            left: Type {
                                t_any: true,
                            },
                            right: rhs,
                        },
                    },
                ).try;
                self.result_type = t?;

                return lhs;
            } else {
                return _ or error::new("unimplemented: try, {}".format(expr.to_string()));
            }
        } else {
            return _ or error::new("unimplemented: expression, {}".format(expr.to_string()));
        }
    }

    fun resolve_record_type(self, type_: Type, args: vec[Type]): map[string, Type] or error {
        if type_.t_ident != nil {
            return self.resolve_record_type(self.globals.at(type_.t_ident!).data, make[vec[Type]]()).try;
        } else if type_.t_struct != nil {
            let result = make[map[string, Type]]();
            let fields = type_.t_struct!.fields;

            for i in 0..fields.length {
                let field = fields.at(i).data;

                result.insert(field.name, field.type_);
            }

            return result;
        } else if type_.t_enum != nil {
            let fields = make[map[string, Type]]();
            if type_.t_enum != nil {
                for field in type_.t_enum!.fields {
                    fields.insert(
                        field.data.name,
                        Type {
                            t_optional: field.data.type_,
                        },
                    );
                }
            }

            return fields;
        } else if type_.t_vec != nil {
            let m = self.resolve_record_type(
                Type {
                    t_ident: "vec",
                },
                args,
            ).try;

            // FIXME: hack for generics
            m.insert(
                "data",
                Type {
                    t_ptr: type_.t_vec!,
                },
            );

            return m;
        } else if type_.t_i32 != nil {
            return make[map[string, Type]]();
        } else if type_.t_ptr != nil {
            return make[map[string, Type]]();
        } else if type_.t_bool != nil {
            return make[map[string, Type]]();
        } else if type_.t_nil != nil {
            return make[map[string, Type]]();
        } else if type_.t_or != nil {
            return make[map[string, Type]]();
        } else if type_.t_u32 != nil {
            return make[map[string, Type]]();
        } else if type_.t_byte != nil {
            return make[map[string, Type]]();
        }

        return _ or error::new("unimplemented: resolve_record_type, {}".format(type_.to_string()));
    }

    fun resolve_path(
        self,
        specified: Path,
    ): struct {
        path: Path,
        type_: LType,
    } or error {
        let candidates = vec_clone(self.imported) as vec[Path];
        candidates.push(self.current_path);
        candidates.push(Path::ident("main"));

        for path_prefix in candidates {
            let path = path_prefix.clone();
            path.extend(specified);

            if self.globals.has(path.join("_")) {
                return struct {
                    path: path,
                    type_: self.globals.at(path.join("_")),
                };
            }
        }

        return _ or error::new("unknown symbol: {}".format(specified.join("_")));
    }

    // for LSP
    fun find_at_cursor(self, module_: Module, path: Path, cursor: i32): Type or error {
        self.search_node = struct {
            path: path,
            cursor: cursor,
        }?;

        let result = self.module_(module_).try;

        if self.search_node_type == nil {
            return _ or error::new("not found");
        } else {
            return self.search_node_type!;
        }
    }

    fun is_search_finished(
        self,
        location: Location,
        node: struct {
            path: Path,
            cursor: i32,
        },
    ): bool {
        if self.search_node_type != nil {
            return true;
        }
        if location.start != nil {
            if location.start! > node.cursor {
                return true;
            }
        }

        return false;
    }

    fun set_search_node_type(self, type_: Type, location: Location) {
        if self.search_node != nil {
            let path = self.search_node!.path;
            let cursor = self.search_node!.cursor;
            if is_prefix_path(path, self.current_path) {
                if self.search_node_type == nil {
                    if location.start != nil && location.end != nil {
                        if location.start! <= cursor && cursor <= location.end! {
                            self.search_node_type = type_?;
                        }
                    }
                }
            }
        }
    }

    fun find_definition(
        self,
        module_: Module,
        path: Path,
        cursor: i32,
    ): struct {
        path: Path,
        start: i32,
        end: i32,
    } or error {
        self.search_node = struct {
            path: path,
            cursor: cursor,
        }?;

        let r = self.module_(module_);

        if self.search_node_definition == nil {
            return _ or error::new("not found");
        } else {
            return self.search_node_definition!;
        }
    }

    fun set_search_node_definition(self, path: Path, def: Location, source: Location) {
        if self.search_node != nil {
            let search_path = self.search_node!.path;
            let cursor = self.search_node!.cursor;
            if is_prefix_path(search_path, self.current_path) {
                if source.start != nil && source.end != nil {
                    if source.start! <= cursor && cursor <= source.end! {
                        if self.search_node_definition == nil {
                            self.search_node_definition = struct {
                                path: path,
                                start: def.start!,
                                end: def.end!,
                            }?;
                        }
                    }
                }
            }
        }
    }

    fun completion(
        self,
        module_: Module,
        path: Path,
        cursor: i32,
        dot: bool,
    ): vec[struct {
        kind: string,
        label: string,
        text: string,
    }] or error {
        self.search_node = struct {
            path: path,
            cursor: cursor,
        }?;

        let r = self.module_(module_);

        if !dot {
            let items = make[vec[struct {
                kind: string,
                label: string,
                text: string,
            }]]();
            for key in self.globals.list_keys() {
                let value = self.globals.at(key);

                items.push(struct {
                    kind: "function",
                    label: key,
                    text: value.data.to_string(),
                });
            }

            self.completed = items?;
        }

        if self.completed == nil {
            return _ or error::new("not found");
        } else {
            return self.completed!;
        }
    }

    fun set_completion(self, type_: Type, source: Location): nil or error {
        if self.search_node != nil {
            let path = self.search_node!.path;
            let cursor = self.search_node!.cursor;
            if is_prefix_path(path, self.current_path) {
                // UGLY HACK: For dot completion, some nodes are skipped. So we need to search nodes for a bit wider range.
                if source.start != nil && source.end != nil && source.start! <= cursor && cursor <= source.end! + 5 {
                    let completion = make[vec[struct {
                        kind: string,
                        label: string,
                        text: string,
                    }]]();

                    // field completion
                    let rs = self.resolve_record_type(type_, make[vec[Type]]()).try;
                    for key in rs.list_keys() {
                        let value = rs.at(key);
                        completion.push(struct {
                            kind: "field",
                            label: key,
                            text: value.to_string(),
                        });
                    }

                    // method completion
                    if type_.t_ident != nil {
                        let search_path = Path::ident(type_.t_ident!);

                        for import_path in self.imported {
                            import_path.extend(search_path);
                            for key in self.globals.list_keys() {
                                let key_path = Path::new(key);
                                let value = self.globals.at(key);
                                if is_prefix_path(key_path, import_path) {
                                    let label = key_path.remove_prefix(import_path);

                                    completion.push(struct {
                                        kind: "function",
                                        label: key,
                                        text: value.data.to_string(),
                                    });
                                }
                            }
                        }
                    }

                    // special syntax
                    if type_.t_optional != nil {
                        completion.push(struct {
                            kind: "keyword",
                            label: "!",
                            text: "unwrap",
                        });
                    }
                    if type_.t_or != nil {
                        completion.push(struct {
                            kind: "keyword",
                            label: "try",
                            text: "try",
                        });
                    }

                    self.completed = completion?;
                }
            }
        }

        return nil;
    }
}

fun unify(type1: Type, type2: Type): Type or error {
    if type1.t_i32 != nil && type2.t_i32 != nil {
        return type1;
    }
    if type1.t_u32 != nil && type2.t_u32 != nil {
        return type1;
    }
    if type1.t_nil != nil && type2.t_nil != nil {
        return type1;
    }
    if type1.t_bool != nil && type2.t_bool != nil {
        return type1;
    }
    if type1.t_ident != nil && type1.t_ident!.equal("bool") && type2.t_bool != nil {
        return type1;
    }
    if type2.t_ident != nil && type2.t_ident!.equal("bool") && type1.t_bool != nil {
        return type2;
    }
    if type1.t_byte != nil && type2.t_byte != nil {
        return type1;
    }
    if type1.t_ident != nil && type2.t_ident != nil {
        if !type1.t_ident!.equal(type2.t_ident!) {
            return _ or error::new(
                "unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string()),
            );
        }

        return type1;
    }
    if type1.t_ptr != nil && type2.t_ptr != nil {
        let result = unify(type1.t_ptr!, type2.t_ptr!).try;

        return Type {
            t_ptr: result,
        };
    }
    if type1.t_optional != nil && type2.t_optional != nil {
        let result = unify(type1.t_optional!, type2.t_optional!).try;

        return Type {
            t_optional: result,
        };
    }
    if type1.t_omit != nil {
        return type2;
    }
    if type2.t_omit != nil {
        return type1;
    }
    if type1.t_nil != nil && type2.t_optional != nil {
        return type2;
    }
    if type2.t_nil != nil && type1.t_optional != nil {
        return type1;
    }
    if type1.t_any != nil {
        return type2;
    }
    if type2.t_any != nil {
        return type1;
    }
    if type1.t_vec != nil && type2.t_vec != nil {
        let result = unify(type1.t_vec!, type2.t_vec!).try;

        return Type {
            t_vec: result,
        };
    }
    if type1.t_vec != nil && type2.t_ident != nil && type2.t_ident!.equal("vec") {
        return type1;
    }
    if type2.t_vec != nil && type1.t_ident != nil && type1.t_ident!.equal("vec") {
        return type2;
    }
    if type1.t_struct != nil && type2.t_struct != nil {
        if type1.t_struct!.fields.length != type2.t_struct!.fields.length {
            return _ or error::new("unification failed: ".concat(type1.t_struct!.fields.length.to_string()).concat(
                " != ",
            ).concat(type2.t_struct!.fields.length.to_string()));
        }

        for i in 0..type1.t_struct!.fields.length {
            let rs1 = type1.t_struct!.fields.at(i).data;
            let rs2 = type2.t_struct!.fields.at(i).data;

            if !rs1.name.equal(rs2.name) {
                return _ or error::new(
                    "unification failed: ".concat(derive::to_string(rs1)).concat(" != ").concat(derive::to_string(
                        rs2,
                    )),
                );
            }

            unify(rs1.type_, rs2.type_).try;
        }

        return type1;
    }
    if type1.t_or != nil && type2.t_or != nil {
        let left = unify(type1.t_or!.left, type2.t_or!.left).try;
        let right = unify(type1.t_or!.right, type2.t_or!.right).try;

        return Type {
            t_or: struct {
                left: left,
                right: right,
            },
        };
    }
    if type1.t_map != nil && type2.t_map != nil {
        let key = unify(type1.t_map!.key, type2.t_map!.key).try;
        let value = unify(type1.t_map!.value, type2.t_map!.value).try;

        return Type {
            t_map: struct {
                key: key,
                value: value,
            },
        };
    }

    return _ or error::new(
        "unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string()),
    );
}

fun is_prefix_path(a: Path, b: Path): bool {
    if a.path.length > b.path.length {
        return false;
    }

    for i in 0..a.path.length {
        if !a.path.at(i).equal(b.path.at(i)) {
            return false;
        }
    }

    return true;
}

