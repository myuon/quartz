import quartz::ast;

type Typechecker = {
    locals: map[string, Type],
    globals: map[string, Type],
};

module Typechecker {
    fun new(): Typechecker {
        return Typechecker {
            locals: make[map[string, Type]](),
            globals: make[map[string, Type]](),
        };
    }

    fun module_(self, m: Module): nil or error {
        for i in 0..m.decls.length {
            let d = m.decls.at(i);
            self.decl(d).try;
        }
    }

    fun decl(self, d: Decl): nil or error {
        if d.t_func != nil {
            // For recursive functions
            self.globals.insert(d.t_func!.name, d.t_func!.to_type());

            self.function(d.t_func!).try;

            self.globals.insert(d.t_func!.name, d.t_func!.to_type());
            return;
        }
        if d.t_let != nil {
            let t = self.expression(d.t_let!.expr).try;
            unify(t, d.t_let!.name_type).try;
            d.t_let!.name_type = t;

            self.globals.insert(d.t_let!.name, t);
            return;
        }
        if d.t_type != nil {
            self.globals.insert(d.t_type!.name, d.t_type!.type_);
            return;
        }

        panic("unimplemented: decl");
    }

    fun function(self, f: Function): nil or error {
        let locals = self.locals;
        self.locals = make[map[string, Type]]();

        for i in 0..f.params.length {
            let p = f.params.at(i);
            self.locals.insert(p.name, p.type_);
        }

        self.block(f.body, f.result_type).try;

        self.locals = locals;
    }

    fun block(self, b: Block, expected: Type): nil or error {
        for i in 0..b.block.length {
            let result = Type {
                t_omit: true?,
                ..nil,
            };
            self.statement(b.block.at(i), result).try;
        }
    }

    fun statement(self, s: Statement, result_type: Type): nil or error {
        if s.t_let != nil {
            let t = self.expression(s.t_let!.expr).try;
            unify(t, s.t_let!.name_type).try;
            s.t_let!.name_type = t;

            self.locals.insert(s.t_let!.name, t);
            return;
        }
        if s.t_return != nil {
            let t = self.expression(s.t_return!.expr).try;
            unify(t, result_type).try;
            return;
        }
        if s.t_expr != nil {
            let _t = self.expression(s.t_expr!.expr).try;
            return;
        }
        if s.t_assign != nil {
            let lhs_type = self.expression_left_value(s.t_assign!.lhs).try;
            let rhs_type = Type {
                t_ptr: self.expression(s.t_assign!.rhs).try?,
                ..nil,
            };

            unify(lhs_type, rhs_type).try;
            return;
        }
        if s.t_if != nil {
            let condition_type = self.expression(s.t_if!.condition).try;
            unify(condition_type, Type {
                t_bool: true?,
                ..nil,
            }).try;

            let type_ = Type {
                t_omit: true?,
                ..nil,
            };
            self.block(s.t_if!.then_block, type_).try;
            if s.t_if!.else_block != nil {
                self.block(s.t_if!.else_block!, type_).try;
            }
            return;
        }
        if s.t_while != nil {
            let condition_type = self.expression(s.t_while!.condition).try;
            unify(condition_type, Type {
                t_bool: true?,
                ..nil,
            }).try;

            let type_ = Type {
                t_omit: true?,
                ..nil,
            };
            self.block(s.t_while!.block, type_).try;
            return;
        }

        return _ or error::new("unimplemented: statement, {}".format(s.to_string()));
    }

    fun expression_left_value(self, expr: Expression): Type or error {
        let t = self.expression(expr).try;

        return Type {
            t_ptr: t?,
            ..nil,
        };
    }

    fun expression(self, expr: Expression): Type or error {
        if expr.t_number != nil {
            return Type {
                t_i32: true?,
                ..nil,
            };
        }
        if expr.t_binop != nil {
            if (expr.t_binop!.binop.equal("plus")
                || expr.t_binop!.binop.equal("minus")
                || expr.t_binop!.binop.equal("mult")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                unify(t1, Type {
                    t_i32: true?,
                    ..nil,
                }).try;

                let t2 = self.expression(expr.t_binop!.right).try;
                unify(t2, Type {
                    t_i32: true?,
                    ..nil,
                }).try;

                return t1;
            }
            if (expr.t_binop!.binop.equal("equal")
                || expr.t_binop!.binop.equal("lt")) {
                let t1 = self.expression(expr.t_binop!.left).try;
                let t2 = self.expression(expr.t_binop!.right).try;
                unify(t1, t2).try;

                return Type {
                    t_bool: true?,
                    ..nil,
                };
            }

            return _ or error::new("unimplemented: binop, {}".format(expr.to_string()));
        }
        if expr.t_ident != nil {
            if self.globals.has(expr.t_ident!.name) {
                let t = self.globals.at(expr.t_ident!.name);

                return t;
            }
            if self.locals.has(expr.t_ident!.name) {
                let t = self.locals.at(expr.t_ident!.name);

                return t;
            }

            return _ or error::new("unbound identifier: ".concat(expr.t_ident!.name));
        }
        if expr.t_call != nil {
            let func_type = self.expression(expr.t_call!.callee).try.t_func!;
            if func_type.params.length != expr.t_call!.args.length {
                return _ or error::new("wrong number of arguments, {}".format(expr.to_string()));
            }

            for i in 0..expr.t_call!.args.length {
                let arg = expr.t_call!.args.at(i);
                let arg_type = self.expression(arg).try;
                let param_type = func_type.params.at(i);

                unify(arg_type, param_type).try;
            }

            return func_type.result;
        }
        if expr.t_project != nil {
            let t = self.expression(expr.t_project!.expr).try;
            if t.t_struct != nil {
                if t.t_struct!.has(expr.t_project!.field) {
                    let t = t.t_struct!.at(expr.t_project!.field);

                    return t;
                }
            }

            return _ or error::new("unimplemented: project, {}".format(expr.to_string()));
        }
        if expr.t_record != nil {
            let t = self.globals.at(expr.t_record!.name);
            if t.t_struct == nil {
                return _ or error::new("unimplemented: record, {}".format(expr.to_string()));
            }

            for i in 0..t.t_struct!.fields.length {
                let field = t.t_struct!.fields.at(i);
                let expr = expr.t_record!.fields.at(i);
                let expr_type = self.expression(expr.value).try;

                unify(expr_type, field.type_).try;
            }

            for i in 0..expr.t_record!.fields.length {
                let field = expr.t_record!.fields.at(i);
                if !t.t_struct!.has(field.field) {
                    return _ or error::new("unknown field: {}".format(expr.to_string()));
                }
            }

            return t;
        }

        return _ or error::new("unimplemented: expression, {}".format(expr.to_string()));
    }
}

fun unify(type1: Type, type2: Type): nil or error {
    if type1.t_i32 != nil && type2.t_i32 != nil {
        return;
    }
    if type1.t_nil != nil && type2.t_nil != nil {
        return;
    }
    if type1.t_omit != nil {
        return;
    }
    if type2.t_omit != nil {
        return;
    }
    if type1.t_ptr != nil && type2.t_ptr != nil {
        unify(type1.t_ptr!, type2.t_ptr!).try;
        return;
    }
    if type1.t_bool != nil && type2.t_bool != nil {
        return;
    }

    return _ or error::new("unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string()));
}
