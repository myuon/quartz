import quartz::ast;

type Typechecker = {
    locals: map[string, Type],
    globals: map[string, Type],
};

module Typechecker {
    fun new(): Typechecker {
        return Typechecker {
            locals: make[map[string, Type]](),
            globals: make[map[string, Type]](),
        };
    }

    fun module_(self, m: Module) {
        for i in 0..m.decls.length {
            let f = m.decls.at(i);

            if f.t_func != nil {
                self.function(f.t_func!);

                let params_type = make[vec[Type]]();
                for i in 0..f.t_func!.params.length {
                    let p = f.t_func!.params.at(i);
                    params_type.push(p.type_);
                }

                self.globals.insert(f.t_func!.name, Type {
                    t_func: struct {
                        params: params_type,
                        result: f.t_func!.result_type,
                    }?,
                    ..nil,
                });

                continue;
            }

            panic("unimplemented: decl");
        }
    }

    fun function(self, f: Function) {
        let locals = self.locals;
        self.locals = make[map[string, Type]]();

        for i in 0..f.params.length {
            let p = f.params.at(i);
            self.locals.insert(p.name, p.type_);
        }

        self.block(f.body, f.result_type);

        self.locals = locals;
    }

    fun block(self, b: Block, expected: Type) {
        for i in 0..b.block.length {
            let result = Type {
                t_omit: true?,
                ..nil,
            };
            self.statement(b.block.at(i), result);
        }
    }

    fun statement(self, s: Statement, result_type: Type) {
        if s.t_let != nil {
            let t = self.expression(s.t_let!.expr);

            self.locals.insert(s.t_let!.name, t);
            return;
        }
        if s.t_return != nil {
            let t = self.expression(s.t_return!.expr);
            unify(t, result_type);
            return;
        }

        panic("unimplemented: statement");
    }

    fun expression(self, expr: Expression): Type {
        if expr.t_number != nil {
            return Type {
                t_i32: true?,
                ..nil,
            };
        }
        if expr.t_binop != nil {
            if expr.t_binop!.binop.equal("plus") {
                let t1 = self.expression(expr.t_binop!.left);
                unify(t1, Type {
                    t_i32: true?,
                    ..nil,
                });

                let t2 = self.expression(expr.t_binop!.right);
                unify(t2, Type {
                    t_i32: true?,
                    ..nil,
                });

                return t1;
            }

            println(expr.t_binop!.binop);
            panic("unimplemented: binop");
        }
        if expr.t_ident != nil {
            let t = self.locals.at(expr.t_ident!.name);

            return t;
        }
        if expr.t_call != nil {
            let func_type = self.expression(expr.t_call!.callee).t_func!;
            if func_type.params.length != expr.t_call!.args.length {
                println(expr.to_string());
                println(func_type.params.length.to_string().concat(" != ").concat(expr.t_call!.args.length.to_string()));
                panic("wrong number of arguments");
            }

            for i in 0..expr.t_call!.args.length {
                let arg = expr.t_call!.args.at(i);
                let arg_type = self.expression(arg);
                let param_type = func_type.params.at(i);

                unify(arg_type, param_type);
            }

            return func_type.result;
        }

        panic("unimplemented: expression");
    }
}

fun unify(type1: Type, type2: Type) {
    if type1.t_i32 != nil && type2.t_i32 != nil {
        return;
    }
    if type1.t_nil != nil && type2.t_nil != nil {
        return;
    }
    if type1.t_omit != nil {
        return;
    }
    if type2.t_omit != nil {
        return;
    }

    panic("unification failed: ".concat(type1.to_string()).concat(" != ").concat(type2.to_string()));
}
