import quartz::lexer;

type Parser = {
    position: i32,
    input: vec[Token],
    omit_index: i32,
};

module Parser {
    fun new(): Parser {
        return Parser {
            position: 0,
            input: make[vec[Token]](),
            omit_index: 0,
        };
    }

    fun run(self, input: vec[Token]) {
        self.input = input;
        return self.module_();
    }

    fun module_(self) {
        self.decl();
    }

    fun decl(self) {
        self.expect_ident("fun");
        let name = self.ident();
        self.expect("(");
        self.expect(")");

        self.expect(":");
        let result_type = self.ident();

        self.expect("{");
        self.expect("}");
    }

    fun function(self) {
        self.consume();
    }

    fun peek(self): Token {
        return self.input.at(self.position);
    }

    fun is_end(self): bool {
        return self.position >= self.input.length;
    }

    fun consume(self): Token {
        let token = self.peek();
        self.position = self.position + 1;

        return token;
    }

    fun ident(self): string {
        let token = self.peek();
        if token.lexeme == "ident" {
            let t = self.consume();
            return t.string_value!;
        } else {
            panic("Expected IDENT, got ".concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
        }
    }

    fun expect(self, lexeme: string) {
        let token = self.peek();
        if token.lexeme.equal(lexeme) {
            return token;
        } else {
            panic("Expected ".concat(lexeme).concat(", got ").concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
        }
    }

    fun expect_ident(self, expected: string) {
        let i = self.ident();
        if !i.equal(expected) {
            panic("Expected ".concat(expected).concat(", got ").concat(i));
        }
    }
}
