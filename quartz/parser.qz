import quartz::lexer;
import quartz::ast;

type Parser = {
    position: i32,
    input: vec[Token],
    omit_index: i32,
};

module Parser {
    fun new(): Parser {
        return Parser {
            position: 0,
            input: make[vec[Token]](),
            omit_index: 0,
        };
    }

    fun run(self, input: vec[Token]): Module {
        self.input = input;
        return self.module_();
    }

    fun module_(self): Module {
        let decls = make[vec[Decl]]();

        while !self.is_end() && !self.peek().lexeme.equal("rbrace") {
            decls.push(self.decl());
        }

        return Module {
            decls: decls,
        };
    }

    fun decl(self): Decl {
        let func = self.function();

        return Decl {
            t_func: func?,
            ..nil,
        };
    }

    fun function(self): Function {
        self.expect("fun");
        let name = self.ident();
        self.expect("lparen");
        let params = self.parameters();
        self.expect("rparen");

        let result_type = Type {
            t_omit: true?,
            ..nil,
        };
        if self.peek().lexeme.equal("colon") {
            self.consume();
            result_type = self.type_();
        }

        self.expect("lbrace");
        let body = self.block();
        self.expect("rbrace");

        return Function {
            name: name,
            result_type: result_type,
            body: body,
            params: params,
        };
    }

    fun parameters(self): vec[struct {
        name: string,
        type_: Type,
    }] {
        let params = make[vec[struct {
            name: string,
            type_: Type,
        }]]();

        while !self.is_end() && !self.peek().lexeme.equal("rparen") {
            let name = self.ident();
            self.expect("colon");
            let t = self.type_();

            params.push(struct {
                name: name,
                type_: t,
            });

            if self.peek().lexeme.equal("comma") {
                self.consume();
            }
        }

        return params;
    }

    fun type_(self): Type {
        let token = self.consume();
        if token.lexeme.equal("ident") {
            if token.string_value!.equal("i32") {
                return Type {
                    t_i32: true?,
                    ..nil,
                };
            }
            
            panic("Unknown type ".concat(token.string_value!));
        }

        panic("Expected IDENT, got ".concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
    }

    fun peek(self): Token {
        return self.input.at(self.position);
    }

    fun is_end(self): bool {
        return self.position >= self.input.length;
    }

    fun consume(self): Token {
        let token = self.peek();
        self.position = self.position + 1;

        return token;
    }

    fun ident(self): string {
        let token = self.consume();
        if token.lexeme.equal("ident") {
            return token.string_value!;
        } else {
            panic("Expected IDENT, got ".concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
        }
    }

    fun expect(self, lexeme: string): Token {
        let token = self.consume();
        if token.lexeme.equal(lexeme) {
            return token;
        } else {
            panic("Expected ".concat(lexeme).concat(", got ").concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
        }
    }

    fun expect_ident(self, expected: string) {
        let i = self.ident();
        if !i.equal(expected) {
            panic("Expected ".concat(expected).concat(", got ").concat(i));
        }
    }

    fun block(self): Block {
        let statements = make[vec[Statement]]();

        while !self.is_end() && !self.peek().lexeme.equal("rbrace") {
            statements.push(self.statement());
        }

        return Block {
            block: statements,
        };
    }

    fun statement(self): Statement {
        let token = self.peek();
        if token.lexeme.equal("let") {
            return self.let_statement();
        } else {
            if token.lexeme.equal("return") {
                return self.return_statement();
            } else {
                panic("Unexpected token ".concat(token.lexeme).concat("{").concat(token.string_value!).concat("}"));
            }
        }
    }

    fun let_statement(self): Statement {
        self.consume();
        let name = self.ident();

        let t = Type {
            t_omit: true?,
            ..nil,
        };
        if self.peek().lexeme.equal("colon") {
            self.expect("colon");
            t = self.type_();
        }

        self.expect("equal");
        let value = self.expression();
        self.expect("semicolon");

        return Statement {
            t_let: struct {
                name: name,
                name_type: t,
                expr: value,
            }?,
            ..nil,
        };
    }

    fun return_statement(self): Statement {
        self.consume();
        let value = self.expression();
        self.expect("semicolon");

        return Statement {
            t_return: struct {
                expr: value,
            }?,
            ..nil,
        };
    }

    fun expression(self): Expression {
        return self.term_2();
    }

    fun term_2(self): Expression {
        let current = self.term_0();

        while true {
            if self.peek().lexeme.equal("plus") {
                self.consume();

                current = Expression {
                    t_binop: struct {
                        binop: "plus",
                        left: current,
                        right: self.term_0(),
                    }?,
                    ..nil,
                };
                continue;
            }

            return current;
        }
    }

    fun term_0(self): Expression {
        let current = self.term_0_1();

        while true {
            if self.peek().lexeme.equal("lparen") {
                self.consume();

                let args = make[vec[Expression]]();
                while !self.peek().lexeme.equal("rparen") {
                    args.push(self.expression());

                    if self.peek().lexeme.equal("comma") {
                        self.consume();
                    } else {
                        break;
                    }
                }
                self.consume();

                current = Expression {
                    t_call: struct {
                        callee: current,
                        args: args,
                    }?,
                    ..nil,
                };
            }

            return current;
        }
    }

    fun term_0_1(self): Expression {
        if self.peek().lexeme.equal("ident") {
            return Expression {
                t_ident: struct {
                    name: self.ident(),
                }?,
                ..nil,
            };
        }
        if self.peek().lexeme.equal("number") {
            return Expression {
                t_number: struct {
                    value: self.consume().string_value!,
                }?,
                ..nil,
            };
        }

        panic("Unexpected token ".concat(self.peek().lexeme));
    }
}
