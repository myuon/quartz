import quartz::lexer;
import quartz::ast;

struct Parser {
    position: i32,
    input: vec[Token],
    omit_index: i32,
}

module Parser {
    fun new(): Parser {
        return Parser {
            position: 0,
            input: make[vec[Token]](),
            omit_index: 0,
        };
    }

    fun run(self, input: vec[Token]): Module or error {
        self.input = input;
        return self.module_();
    }

    fun module_(self): Module or error {
        let decls = make[vec[Decl]]();

        while !self.is_end() && !self.peek().lexeme.equal("rbrace") {
            decls.push(self.decl().try);
        }

        return Module {
            decls: decls,
        };
    }

    fun decl(self): Decl or error {
        let token = self.peek();
        if token.lexeme.equal("fun") {
            let func = self.function().try;

            return Decl {
                t_func: func?,
                ..nil,
            };
        }
        if token.lexeme.equal("let") {
            let let_ = self.global_let().try;

            return Decl {
                t_let: let_?,
                ..nil,
            };
        }
        if token.lexeme.equal("struct") {
            let struct_ = self.struct_decl().try;

            return Decl {
                t_type: struct_?,
                ..nil,
            };
        }
        if token.lexeme.equal("module") {
            let module_ = self.module_decl().try;

            return Decl {
                t_module: module_?,
                ..nil,
            };
        }

        return _ or error::new("Expected DECL, got ".concat(token.lexeme).concat("{").concat(
            token.string_value!,
        ).concat("}"));
    }

    fun struct_decl(
        self,
    ): struct {
        name: string,
        type_: Type,
    } or error {
        self.expect("struct").try;
        let ident = self.ident().try;
        self.expect("lbrace").try;

        let fields = make[vec[struct {
            name: string,
            type_: Type,
        }]]();

        while !self.peek().lexeme.equal("rbrace") {
            let name = self.ident().try;
            self.expect("colon").try;
            let t = self.type_().try;

            fields.push(struct {
                name: name,
                type_: t,
            });

            if self.peek().lexeme.equal("comma") {
                self.consume();
            } else {
                break;
            }
        }

        self.expect("rbrace").try;

        return struct {
            name: ident,
            type_: Type {
                t_struct: TypeStruct {
                    fields: fields,
                }?,
                ..nil,
            },
        };
    }

    fun module_decl(
        self,
    ): struct {
        name: string,
        module_: Module,
    } or error {
        self.expect("module").try;
        let name = self.ident().try;
        self.expect("lbrace").try;
        let module_ = self.module_().try;
        self.expect("rbrace").try;

        return struct {
            name: name,
            module_: module_,
        };
    }

    fun global_let(self): Let or error {
        self.expect("let").try;
        let name = self.ident().try;

        let t = Type {
            t_omit: true?,
            ..nil,
        };
        if self.peek().lexeme.equal("colon") {
            self.expect("colon").try;
            t = self.type_().try;
        }

        self.expect("equal").try;
        let value = self.expression().try;
        self.expect("semicolon").try;

        return Let {
            name: name,
            name_type: t,
            expr: value,
        };
    }

    fun function(self): Function or error {
        self.expect("fun").try;
        let name = self.ident().try;
        self.expect("lparen").try;
        let params = self.parameters().try;
        self.expect("rparen").try;

        let result_type = Type {
            t_nil: true?,
            ..nil,
        };
        if self.peek().lexeme.equal("colon") {
            let _t = self.consume();
            result_type = self.type_().try;
        }

        self.expect("lbrace").try;
        let body = self.block().try;
        self.expect("rbrace").try;

        return Function {
            name: name,
            result_type: result_type,
            body: body,
            params: params,
        };
    }

    fun parameters(
        self,
    ): vec[struct {
        name: string,
        type_: Type,
    }] or error {
        let params = make[vec[struct {
            name: string,
            type_: Type,
        }]]();

        while !self.is_end() && !self.peek().lexeme.equal("rparen") {
            if self.peek().lexeme.equal("self") {
                self.expect("self").try;
                params.push(struct {
                    name: "self",
                    type_: Type {
                        t_omit: true?,
                        ..nil,
                    },
                });
            } else {
                let name = self.ident().try;
                self.expect("colon").try;
                let t = self.type_().try;

                params.push(struct {
                    name: name,
                    type_: t,
                });
            }

            if self.peek().lexeme.equal("comma") {
                let _t = self.consume();
            }
        }

        return params;
    }

    fun type_(self): Type or error {
        let token = self.consume();
        if token.lexeme.equal("ident") {
            if token.string_value!.equal("i32") {
                return Type {
                    t_i32: true?,
                    ..nil,
                };
            }
            if token.string_value!.equal("byte") {
                return Type {
                    t_byte: true?,
                    ..nil,
                };
            }
            if token.string_value!.equal("bool") {
                return Type {
                    t_bool: true?,
                    ..nil,
                };
            }
            if token.string_value!.equal("ptr") {
                self.expect("lbracket").try;
                let t = self.type_().try;
                self.expect("rbracket").try;

                return Type {
                    t_ptr: t?,
                    ..nil,
                };
            }

            return Type {
                t_ident: token.string_value!?,
                ..nil,
            };
        }

        return _ or error::new("Expected IDENT, got ".concat(token.lexeme).concat("{").concat(
            token.string_value!,
        ).concat("}"));
    }

    fun peek(self): Token {
        return self.input.at(self.position);
    }

    fun is_end(self): bool {
        return self.position >= self.input.length;
    }

    fun consume(self): Token {
        let token = self.peek();
        self.position = self.position + 1;

        return token;
    }

    fun ident(self): string or error {
        let token = self.consume();
        if token.lexeme.equal("ident") {
            return token.string_value!;
        } else {
            return _ or error::new("Expected IDENT, got ".concat(token.lexeme).concat("{").concat(
                token.string_value!,
            ).concat("}"));
        }
    }

    fun expect(self, lexeme: string): nil or error {
        let token = self.consume();
        if token.lexeme.equal(lexeme) {
            return nil;
        } else {
            return _ or error::new("Expected ".concat(lexeme).concat(", got ").concat(token.lexeme).concat(
                "{",
            ).concat(token.string_value!).concat("}"));
        }
    }

    fun expect_ident(self, expected: string): nil or error {
        let i = self.ident().try;
        if !i.equal(expected) {
            return _ or error::new("Expected ".concat(expected).concat(", got ").concat(i));
        }

        return nil;
    }

    fun block(self): Block or error {
        let statements = make[vec[Statement]]();

        while !self.is_end() && !self.peek().lexeme.equal("rbrace") {
            let s = self.statement().try;
            statements.push(s);
        }

        return Block {
            block: statements,
        };
    }

    fun statement(self): Statement or error {
        let token = self.peek();
        if token.lexeme.equal("let") {
            return self.let_statement();
        }
        if token.lexeme.equal("return") {
            return self.return_statement();
        }
        if token.lexeme.equal("if") {
            self.consume();
            let condition = self.expression_conditional().try;
            self.expect("lbrace").try;
            let then_block = self.block().try;
            self.expect("rbrace").try;

            let else_block = nil as Block?;
            if self.peek().lexeme.equal("else") {
                self.consume();
                self.expect("lbrace").try;
                else_block = self.block().try?;
                self.expect("rbrace").try;
            }

            return Statement {
                t_if: struct {
                    condition: condition,
                    then_block: then_block,
                    else_block: else_block,
                }?,
                ..nil,
            };
        }
        if token.lexeme.equal("while") {
            self.consume();
            let condition = self.expression_conditional().try;
            self.expect("lbrace").try;
            let block = self.block().try;
            self.expect("rbrace").try;

            return Statement {
                t_while: struct {
                    condition: condition,
                    block: block,
                }?,
                ..nil,
            };
        }

        let expr = self.expression().try;
        if self.peek().lexeme.equal("semicolon") {
            self.consume();

            return Statement {
                t_expr: struct {
                    expr: expr,
                }?,
                ..nil,
            };
        }
        if self.peek().lexeme.equal("equal") {
            self.consume();
            let rhs = self.expression().try;
            self.expect("semicolon").try;

            return Statement {
                t_assign: struct {
                    lhs: expr,
                    rhs: rhs,
                }?,
                ..nil,
            };
        }

        return _ or error::new(format("Unexpected token {}", self.peek().to_string()));
    }

    fun expression_conditional(self): Expression or error {
        return self.expression_(false).try;
    }

    fun let_statement(self): Statement or error {
        self.expect("let").try;
        let name = self.ident().try;

        let t = Type {
            t_omit: true?,
            ..nil,
        };
        if self.peek().lexeme.equal("colon") {
            self.expect("colon").try;
            t = self.type_().try;
        }

        self.expect("equal").try;
        let value = self.expression().try;
        self.expect("semicolon").try;

        return Statement {
            t_let: struct {
                name: name,
                name_type: t,
                expr: value,
            }?,
            ..nil,
        };
    }

    fun return_statement(self): Statement or error {
        self.expect("return").try;
        let value = self.expression().try;
        self.expect("semicolon").try;

        return Statement {
            t_return: struct {
                expr: value,
            }?,
            ..nil,
        };
    }

    fun expression(self): Expression or error {
        return self.expression_(true).try;
    }

    fun expression_(self, with_struct: bool): Expression or error {
        return self.term_5(with_struct).try;
    }

    fun term_5(self, with_struct: bool): Expression or error {
        return self.term_4(with_struct).try;
    }

    fun term_4(self, with_struct: bool): Expression or error {
        let current = self.term_3(with_struct).try;

        while true {
            if self.peek().lexeme.equal("double_equal") {
                self.expect("double_equal").try;

                current = Expression {
                    t_binop: struct {
                        binop: "equal",
                        left: current,
                        right: self.term_3(with_struct).try,
                    }?,
                    ..nil,
                };
                continue;
            }

            return current;
        }
    }

    fun term_3(self, with_struct: bool): Expression or error {
        let current = self.term_2(with_struct).try;

        if self.peek().lexeme.equal("lt") {
            self.expect("lt").try;

            return Expression {
                t_binop: struct {
                    binop: "lt",
                    left: current,
                    right: self.term_2(with_struct).try,
                }?,
                ..nil,
            };
        }

        return current;
    }

    fun term_2(self, with_struct: bool): Expression or error {
        let current = self.term_1(with_struct).try;

        while true {
            if self.peek().lexeme.equal("plus") {
                self.expect("plus").try;

                current = Expression {
                    t_binop: struct {
                        binop: "plus",
                        left: current,
                        right: self.term_1(with_struct).try,
                    }?,
                    ..nil,
                };
                continue;
            }
            if self.peek().lexeme.equal("minus") {
                self.expect("minus").try;

                current = Expression {
                    t_binop: struct {
                        binop: "minus",
                        left: current,
                        right: self.term_1(with_struct).try,
                    }?,
                    ..nil,
                };
                continue;
            }
            if self.peek().lexeme.equal("as") {
                self.expect("as").try;

                current = Expression {
                    t_as: struct {
                        expr: current,
                        type_: self.type_().try,
                    }?,
                    ..nil,
                };
                continue;
            }

            return current;
        }
    }

    fun term_1(self, with_struct: bool): Expression or error {
        let current = self.term_0(with_struct).try;

        while true {
            if self.peek().lexeme.equal("star") {
                self.expect("star").try;

                current = Expression {
                    t_binop: struct {
                        binop: "mult",
                        left: current,
                        right: self.term_1(with_struct).try,
                    }?,
                    ..nil,
                };
                continue;
            }

            return current;
        }
    }

    fun term_0(self, with_struct: bool): Expression or error {
        let current = self.term_0_1().try;

        while true {
            let token = self.peek();

            if token.lexeme.equal("lparen") {
                self.expect("lparen").try;

                let args = make[vec[Expression]]();
                while !self.peek().lexeme.equal("rparen") {
                    args.push(self.expression().try);

                    if self.peek().lexeme.equal("comma") {
                        self.expect("comma").try;
                    } else {
                        break;
                    }
                }
                self.expect("rparen").try;

                current = Expression {
                    t_call: struct {
                        callee: current,
                        args: args,
                    }?,
                    ..nil,
                };
            } else if token.lexeme.equal("dot") {
                self.expect("dot").try;
                let field = self.ident().try;

                current = Expression {
                    t_project: struct {
                        expr: current,
                        field: field,
                        type_: nil as Type?,
                    }?,
                    ..nil,
                };
            } else if with_struct && token.lexeme.equal("lbrace") {
                self.expect("lbrace").try;

                if current.t_ident == nil {
                    return _ or error::new("Expected identifier");
                }

                let ident = current.t_ident!;
                let fields = make[vec[struct {
                    field: string,
                    value: Expression,
                }]]();

                while !self.peek().lexeme.equal("rbrace") {
                    let field = self.ident().try;
                    self.expect("colon").try;
                    let value = self.expression().try;

                    fields.push(struct {
                        field: field,
                        value: value,
                    });

                    if self.peek().lexeme.equal("comma") {
                        self.expect("comma").try;
                    } else {
                        break;
                    }
                }
                self.expect("rbrace").try;

                current = Expression {
                    t_record: RecordExpression {
                        name: ident.name,
                        fields: fields,
                    }?,
                    ..nil,
                };
            } else if token.lexeme.equal("lbracket") {
                self.expect("lbracket").try;

                if current.t_ident == nil {
                    return _ or error::new(format(
                        "Expected identifier for record name, found {}",
                        current.to_string(),
                    ));
                }

                let t = self.type_().try;
                self.expect("rbracket").try;

                self.expect("lparen").try;
                let args = make[vec[Expression]]();
                while !self.peek().lexeme.equal("rparen") {
                    args.push(self.expression().try);

                    if self.peek().lexeme.equal("comma") {
                        self.expect("comma").try;
                    } else {
                        break;
                    }
                }
                self.expect("rparen").try;

                let ident = current.t_ident!.name;
                if ident.equal("make") {
                    current = Expression {
                        t_make: struct {
                            type_: t,
                            args: args,
                        }?,
                        ..nil,
                    };
                }
            } else if token.lexeme.equal("double_colon") {
                self.expect("double_colon").try;

                if current.t_ident == nil {
                    return _ or error::new(format(
                        "Expected identifier for record name, found {}",
                        current.to_string(),
                    ));
                }

                let name = self.ident().try;

                let path = Path::ident(current.t_ident!.name);
                path.push(name);

                current = Expression {
                    t_path: struct {
                        path: path,
                    }?,
                    ..nil,
                };
            } else {
                return current;
            }
        }

        return panic("unreachable");
    }

    fun term_0_1(self): Expression or error {
        if self.peek().lexeme.equal("ident") {
            let name = self.ident().try;

            return Expression {
                t_ident: struct {
                    name: name,
                }?,
                ..nil,
            };
        }
        if self.peek().lexeme.equal("number") {
            let token = self.consume();

            return Expression {
                t_i32: struct {
                    value: i32::parse(token.string_value!),
                }?,
                ..nil,
            };
        }
        if self.peek().lexeme.equal("self") {
            self.expect("self").try;

            return Expression {
                t_self: true?,
                ..nil,
            };
        }

        return _ or error::new(format("Unexpected token {}", token.lexeme));
    }
}

