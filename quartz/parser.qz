import quartz::path;
import quartz::lexer;
import quartz::ast;
import quartz::location;
import quartz::errors;

struct Parser {
    position: i32,
    input: vec[Token],
    omit_index: i32,
    imports: vec[Path],
    skip_errors: bool,
}

module Parser {
    fun new(): Parser {
        return Parser {
            position: 0,
            input: make[vec[Token]](),
            omit_index: 0,
            imports: make[vec[Path]](),
            skip_errors: false,
        };
    }

    fun run(self, input: vec[Token], skip_errors: bool): Module or error {
        self.skip_errors = skip_errors;
        self.input = make[vec[Token]]();
        for token in input {
            if !token.lexeme.equal("comment") {
                self.input.push(token);
            }
        }
        return self.module_();
    }

    fun module_(self): Module or error {
        let decls = make[vec[LDecl]]();
        let prev = 0;

        while !self.is_end() && !self.peek().try.lexeme.equal("rbrace") {
            let position = self.position;
            let result or err = self.decl();
            if result != nil || !self.skip_errors {
                if err != nil {
                    return _ or err!;
                }

                decls.push(result!);
            } else if self.position == prev {
                return _ or error::new("Infinite loop detected");
            }

            prev = self.position;
        }

        return Module {
            decls: decls,
        };
    }

    fun decl(self): LDecl or error {
        let token = self.peek().try;
        if token.lexeme.equal("fun") {
            let func = self.function().try;

            return LDecl {
                data: Decl {
                    t_func: func.data,
                },
                location: func.location,
            };
        } else if token.lexeme.equal("let") {
            let let_ = self.global_let().try;

            return LDecl {
                data: Decl {
                    t_let: let_.data,
                },
                location: let_.location,
            };
        } else if token.lexeme.equal("struct") {
            let struct_ = self.struct_decl().try;

            return LDecl {
                data: Decl {
                    t_type: struct_.data,
                },
                location: struct_.location,
            };
        } else if token.lexeme.equal("enum") {
            let enum_ = self.enum_decl().try;

            return LDecl {
                data: Decl {
                    t_enum: enum_.data,
                },
                location: enum_.location,
            };
        } else if token.lexeme.equal("module") {
            let module_ = self.module_decl().try;

            return LDecl {
                data: Decl {
                    t_module: module_.data,
                },
                location: module_.location,
            };
        } else if token.lexeme.equal("import") {
            let start_token = self.expect("import").try;
            let path = self.path().try;
            let end_token = self.expect("semicolon").try;

            self.imports.push(path);

            return LDecl {
                data: Decl {
                    t_import: path,
                },
                location: self.span_location(start_token, end_token),
            };
        } else if token.lexeme == "at" {
            let start_token = self.expect("at").try;
            let attrs = self.attributes().try;

            return LDecl {
                data: Decl {
                    t_attributes: attrs,
                },
                location: attrs.location,
            };
        } else if token.lexeme == "declare" {
            let start_token = self.expect("declare").try;
            let token = self.peek().try;
            if token.lexeme.equal("fun") {
                self.expect("fun").try;
                let name = self.ident().try;
                self.expect("lparen").try;
                let params = self.parameters().try;
                self.expect("rparen").try;

                let result_type = Type {
                    t_nil: true,
                };
                if self.peek().try.lexeme.equal("colon") {
                    self.consume().try;
                    result_type = self.type_().try.data;
                }

                let end_token = self.expect("semicolon").try;

                return LDecl {
                    data: Decl {
                        t_declare_func: DeclareFunc {
                            name: name,
                            result_type: result_type,
                            params: params.params,
                            ..nil,
                        },
                    },
                    location: Location {
                        start: start_token.location.start,
                        end: end_token.location.end,
                    },
                };
            }
        } else if token.lexeme == "interface" {
            let start_token = self.expect("interface").try;
            let name = self.ident().try;
            self.expect("lbrace").try;

            let methods = make[vec[struct {
                name: string,
                params: vec[struct {
                    name: string,
                    type_: Type,
                }],
                result_type: Type,
            }]]();
            while true {
                if self.peek().try.lexeme == "fun" {
                    self.expect("fun").try;
                } else {
                    break;
                }

                let method_name = self.ident().try;
                self.expect("lparen").try;
                let params = self.parameters().try;
                self.expect("rparen").try;

                let result_type = Type {
                    t_nil: true,
                };
                if self.peek().try.lexeme == "colon" {
                    self.expect("colon").try;
                    result_type = self.type_().try.data;
                }

                self.expect("semicolon").try;

                methods.push(struct {
                    name: method_name.data,
                    params: params.params,
                    result_type: result_type,
                });
            }

            let end_token = self.expect("rbrace").try;

            return LDecl {
                data: Decl {
                    t_interface: Interface {
                        name: name.data,
                        methods: methods,
                    },
                },
                location: Location {
                    start: start_token.location.start,
                    end: end_token.location.end,
                },
            };
        }

        return _ or error::new("Expected DECL, got ".concat(token.lexeme).concat("{").concat(
            token.string_value!,
        ).concat("}"));
    }

    fun path(self): Path or error {
        let path = make[vec[string]](self.ident().try.data);
        while true {
            if self.peek().try.lexeme.equal("double_colon") {
                self.expect("double_colon").try;
                path.push(self.ident().try.data);
            } else {
                break;
            }
        }

        return Path {
            path: path,
        };
    }

    fun struct_decl(
        self,
    ): struct {
        data: struct {
            name: string,
            type_: Type,
        },
        location: Location,
    } or error {
        let start_token = self.expect("struct").try;
        let ident = self.ident().try;
        self.expect("lbrace").try;

        let fields = make[vec[struct {
            data: struct {
                name: string,
                type_: Type,
            },
            location: Location,
        }]]();

        while !self.peek().try.lexeme.equal("rbrace") {
            let name = self.ident().try;
            self.expect("colon").try;
            let t = self.type_().try;

            fields.push(struct {
                data: struct {
                    name: name.data,
                    type_: t.data,
                },
                location: Location {
                    start: name.location.start,
                    end: t.location.end,
                },
            });

            if self.peek().try.lexeme.equal("comma") {
                self.consume().try;
            } else {
                break;
            }
        }

        let end_token = self.expect("rbrace").try;

        return struct {
            data: struct {
                name: ident.data,
                type_: Type {
                    t_struct: TypeStruct {
                        fields: fields,
                    },
                },
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun enum_decl(
        self,
    ): struct {
        data: struct {
            name: string,
            type_: Type,
        },
        location: Location,
    } or error {
        let start_token = self.expect("enum").try;
        let ident = self.ident().try;
        self.expect("lbrace").try;

        let fields = make[vec[struct {
            data: struct {
                name: string,
                type_: Type,
            },
            location: Location,
        }]]();

        while !self.peek().try.lexeme.equal("rbrace") {
            let name = self.ident().try;
            self.expect("colon").try;
            let t = self.type_().try;

            fields.push(struct {
                data: struct {
                    name: name.data,
                    type_: t.data,
                },
                location: Location {
                    start: name.location.start,
                    end: t.location.end,
                },
            });

            if self.peek().try.lexeme.equal("comma") {
                self.consume().try;
            } else {
                break;
            }
        }

        let end_token = self.expect("rbrace").try;

        return struct {
            data: struct {
                name: ident.data,
                type_: Type {
                    t_enum: TypeStruct {
                        fields: fields,
                    },
                },
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun module_decl(
        self,
    ): struct {
        data: struct {
            path: Path,
            extends: string?,
            module_: Module,
        },
        location: Location,
    } or error {
        let start_token = self.expect("module").try;
        let name = self.ident().try;

        let extends = nil;
        if self.peek().try.lexeme == "colon" {
            self.expect("colon").try;
            extends = self.ident().try.data?;
        }

        self.expect("lbrace").try;
        let module_ = self.module_().try;
        let end_token = self.expect("rbrace").try;

        return struct {
            data: struct {
                path: Path::ident(name.data),
                extends: extends,
                module_: module_,
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun global_let(
        self,
    ): struct {
        data: Let,
        location: Location,
    } or error {
        let start_token = self.expect("let").try;
        let name = self.ident().try;

        let t = Type {
            t_omit: true,
        };
        if self.peek().try.lexeme.equal("colon") {
            self.expect("colon").try;
            t = self.type_().try.data;
        }

        self.expect("equal").try;
        let value = self.expression().try;
        let end_token = self.expect("semicolon").try;

        return struct {
            data: Let {
                name: name.data,
                name_type: t,
                expr: value,
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun function(
        self,
    ): struct {
        data: Function,
        location: Location,
    } or error {
        let start_token = self.expect("fun").try;
        let name = self.ident().try;
        self.expect("lparen").try;
        let params = self.parameters().try;
        self.expect("rparen").try;

        let result_type = Type {
            t_nil: true,
        };
        if self.peek().try.lexeme.equal("colon") {
            self.consume().try;
            result_type = self.type_().try.data;
        }

        let body = self.block().try;

        return struct {
            data: Function {
                name: name,
                result_type: result_type,
                body: body,
                params: params.params,
                variadic: params.variadic,
                no_allocation: false,
                is_test: false,
                ffi_export: nil,
            },
            location: Location {
                start: start_token.location.start,
                end: body.location.end,
            },
        };
    }

    fun parameters(
        self,
    ): struct {
        params: vec[struct {
            name: string,
            type_: Type,
        }],
        variadic: struct {
            name: string,
            type_: Type,
        }?,
    } or error {
        let params = make[vec[struct {
            name: string,
            type_: Type,
        }]]();
        let variadic = nil as struct {
            name: string,
            type_: Type,
        }?;

        while !self.is_end() && !self.peek().try.lexeme.equal("rparen") {
            if self.peek().try.lexeme.equal("self") {
                self.expect("self").try;
                params.push(struct {
                    name: "self",
                    type_: Type {
                        t_omit: true,
                    },
                });
            } else if self.peek().try.lexeme.equal("double_dot") {
                self.expect("double_dot").try;
                let name = self.ident().try;
                self.expect("colon").try;
                let t = self.type_().try;

                variadic = struct {
                    name: name.data,
                    type_: t.data,
                }?;
            } else {
                let name = self.ident().try;
                self.expect("colon").try;
                let t = self.type_().try;

                params.push(struct {
                    name: name.data,
                    type_: t.data,
                });
            }

            if self.peek().try.lexeme.equal("comma") {
                self.consume().try;
            }
        }

        return struct {
            params: params,
            variadic: variadic,
        };
    }

    fun type_(self): LType or error {
        let current = self.type_primitive().try;

        while true {
            let token = self.peek().try;
            if token.lexeme.equal("question") {
                self.expect("question").try;

                current = LType {
                    data: Type {
                        t_optional: current.data,
                    },
                    location: current.location,
                };
            } else if token.lexeme.equal("or") {
                self.expect("or").try;
                let t = self.type_().try;

                current = LType {
                    data: Type {
                        t_or: struct {
                            left: current.data,
                            right: t.data,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: t.location.end,
                    },
                };
            } else {
                break;
            }
        }

        return current;
    }

    fun type_primitive(self): LType or error {
        let token = self.consume().try;
        if token.lexeme.equal("ident") {
            if token.string_value!.equal("i32") {
                return LType {
                    data: Type {
                        t_i32: true,
                    },
                    location: token.location,
                };
            } else if token.string_value!.equal("u32") {
                return LType {
                    data: Type {
                        t_u32: true,
                    },
                    location: token.location,
                };
            } else if token.string_value!.equal("byte") {
                return LType {
                    data: Type {
                        t_byte: true,
                    },
                    location: token.location,
                };
            } else if token.string_value!.equal("bool") {
                return LType {
                    data: Type {
                        t_bool: true,
                    },
                    location: token.location,
                };
            } else if token.string_value!.equal("ptr") {
                let start_token = self.expect("lbracket").try;
                let t = self.type_().try;
                let end_token = self.expect("rbracket").try;

                return LType {
                    data: Type {
                        t_ptr: t.data,
                    },
                    location: self.span_location(start_token, end_token),
                };
            } else if token.string_value!.equal("vec") {
                let start_token = self.expect("lbracket").try;
                let t = self.type_().try;
                let end_token = self.expect("rbracket").try;

                return LType {
                    data: Type {
                        t_vec: t.data,
                    },
                    location: self.span_location(start_token, end_token),
                };
            } else if token.string_value!.equal("any") {
                return LType {
                    data: Type {
                        t_any: true,
                    },
                    location: token.location,
                };
            } else if token.string_value!.equal("map") {
                let start_token = self.expect("lbracket").try;
                let key = self.type_().try;
                self.expect("comma").try;
                let value = self.type_().try;
                let end_token = self.expect("rbracket").try;

                return LType {
                    data: Type {
                        t_map: struct {
                            key: key.data,
                            value: value.data,
                        },
                    },
                    location: self.span_location(start_token, end_token),
                };
            }

            return LType {
                data: Type {
                    t_ident: token.string_value!,
                },
                location: token.location,
            };
        } else if token.lexeme.equal("struct") {
            let start_token = self.expect("lbrace").try;

            let fields = make[vec[struct {
                data: struct {
                    name: string,
                    type_: Type,
                },
                location: Location,
            }]]();

            while !self.peek().try.lexeme.equal("rbrace") {
                let name = self.ident().try;
                self.expect("colon").try;
                let t = self.type_().try;

                fields.push(struct {
                    data: struct {
                        name: name.data,
                        type_: t.data,
                    },
                    location: Location {
                        start: name.location.start,
                        end: t.location.end,
                    },
                });

                if self.peek().try.lexeme.equal("comma") {
                    self.consume().try;
                } else {
                    break;
                }
            }

            let end_token = self.expect("rbrace").try;

            return LType {
                data: Type {
                    t_struct: TypeStruct {
                        fields: fields,
                    },
                },
                location: self.span_location(start_token, end_token),
            };
        } else if token.lexeme.equal("nil") {
            return LType {
                data: Type {
                    t_nil: true,
                },
                location: token.location,
            };
        } else {
            return _ or error::new(format("Expected type, got {}", token.to_string()));
        }
    }

    fun peek(self): Token or error {
        if self.position >= self.input.length {
            return _ or error::new("Unexpected end of input");
        }

        return self.input.at(self.position);
    }

    fun is_end(self): bool {
        return self.position >= self.input.length;
    }

    fun consume(self): Token or error {
        let token = self.peek().try;
        self.position = self.position + 1;

        return token;
    }

    fun ident(self): Ident or error {
        let token = self.peek().try;
        if token.lexeme.equal("ident") {
            self.consume().try;

            return Ident {
                data: token.string_value!,
                location: token.location,
            };
        } else {
            return _ or error::new(format("Expected IDENT, got {}", derive::to_string(token)));
        }
    }

    fun expect(self, lexeme: string): Token or error {
        let token = self.consume().try;
        if token.lexeme.equal(lexeme) {
            return token;
        } else {
            return _ or error::new(format("Expected {}, got {}", lexeme, derive::to_string(token)));
        }
    }

    fun expect_ident(self, expected: string): nil or error {
        let i = self.ident().try;
        if !i.data.equal(expected) {
            return _ or error::new("Expected ".concat(expected).concat(", got ").concat(i.data));
        }

        return nil;
    }

    fun block(self): LBlock or error {
        let statements = make[vec[LStatement]]();

        let prev = 0;
        let start_token = self.expect("lbrace").try;

        while !self.is_end() && !self.peek().try.lexeme.equal("rbrace") {
            let result or err = self.statement();
            if result != nil || !self.skip_errors {
                if err != nil {
                    return _ or err!;
                }

                statements.push(result!);
            } else if self.position == prev {
                return _ or error::new("Infinite loop deteted");
            }

            prev = self.position;
        }

        let end_token = self.expect("rbrace").try;

        return LBlock {
            data: Block {
                block: statements,
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun statement(self): LStatement or error {
        let token = self.peek().try;
        if token.lexeme.equal("let") {
            return self.let_statement();
        }
        if token.lexeme.equal("return") {
            return self.return_statement();
        }
        if token.lexeme.equal("if") {
            let start_token = self.consume().try;
            let condition = self.expression_conditional().try;
            let then_block = self.block().try;
            let end_position = then_block.location.end!;

            let else_block = nil as LBlock?;
            if self.peek().try.lexeme.equal("else") {
                self.consume().try;

                if self.peek().try.lexeme.equal("if") {
                    let s = self.statement().try;
                    else_block = LBlock {
                        data: Block {
                            block: make[vec[LStatement]](s),
                        },
                        location: s.location,
                    }?;

                    if s.location.end != nil {
                        end_position = s.location.end!;
                    }
                } else {
                    let b = self.block().try;
                    end_position = b.location.end!;
                    else_block = b?;
                }
            }

            return LStatement {
                data: Statement {
                    t_if: struct {
                        condition: condition,
                        then_block: then_block,
                        else_block: else_block,
                    },
                },
                location: Location {
                    start: start_token.location.start,
                    end: end_position?,
                },
            };
        }
        if token.lexeme.equal("while") {
            let start_token = self.consume().try;
            let condition = self.expression_conditional().try;
            let block = self.block().try;

            return LStatement {
                data: Statement {
                    t_while: struct {
                        condition: condition,
                        block: block,
                    },
                },
                location: Location {
                    start: start_token.location.start,
                    end: block.location.end,
                },
            };
        }
        if token.lexeme.equal("for") {
            let start_token = self.expect("for").try;
            let ident = self.ident().try;
            self.expect("in").try;
            let range = self.expression_conditional().try;

            let body = self.block().try;

            return LStatement {
                data: Statement {
                    t_for: struct {
                        mode: "",
                        type_: nil,
                        ident: ident.data,
                        range: range,
                        block: body,
                    },
                },
                location: Location {
                    start: start_token.location.start,
                    end: body.location.end,
                },
            };
        }
        if self.peek().try.lexeme.equal("continue") {
            let start_token = self.expect("continue").try;
            let end_token = self.expect("semicolon").try;

            return LStatement {
                data: Statement {
                    t_continue: true,
                },
                location: self.span_location(start_token, end_token),
            };
        }
        if self.peek().try.lexeme.equal("break") {
            let start_token = self.expect("break").try;
            let end_token = self.expect("semicolon").try;

            return LStatement {
                data: Statement {
                    t_break: true,
                },
                location: self.span_location(start_token, end_token),
            };
        }
        if self.peek().try.lexeme.equal("at") {
            self.expect("at").try;
            let attr = self.attribute().try;

            return LStatement {
                data: Statement {
                    t_attribute: attr,
                },
                location: attr.location,
            };
        }

        let expr = self.expression().try;
        if self.peek().try.lexeme.equal("semicolon") {
            self.consume().try;

            return LStatement {
                data: Statement {
                    t_expr: struct {
                        expr: expr,
                    },
                },
                location: expr.location,
            };
        }
        if self.peek().try.lexeme.equal("equal") {
            self.consume().try;
            let rhs = self.expression().try;
            let end_token = self.expect("semicolon").try;

            return LStatement {
                data: Statement {
                    t_assign: struct {
                        lhs: expr,
                        rhs_type: nil,
                        rhs: rhs,
                    },
                },
                location: Location {
                    start: expr.location.start,
                    end: end_token.location.end,
                },
            };
        }

        // Mainly for dot completion
        if self.skip_errors {
            return LStatement {
                data: Statement {
                    t_expr: struct {
                        expr: expr,
                    },
                },
                location: expr.location,
            };
        }

        return _ or error::new(format("Unexpected token {} (statement)", self.peek().try.to_string())).context(ErrorSource {
            path: Path::new("<no module>"),
            location: self.peek().try.location,
        });
    }

    fun attributes(self): LAttributes or error {
        let lbracket = self.expect("lbracket").try;

        let attrs = make[vec[Attribute]]();

        while self.peek().try.lexeme != "rbracket" {
            let attr = self.attribute_inner().try;
            attrs.push(attr);

            if self.peek().try.lexeme.equal("comma") {
                self.expect("comma").try;
            } else {
                break;
            }
        }

        let rbracket = self.expect("rbracket").try;

        return LAttributes {
            data: attrs,
            location: Location {
                start: lbracket.location.start,
                end: rbracket.location.end,
            },
        };
    }

    fun attribute(self): LAttribute or error {
        let lbracket = self.expect("lbracket").try;

        let attr = self.attribute_inner().try;

        let rbracket = self.expect("rbracket").try;

        return LAttribute {
            data: attr,
            location: Location {
                start: lbracket.location.start,
                end: rbracket.location.end,
            },
        };
    }

    fun attribute_inner(self): Attribute or error {
        let name = self.ident().try;

        let args = make[vec[LExpression]]();

        if self.peek().try.lexeme == "lparen" {
            let lparen = self.expect("lparen").try;

            while self.peek().try.lexeme != "rparen" {
                let expr = self.expression().try;
                args.push(expr);

                if self.peek().try.lexeme.equal("comma") {
                    self.expect("comma").try;
                } else {
                    break;
                }
            }

            let rparen = self.expect("rparen").try;
        }

        return Attribute {
            name: name,
            args: args,
        };
    }

    fun expression_conditional(self): LExpression or error {
        return self.expression_(false).try;
    }

    fun let_statement(self): LStatement or error {
        let start_token = self.expect("let").try;
        let pattern = self.pattern().try;

        let t = Type {
            t_omit: true,
        };
        if self.peek().try.lexeme.equal("colon") {
            self.expect("colon").try;
            t = self.type_().try.data;
        }

        self.expect("equal").try;
        let value = self.expression().try;
        let end_token = self.expect("semicolon").try;

        return LStatement {
            data: Statement {
                t_let: struct {
                    pattern: pattern,
                    name_type: t,
                    expr: value,
                },
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun pattern(self): LPattern or error {
        let current = LPattern {
            data: Pattern {
                t_omit: true?,
                ..nil,
            },
            location: Location::unknown(),
        };

        if self.peek().try.lexeme.equal("underscore") {
            let token = self.consume().try;

            current = LPattern {
                data: Pattern {
                    t_omit: true?,
                    ..nil,
                },
                location: token.location,
            };
        } else {
            let name = self.ident().try;

            current = LPattern {
                data: Pattern {
                    t_ident: name.data?,
                    ..nil,
                },
                location: name.location,
            };
        }

        if self.peek().try.lexeme.equal("or") {
            self.consume().try;
            let rhs = self.pattern().try;

            return LPattern {
                data: Pattern {
                    t_or: struct {
                        lhs: current,
                        rhs: rhs,
                    }?,
                    ..nil,
                },
                location: Location {
                    start: current.location.start,
                    end: rhs.location.end,
                },
            };
        } else {
            return current;
        }
    }

    fun return_statement(self): LStatement or error {
        let start_token = self.expect("return").try;

        if self.peek().try.lexeme.equal("semicolon") {
            let end_token = self.expect("semicolon").try;

            return LStatement {
                data: Statement {
                    t_return: struct {
                        expr: LExpression {
                            data: Expression {
                                t_nil: false,
                            },
                            location: Location::unknown(),
                        },
                    },
                },
                location: self.span_location(start_token, end_token),
            };
        }

        let value = self.expression().try;
        let end_token = self.expect("semicolon").try;

        return LStatement {
            data: Statement {
                t_return: struct {
                    expr: value,
                },
            },
            location: self.span_location(start_token, end_token),
        };
    }

    fun expression(self): LExpression or error {
        return self.expression_(true).try;
    }

    fun expression_(self, with_struct: bool): LExpression or error {
        return self.term_5(with_struct).try;
    }

    fun term_5(self, with_struct: bool): LExpression or error {
        let current = self.term_4(with_struct).try;
        while true {
            if self.peek().try.lexeme.equal("double_amp") {
                self.expect("double_amp").try;
                let rhs = self.term_4(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "and",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
            } else if self.peek().try.lexeme.equal("double_pipe") {
                self.expect("double_pipe").try;
                let rhs = self.term_4(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "or",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
            } else if self.peek().try.lexeme.equal("or") {
                self.expect("or").try;
                let lhs = current?;
                if lhs!.data.t_omit != nil {
                    lhs = nil;
                }

                let rhs = self.term_4(with_struct).try;
                let rhs_optional = rhs?;
                if rhs.data.t_omit != nil {
                    rhs_optional = nil;
                }

                current = LExpression {
                    data: Expression {
                        t_enumor: struct {
                            lhs: lhs,
                            rhs: rhs_optional,
                            lhs_type: Type {
                                t_omit: true,
                            },
                            rhs_type: Type {
                                t_omit: true,
                            },
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
            } else {
                return current;
            }
        }

        return current;
    }

    fun term_4(self, with_struct: bool): LExpression or error {
        let current = self.term_3(with_struct).try;

        while true {
            if self.peek().try.lexeme.equal("double_equal") {
                self.expect("double_equal").try;

                let rhs = self.term_3(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "equal",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            } else if self.peek().try.lexeme.equal("not_equal") {
                self.expect("not_equal").try;

                let rhs = self.term_3(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "not_equal",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }

            return current;
        }
    }

    fun term_3(self, with_struct: bool): LExpression or error {
        let current = self.term_2(with_struct).try;

        if self.peek().try.lexeme.equal("lt") {
            self.expect("lt").try;

            let rhs = self.term_2(with_struct).try;

            return LExpression {
                data: Expression {
                    t_binop: struct {
                        binop: "lt",
                        type_: nil,
                        left: current,
                        right: rhs,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: rhs.location.end,
                },
            };
        } else if self.peek().try.lexeme.equal("gt") {
            self.expect("gt").try;

            let rhs = self.term_2(with_struct).try;

            return LExpression {
                data: Expression {
                    t_binop: struct {
                        binop: "gt",
                        type_: nil,
                        left: current,
                        right: rhs,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: rhs.location.end,
                },
            };
        } else if self.peek().try.lexeme.equal("gte") {
            self.expect("gte").try;

            let rhs = self.term_2(with_struct).try;

            return LExpression {
                data: Expression {
                    t_binop: struct {
                        binop: "gte",
                        type_: nil,
                        left: current,
                        right: rhs,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: rhs.location.end,
                },
            };
        } else if self.peek().try.lexeme.equal("lte") {
            self.expect("lte").try;

            let rhs = self.term_2(with_struct).try;

            return LExpression {
                data: Expression {
                    t_binop: struct {
                        binop: "lte",
                        type_: nil,
                        left: current,
                        right: rhs,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: rhs.location.end,
                },
            };
        } else if self.peek().try.lexeme.equal("double_dot") {
            self.expect("double_dot").try;
            let expr = self.term_3(with_struct).try;

            return LExpression {
                data: Expression {
                    t_range: struct {
                        start: current,
                        end: expr,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: expr.location.end,
                },
            };
        }

        return current;
    }

    fun term_2(self, with_struct: bool): LExpression or error {
        let current = self.term_1(with_struct).try;

        while true {
            if self.peek().try.lexeme.equal("plus") {
                self.expect("plus").try;

                let rhs = self.term_1(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "plus",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }
            if self.peek().try.lexeme.equal("minus") {
                self.expect("minus").try;

                let rhs = self.term_1(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "minus",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }
            if self.peek().try.lexeme.equal("as") {
                let end_token = self.expect("as").try;
                let t = self.type_().try;

                current = LExpression {
                    data: Expression {
                        t_as: struct {
                            expr: current,
                            source_type: Type {
                                t_omit: true,
                            },
                            target_type: t.data,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: end_token.location.end,
                    },
                };
                continue;
            }
            if self.peek().try.lexeme.equal("bit_and") {
                self.expect("bit_and").try;

                let rhs = self.term_4(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "bit_and",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }
            if self.peek().try.lexeme.equal("bit_or") {
                self.expect("bit_or").try;

                let rhs = self.term_4(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "bit_or",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }

            return current;
        }
    }

    fun term_1(self, with_struct: bool): LExpression or error {
        let current = self.term_0(with_struct).try;

        while true {
            if self.peek().try.lexeme.equal("star") {
                self.expect("star").try;

                let rhs = self.term_0(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "mult",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            } else if self.peek().try.lexeme.equal("slash") {
                self.expect("slash").try;

                let rhs = self.term_0(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "div",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            } else if self.peek().try.lexeme.equal("percent") {
                self.expect("percent").try;

                let rhs = self.term_0(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "mod",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            } else if self.peek().try.lexeme.equal("bit_shift_left") {
                self.expect("bit_shift_left").try;

                let rhs = self.term_0(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "bit_shift_left",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            } else if self.peek().try.lexeme.equal("bit_shift_right") {
                self.expect("bit_shift_right").try;

                let rhs = self.term_0(with_struct).try;

                current = LExpression {
                    data: Expression {
                        t_binop: struct {
                            binop: "bit_shift_right",
                            type_: nil,
                            left: current,
                            right: rhs,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: rhs.location.end,
                    },
                };
                continue;
            }

            return current;
        }
    }

    fun term_0(self, with_struct: bool): LExpression or error {
        let current = self.term_0_1(with_struct).try;

        while true {
            let token = self.peek().try;

            if token.lexeme.equal("lparen") {
                self.expect("lparen").try;

                let args = make[vec[LExpression]]();
                let expansion = nil as LExpression?;
                while !self.peek().try.lexeme.equal("rparen") {
                    // expansion
                    if self.peek().try.lexeme.equal("double_dot") {
                        self.expect("double_dot").try;
                        expansion = self.expression().try?;
                        break;
                    }

                    args.push(self.expression().try);

                    if self.peek().try.lexeme.equal("comma") {
                        self.expect("comma").try;
                    } else {
                        break;
                    }
                }
                let end_token = self.expect("rparen").try;

                if current.data.t_ident != nil {
                    if current.data.t_ident!.name == "unload" {
                        if args.length != 1 {
                            return _ or error::new(format("Expected 1 argument for unload, got {}", args.length.to_string()));
                        }

                        current = LExpression {
                            data: Expression {
                                t_unload: struct {
                                    expr: args.at(0),
                                    expr_type: Type {
                                        t_omit: true,
                                    },
                                },
                            },
                            location: Location {
                                start: current.location.start,
                                end: end_token.location.end,
                            },
                        };

                        continue;
                    }
                }

                current = LExpression {
                    data: Expression {
                        t_call: struct {
                            callee: current,
                            args: args,
                            variadic: nil,
                            expansion: expansion,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: end_token.location.end,
                    },
                };
            } else if token.lexeme.equal("dot") {
                self.expect("dot").try;

                let result or err = self.dot_after(current);
                if result != nil || !self.skip_errors {
                    if err != nil {
                        return _ or err!;
                    }

                    current = result!;
                }
            } else if with_struct && token.lexeme.equal("lbrace") {
                self.expect("lbrace").try;

                if current.data.t_ident == nil {
                    return _ or error::new(format("Expected identifier, got {}", current.data.to_string()));
                }

                let ident = current.data.t_ident!;
                let fields = make[vec[struct {
                    field: string,
                    value: LExpression,
                }]]();

                let expansion = nil as LExpression?;

                while !self.peek().try.lexeme.equal("rbrace") {
                    let field = self.ident().try;
                    self.expect("colon").try;
                    let value = self.expression().try;

                    fields.push(struct {
                        field: field.data,
                        value: value,
                    });

                    if self.peek().try.lexeme.equal("comma") {
                        self.expect("comma").try;

                        if self.peek().try.lexeme.equal("double_dot") {
                            self.expect("double_dot").try;
                            expansion = self.expression().try?;

                            if self.peek().try.lexeme.equal("comma") {
                                self.expect("comma").try;
                            }

                            break;
                        }
                    } else {
                        break;
                    }
                }
                let end_token = self.expect("rbrace").try;

                current = LExpression {
                    data: Expression {
                        t_record: RecordExpression {
                            name: ident.name,
                            fields: fields,
                            expansion: expansion,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: end_token.location.end,
                    },
                };
            } else if token.lexeme.equal("lbracket") {
                self.expect("lbracket").try;

                if current.data.t_ident == nil {
                    return _ or error::new(format(
                        "Expected identifier for record name, found {}",
                        current.data.to_string(),
                    ));
                }

                let t = self.type_().try;
                self.expect("rbracket").try;

                self.expect("lparen").try;
                let args = make[vec[LExpression]]();
                while !self.peek().try.lexeme.equal("rparen") {
                    args.push(self.expression().try);

                    if self.peek().try.lexeme.equal("comma") {
                        self.expect("comma").try;
                    } else {
                        break;
                    }
                }
                let end_token = self.expect("rparen").try;

                let ident = current.data.t_ident!.name;
                if ident == "make" {
                    current = LExpression {
                        data: Expression {
                            t_make: struct {
                                type_: t.data,
                                args: args,
                            },
                        },
                        location: Location {
                            start: current.location.start,
                            end: end_token.location.end,
                        },
                    };
                } else if ident == "sizeof" {
                    current = LExpression {
                        data: Expression {
                            t_sizeof: struct {
                                type_: t.data,
                            },
                        },
                        location: Location {
                            start: current.location.start,
                            end: end_token.location.end,
                        },
                    };
                } else {
                    return _ or error::new(format("Unknown builtin operator {}", ident));
                }
            } else if token.lexeme.equal("double_colon") {
                self.expect("double_colon").try;

                if current.data.t_ident == nil {
                    return _ or error::new(format(
                        "Expected identifier for record name, found {}",
                        current.data.to_string(),
                    ));
                }

                let name = self.ident().try;

                let path = Path::ident(current.data.t_ident!.name);
                path.push(name.data);

                current = LExpression {
                    data: Expression {
                        t_path: struct {
                            path: path,
                            resolved_path: nil,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: name.location.end,
                    },
                };
            } else if token.lexeme.equal("bang") {
                let end_token = self.expect("bang").try;

                current = LExpression {
                    data: Expression {
                        t_unwrap: struct {
                            type_: Type {
                                t_omit: true,
                            },
                            expr: current,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: end_token.location.end,
                    },
                };
            } else if token.lexeme.equal("question") {
                let end_token = self.expect("question").try;

                current = LExpression {
                    data: Expression {
                        t_wrap: struct {
                            type_: Type {
                                t_omit: true,
                            },
                            expr: current,
                        },
                    },
                    location: Location {
                        start: current.location.start,
                        end: end_token.location.end,
                    },
                };
            } else {
                return current;
            }
        }

        return _ or error::new("unreachable");
    }

    fun term_0_1(self, with_struct: bool): LExpression or error {
        if self.peek().try.lexeme.equal("ident") {
            let name = self.ident().try;

            return LExpression {
                data: Expression {
                    t_ident: struct {
                        name: name.data,
                        resolved_path: nil,
                    },
                },
                location: name.location,
            };
        }
        if self.peek().try.lexeme.equal("number") {
            let token = self.consume().try;
            if token.string_value!.compare_lte("2147483647") {
                return LExpression {
                    data: Expression {
                        t_i32: struct {
                            value: i32::parse(token.string_value!),
                        },
                    },
                    location: token.location,
                };
            } else if token.string_value!.compare_lte("4294967295") {
                return LExpression {
                    data: Expression {
                        t_u32: struct {
                            value: u32::parse(token.string_value!),
                        },
                    },
                    location: token.location,
                };
            } else {
                return _ or error::new(format("Invalid number {}", token.string_value!));
            }
        }
        if self.peek().try.lexeme.equal("self") {
            let token = self.expect("self").try;

            return LExpression {
                data: Expression {
                    t_self: true,
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("string") {
            let token = self.consume().try;

            return LExpression {
                data: Expression {
                    t_string: struct {
                        value: token.string_value!,
                        raw: token.raw,
                    },
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("raw_string") {
            let token = self.consume().try;

            return LExpression {
                data: Expression {
                    t_string: struct {
                        value: token.string_value!,
                        raw: token.raw,
                    },
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("lparen") {
            let start_token = self.expect("lparen").try;

            let expr = self.expression().try;

            let end_token = self.expect("rparen").try;

            return LExpression {
                data: Expression {
                    t_paren: expr,
                },
                location: self.span_location(start_token, end_token),
            };
        }
        if self.peek().try.lexeme.equal("bang") {
            let start_token = self.expect("bang").try;

            let expr = self.term_0(with_struct).try;

            return LExpression {
                data: Expression {
                    t_unop: struct {
                        unop: "not",
                        expr: expr,
                    },
                },
                location: Location {
                    start: start_token.location.start,
                    end: expr.location.end,
                },
            };
        }
        if self.peek().try.lexeme.equal("true") {
            let token = self.expect("true").try;

            return LExpression {
                data: Expression {
                    t_bool: true,
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("false") {
            let token = self.expect("false").try;

            return LExpression {
                data: Expression {
                    t_bool: false,
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("nil") {
            let token = self.expect("nil").try;

            return LExpression {
                data: Expression {
                    t_nil: true,
                },
                location: token.location,
            };
        }
        if self.peek().try.lexeme.equal("struct") {
            let start_token = self.expect("struct").try;
            self.expect("lbrace").try;

            let fields = make[vec[struct {
                data: struct {
                    field: string,
                    value: LExpression,
                },
                location: Location,
            }]]();

            while !self.peek().try.lexeme.equal("rbrace") {
                let ident = self.ident().try;
                let colon_token = self.expect("colon").try;
                let value = self.expression().try;

                fields.push(struct {
                    data: struct {
                        field: ident.data,
                        value: value,
                    },
                    location: Location {
                        start: ident.location.start,
                        end: value.location.end,
                    },
                });

                if self.peek().try.lexeme.equal("comma") {
                    self.expect("comma").try;
                } else {
                    break;
                }
            }
            let end_token = self.expect("rbrace").try;

            return LExpression {
                data: Expression {
                    t_anonymous_record: struct {
                        fields: fields,
                        type_: nil,
                    },
                },
                location: self.span_location(start_token, end_token),
            };
        }
        if self.peek().try.lexeme.equal("underscore") {
            let token = self.expect("underscore").try;

            return LExpression {
                data: Expression {
                    t_omit: true,
                },
                location: token.location,
            };
        }

        return _ or error::new(format("Unexpected token {} (term)", self.peek().try.lexeme.to_string()));
    }

    fun dot_after(self, current: LExpression): LExpression or error {
        let peeked = self.peek().try;
        if peeked.lexeme == "try" {
            let end_token = self.expect("try").try;

            return LExpression {
                data: Expression {
                    t_try: current,
                },
                location: Location {
                    start: current.location.start,
                    end: end_token.location.end,
                },
            };
        } else if peeked.lexeme == "lparen" {
            self.expect("lparen").try;
            let expr = self.expression().try;
            let end_token = self.expect("rparen").try;

            return LExpression {
                data: Expression {
                    t_index: struct {
                        expr: current,
                        expr_type: nil as Type?,
                        index: expr,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: end_token.location.end,
                },
            };
        } else {
            let field = self.ident().try;

            return LExpression {
                data: Expression {
                    t_project: struct {
                        expr: current,
                        field: field,
                        type_: nil as Type?,
                        resolved_path: nil,
                        interface_call: false,
                    },
                },
                location: Location {
                    start: current.location.start,
                    end: field.location.end,
                },
            };
        }
    }

    fun span_location(self, start: Token, end: Token): Location {
        return Location {
            start: start.location.start,
            end: end.location.end,
        };
    }
}

