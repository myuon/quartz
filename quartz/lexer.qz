struct Token {
    lexeme: string,
    string_value: string?,
    position: i32,
}

module Token {
    fun to_string(self): string {
        let value = "nil";
        if self.string_value != nil {
            value = self.string_value!;
        }

        return format("Token({}, {})", self.lexeme, value);
    }
}

struct Lexer {
    position: i32,
    tokens: vec[Token],
}

module Lexer {
    fun new(): Lexer {
        return Lexer {
            position: 0,
            tokens: make[vec[Token]](),
        };
    }

    fun consume_space(self, input: string): i32 {
        let consumed = 0;
        while is_space(input, self.position) {
            self.position = self.position + 1;
            consumed = consumed + 1;
        }

        return consumed;
    }

    fun consume_ident(self, input: string): string? {
        let ident = make[vec[byte]]();
        while is_included(
            input,
            self.position,
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_",
        ) {
            ident.push(input.data.at(self.position));
            self.position = self.position + 1;
        }

        if ident.length == 0 {
            return nil;
        }

        return vec_byte_to_string(ident)?;
    }

    fun consume_number(self, input: string): string? {
        let number = make[vec[byte]]();
        while is_included(input, self.position, "0123456789") {
            number.push(input.data.at(self.position));
            self.position = self.position + 1;
        }

        if number.length == 0 {
            return nil;
        }

        return vec_byte_to_string(number)?;
    }

    fun consume_string_literal(self, input: string): string? {
        let quote = 34 as byte;
        let str = make[vec[byte]]();
        if input.at(self.position) != quote {
            return nil;
        }

        self.position = self.position + 1;

        while input.at(self.position) != quote {
            str.push(input.at(self.position));
            self.position = self.position + 1;
        }

        self.position = self.position + 1;

        return vec_byte_to_string(str)?;
    }

    fun consume_raw_string_literal(self, input: string): string? {
        let backquote = 96 as byte;
        let str = make[vec[byte]]();
        if input.at(self.position) != backquote {
            return nil;
        }

        self.position = self.position + 1;

        while input.at(self.position) != backquote {
            str.push(input.at(self.position));
            self.position = self.position + 1;
        }

        self.position = self.position + 1;

        return vec_byte_to_string(str)?;
    }

    fun consume_comment(self, input: string): string? {
        if !is_prefix(input, self.position, "//") {
            return nil;
        }

        self.position = self.position + 2;

        let comment = make[vec[byte]]();
        while input.at(self.position) != 10 as byte {
            comment.push(input.at(self.position));
            self.position = self.position + 1;
        }

        return vec_byte_to_string(comment)?;
    }

    fun match(self, input: string, token: string, token_name: string): bool {
        if is_prefix(input, self.position, token) {
            self.tokens.push(Token {
                lexeme: token_name,
                string_value: nil,
                position: self.position,
            });
            self.position = self.position + token.length;
            return true;
        }

        return false;
    }

    fun match_term(self, input: string, token: string, token_name: string): bool {
        if is_prefix(input, self.position, token) && is_term_boundary(input, self.position + token.length) {
            self.tokens.push(Token {
                lexeme: token_name,
                string_value: nil,
                position: self.position,
            });
            self.position = self.position + token.length;
            return true;
        }

        return false;
    }

    fun run(self, input: string): nil or error {
        while self.position < input.length {
            let p = self.consume_space(input);
            if p > 0 {
                continue;
            }

            let comment = self.consume_comment(input);
            if comment != nil {
                continue;
            }

            if self.match_term(input, "fun", "fun") {
                continue;
            }
            if self.match_term(input, "let", "let") {
                continue;
            }
            if self.match_term(input, "return", "return") {
                continue;
            }
            if self.match_term(input, "if", "if") {
                continue;
            }
            if self.match_term(input, "else", "else") {
                continue;
            }
            if self.match_term(input, "while", "while") {
                continue;
            }
            if self.match_term(input, "struct", "struct") {
                continue;
            }
            if self.match_term(input, "as", "as") {
                continue;
            }
            if self.match_term(input, "module", "module") {
                continue;
            }
            if self.match_term(input, "self", "self") {
                continue;
            }
            if self.match_term(input, "for", "for") {
                continue;
            }
            if self.match_term(input, "in", "in") {
                continue;
            }
            if self.match_term(input, "true", "true") {
                continue;
            }
            if self.match_term(input, "false", "false") {
                continue;
            }
            if self.match_term(input, "nil", "nil") {
                continue;
            }
            if self.match_term(input, "or", "or") {
                continue;
            }
            if self.match_term(input, "import", "import") {
                continue;
            }
            if self.match_term(input, "continue", "continue") {
                continue;
            }
            if self.match_term(input, "break", "break") {
                continue;
            }
            if self.match(input, "==", "double_equal") {
                continue;
            }
            if self.match(input, "!=", "not_equal") {
                continue;
            }
            if self.match(input, ">=", "gte") {
                continue;
            }
            if self.match(input, "<=", "lte") {
                continue;
            }
            if self.match(input, "<<", "bit_shift_left") {
                continue;
            }
            if self.match(input, ">>", "bit_shift_right") {
                continue;
            }
            if self.match(input, "::", "double_colon") {
                continue;
            }
            if self.match(input, "..", "double_dot") {
                continue;
            }
            if self.match(input, "&&", "double_amp") {
                continue;
            }
            if self.match(input, "||", "double_pipe") {
                continue;
            }
            if self.match(input, "(", "lparen") {
                continue;
            }
            if self.match(input, ")", "rparen") {
                continue;
            }
            if self.match(input, "{", "lbrace") {
                continue;
            }
            if self.match(input, "}", "rbrace") {
                continue;
            }
            if self.match(input, "[", "lbracket") {
                continue;
            }
            if self.match(input, "]", "rbracket") {
                continue;
            }
            if self.match(input, ":", "colon") {
                continue;
            }
            if self.match(input, ";", "semicolon") {
                continue;
            }
            if self.match(input, "+", "plus") {
                continue;
            }
            if self.match(input, "-", "minus") {
                continue;
            }
            if self.match(input, "*", "star") {
                continue;
            }
            if self.match(input, "/", "slash") {
                continue;
            }
            if self.match(input, "%", "percent") {
                continue;
            }
            if self.match(input, "=", "equal") {
                continue;
            }
            if self.match(input, "<", "lt") {
                continue;
            }
            if self.match(input, ">", "gt") {
                continue;
            }
            if self.match(input, ",", "comma") {
                continue;
            }
            if self.match(input, ".", "dot") {
                continue;
            }
            if self.match(input, "!", "bang") {
                continue;
            }
            if self.match(input, "?", "question") {
                continue;
            }
            if self.match(input, "_", "underscore") {
                continue;
            }
            if self.match(input, "|", "bit_or") {
                continue;
            }
            if self.match(input, "&", "bit_and") {
                continue;
            }

            let number = self.consume_number(input);
            if number != nil {
                self.tokens.push(Token {
                    lexeme: "number",
                    string_value: number,
                    position: self.position,
                });

                continue;
            }

            let ident = self.consume_ident(input);
            if ident != nil {
                self.tokens.push(Token {
                    lexeme: "ident",
                    string_value: ident,
                    position: self.position,
                });

                continue;
            }

            let str = self.consume_string_literal(input);
            if str != nil {
                self.tokens.push(Token {
                    lexeme: "string",
                    string_value: str,
                    position: self.position,
                });

                continue;
            }

            let str = self.consume_raw_string_literal(input);
            if str != nil {
                self.tokens.push(Token {
                    lexeme: "string",
                    string_value: str,
                    position: self.position,
                });

                continue;
            }

            return _ or error::new(`== Abort ==
position: {}
input: {}`.format(
                self.position.to_string(),
                input.slice_start(self.position),
            ));
        }

        return nil;
    }
}

fun is_term_boundary(input: string, position: i32): bool {
    let ch = input.at(position) as i32;
    if 48 < ch && ch < 57 {
        return false;
    }
    if 65 < ch && ch < 90 {
        return false;
    }
    if 97 < ch && ch < 122 {
        return false;
    }
    if ch == 95 {
        return false;
    }

    return true;
}

