struct Token {
    lexeme: string,
    string_value: string?,
    position: i32,
}

module Token {
    fun to_string(self): string {
        let value = "nil";
        if self.string_value != nil {
            value = self.string_value!;
        }

        return format("Token({}, {})", self.lexeme, value);
    }
}

struct Lexer {
    position: i32,
    tokens: vec[Token],
}

module Lexer {
    fun new(): Lexer {
        return Lexer {
            position: 0,
            tokens: make[vec[Token]](),
        };
    }

    fun consume_space(self, input: string): i32 {
        let consumed = 0;
        while is_space(input, self.position) {
            self.position = self.position + 1;
            consumed = consumed + 1;
        }

        return consumed;
    }

    fun consume_ident(self, input: string): string? {
        let ident = make[vec[byte]]();
        while is_included(
            input,
            self.position,
            "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_",
        ) {
            ident.push(input.data.at(self.position));
            self.position = self.position + 1;
        }

        if ident.length == 0 {
            return nil;
        }

        return vec_byte_to_string(ident)?;
    }

    fun consume_number(self, input: string): string? {
        let number = make[vec[byte]]();
        while is_included(input, self.position, "0123456789") {
            number.push(input.data.at(self.position));
            self.position = self.position + 1;
        }

        if number.length == 0 {
            return nil;
        }

        return vec_byte_to_string(number)?;
    }

    fun match(self, input: string, token: string, token_name: string): bool {
        if is_prefix(input, self.position, token) {
            self.tokens.push(Token {
                lexeme: token_name,
                string_value: nil,
                position: self.position,
            });
            self.position = self.position + token.length;
            return true;
        }

        return false;
    }

    fun run(self, input: string): nil or error {
        while self.position < input.length {
            let p = self.consume_space(input);
            if p > 0 {
                continue;
            }

            if self.match(input, "fun", "fun") {
                continue;
            }
            if self.match(input, "let", "let") {
                continue;
            }
            if self.match(input, "return", "return") {
                continue;
            }
            if self.match(input, "if", "if") {
                continue;
            }
            if self.match(input, "else", "else") {
                continue;
            }
            if self.match(input, "while", "while") {
                continue;
            }
            if self.match(input, "struct", "struct") {
                continue;
            }
            if self.match(input, "==", "double_equal") {
                continue;
            }
            if self.match(input, "(", "lparen") {
                continue;
            }
            if self.match(input, ")", "rparen") {
                continue;
            }
            if self.match(input, "{", "lbrace") {
                continue;
            }
            if self.match(input, "}", "rbrace") {
                continue;
            }
            if self.match(input, "[", "lbracket") {
                continue;
            }
            if self.match(input, "]", "rbracket") {
                continue;
            }
            if self.match(input, ":", "colon") {
                continue;
            }
            if self.match(input, ";", "semicolon") {
                continue;
            }
            if self.match(input, "+", "plus") {
                continue;
            }
            if self.match(input, "-", "minus") {
                continue;
            }
            if self.match(input, "*", "star") {
                continue;
            }
            if self.match(input, "=", "equal") {
                continue;
            }
            if self.match(input, "<", "lt") {
                continue;
            }
            if self.match(input, ",", "comma") {
                continue;
            }
            if self.match(input, ".", "dot") {
                continue;
            }

            let number = self.consume_number(input);
            if number != nil {
                self.tokens.push(Token {
                    lexeme: "number",
                    string_value: number,
                    position: self.position,
                });

                continue;
            }

            let ident = self.consume_ident(input);
            if ident != nil {
                self.tokens.push(Token {
                    lexeme: "ident",
                    string_value: ident,
                    position: self.position,
                });

                continue;
            }

            return _ or error::new(`== Abort ==
position: {}
input: {}`.format(
                self.position.to_string(),
                input.slice_start(self.position),
            ));
        }

        return nil;
    }
}

